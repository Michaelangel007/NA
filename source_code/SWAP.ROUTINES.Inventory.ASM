; ============================================
; Copyright (C) 2016-2018. 6502 Workshop, LLC
; contact: mark@6502workshop.com
; ============================================


;************************INCLUDE FILE*****************************
;(do not assemble stand-alone.  )
				.TF     swap.routines.inventory.bin,BIN
				;.OR		$9600			**Always put before .TF directive and never use again in program
				.OR		$0000			**Always put before .TF directive and never use again in program
				.EB		OFF

				

;=====SWAP.ROUTINES.INVENTORY.ASM DOCUMENTATION====================================
;
;-Overview: Inventory Module
;The inventory module is actually a collection of sub_modules (currently 7). Sub_modules are only
;read from disk into memory when needed. For example, the first menu that appears after the player 
;opens the inventory window is the stats menu. The status menu is it's own sub_module. The weapons/armor/misc_items/spells
;menu are another sub_module. Ready/Unready equipment is another sub_module. 
;
;-Sub_modules: summary
;The general idea is for some common entrance code to be loaded first and kept in memory at all times,
;and then load each sub_module as needed, but keep the sub_modules in memory for the duration of the inventory session
;so that there are less disk loades if the player repeats actions like switching between the same menus or ready/unready of
;weapons. To support this, the patch sections for the sub_modules don't overlap. Each sub_module has memory space reserved for it
;such that all sub_modules can be in memory at the same time. 
;
;-Sub_modules: more detail 
;When the inventory window is first opened, the stats sub_module is read from disk but the weapons/etc. sub_module 
;is not read from disk, until the player switches to that menu. The Ready/Unready equipment sub_module is not
;read from disk until the player attempts to ready or unready equipment. 
;
;Once a sub_module is read into memory, it stays in memory for the remainder of the inventory session (until inventory exit occurs)
;As a result, if the player switches back and forth between menus, or repeats other activities such as ready/unready, the disk load time
;will be less or eliminated. Sometimes disk loads will still occur because the sub_module itself loads data from 
;disk, such as the weapons/etc. menus, which read data from the master item tables to display the on screen information. 
;
;Each sub_module has it's own .ASM file and the entrance routine for each sub_module is at the top of it's .ASM file. 
;The .ASM files for each sub_module are .IN includes in the patch section for each sub_module (more on patch sections below).
;
;
;
;-CALCULATE.COMBAT.STATS
;This is a sub_module which might run when the inventory module exits or when the player switches from the weapons/etc. menus to 
;a different menu. It only runs if the INV.RE.UPDATE_DAMAGE.FLAG or INV.RE.UPDATE_DEFENSE.FLAG are set by the ready/unready equipment routine. 
;This avoids the lengthy disk activity generated by CALCULATE.COMBAT.STATS (from accessing the master item table) unless it is necessary. 
;There is a way to make it faster when it does run, see ";-Disk Speed Improvement Ideas" in SWAP.ROUTINES.INV.combat_stats.asm
;
;
;-Inventory State Loops
;There are 3 state loops: INV_4.STATE.LOOP (weapons/armor/misc_items/spells menus) INV.STATS.STATE_LOOP (stats menu: regular entrance)
;and .COMBAT.STATS.STATE_LOOP (stats menu: combat entrance)
;
;The weapons/etc. menus and stats menu have separate state loops primarily because the left/right arrow keys have different functionality. 
;.COMBAT.STATS.STATE_LOOP is a separate state loop because a local copy of the stats menu is stored in the combat module so that it can be accessed
;without a disk load. This is achieve by making SWAP.ROUTINES.Combat.stats_summary.ASM a .IN include of both
;SWAP.ROUTINES.Combat.ASM and SWAP.ROUTINES.INV.stats_summary.ASM
;
;.COMBAT.STATS.STATE_LOOP (not yet built) will replicate the functionality of INV.STATS.STATE_LOOP for local keys and when a key is pressed
;(tab or menu hot key) that changes menus then appropriate sub_module will be loaded and for the duration of the inventory session
;state will be managed by INV_4.STATE.LOOP and/or INV.STATS.STATE_LOOP
;
;The state loops use INV.NEXT.MENU and INV.STATS.NEXT_SCREEN to switch menus and switch screens within the stats menu. 
;The program flow within the state loops is managed via JMPs instead of JSRs to avoid a circular path that overflows the stack. 
;
;
;-This .ASM file
;The inventory binary file (swap.routines.inventory.bin) created by the .TF directive of this .ASM file 
;contains the inventory module source code and also player and game inventory/item related data. Seperate files
;are not used to minimize the frequency that files are opened by ProRWTS, which is a very slow disk operation.
;
;--DATA--
;CHR_SHEET.PC.READIED_EQUIP.START
;INV.PLAYER.INVENTORY.DATA.START
;INV.ITEM_TABLES.START
;
;--INVENTORY SUB-MODULES
;
;Each inventory sub-module is setup in it's own patch section, in this source code file (below)
;to match up to the memory addresses that it is loaded to.
;Each patch section has labels for the start/end of the section
;both inside and outside of the patch section. 
;
;For example, the start label outside the patch section is used in conjunction with the
;label for the start of this file to calculate the seek bytes for each 
;sub-module. For the seek/read offsets see ;==INVENTORY FILE OFFSETS==
;
;
;
;
;==Inventory Manager launched from combat(tenative)==
;When the player launches the inventory manager, the entire combat module is swapped out to aux memory
;and when the player exits the inventory manager, the combat module is swapped back in. 
;
;
;===ADDING A SUB_MODULE====
;
;expand INV.SUB_MODULE.LOAD_FLAGS unless the new sub_module already has a load flag assigned
;add a patch section below. The .PH should be set to the patch end label of the patch section above it. 
;		if inserting a new patch section between two existing, make sure to change the .PH of the exiting patch below the new section to be the end lable of the new patch section. 
;add to INV.FILE.OFFSETS
;add to INV.SUB_MODULE.FILE.PARAMETERS
;
;Also see "---Add New Sub-Module---" in INV.INVENTORY_MODULE.ENTRANCE 
;
;===MODULE MEMORY MAP===  (OUT OF DATE)
;$9600-$BFFF	main inventory program
;$BA00-BFFF*	Map Object Arrays (npc schedule, mob, general, and npc) ;I'm not sure yet if these are required to stay in memory while the inventory module
;				is loaded. If not they would need to be loaded again from disk of course. 
;	;$BD00-BFFF*	Mob, General and NPC map object arrays 
;
;
;=================================================================================



SRTN.INVENTORY.FILE.START
;LOCAL POINTERS/CONSTANTS
@START
INV.MAIN_MODULE.END						.EQ $B9FF
INV.PLAYER.INVENTORY.DATA				.EQ INV.MAIN_MODULE.END+1 ;This is the main inventory data array pointer

;INV.PLAYER.INVENTORY.DATA.PATCH_END			.EQ $BFFF ;#CONSTANT. It's really END+1
INV.PLAYER.INVENTORY.DATA.RECORD_SIZE	.EQ $06 ;#CONSTANT
INV.PLAYER.INVENTORY.DATA.LESS_ONE_RECORD	.EQ INV.PLAYER.INVENTORY.DATA-INV.PLAYER.INVENTORY.DATA.RECORD_SIZE

@END


INV.DATA.INVENTORY
;(player readied equipment, player inventory, master game items table)			
				.IN 	data.game.inventory.ASM
				

INV.DATA.MERCHANT_PROFILE
				.IN 	data.game.merchant_profile.ASM


				
INV.MODULE.START ;start of the submodule patch sections	


;==========================================================
INV.ENTRANCE.START
@START
	.PH SWAP_SPACE.MAIN_MEMORY
INV.ENTRANCE.PATCH_START
	
			.IN 	swap.routines.inv.entrance_exit.asm
	
INV.ENTRANCE.PATCH_END
	.EP ;end patch mode
INV.ENTRANCE.END
@END

;==========================================================
;

;
;==========================================================
INV_0.STATS_SUMMARY.START	;screen0	
@START	
	.PH INV.ENTRANCE.PATCH_END ;start patch mode
INV_0.STATS_SUMMARY.PATCH_START	
	

	.IN 	swap.routines.inv.stats_summary.asm


INV_0.STATS_SUMMARY.PATCH_END
	.EP ;end patch mode
INV_0.STATS_SUMMARY.END	
@END
;==========================================================
;

;
;==========================================================
INV_1.READIED_EQUIPMENT.START	;screen1		
@START
	.PH INV_0.STATS_SUMMARY.PATCH_END ;start patch mode
INV_1.READIED_EQUIPMENT.PATCH_START	
	

	.IN 	swap.routines.inv.readied_equipment.asm


INV_1.READIED_EQUIPMENT.PATCH_END
	.EP ;end patch mode
INV_1.READIED_EQUIPMENT.END	
@END
;==========================================================
;

;
;==========================================================
INV_2.COMBAT_STATS.START	;screen2		
@START
	.PH INV_1.READIED_EQUIPMENT.PATCH_END ;start patch mode
INV_2.COMBAT_STATS.PATCH_START	
	

	.IN 	swap.routines.inv.combat_stats.asm


INV_2.COMBAT_STATS.PATCH_END
	.EP ;end patch mode
INV_2.COMBAT_STATS.END	
@END
;==========================================================
;

;
;==========================================================
INV_3.SKILLS.START	;screen3
@START		
	.PH INV_2.COMBAT_STATS.PATCH_END ;start patch mode
INV_3.SKILLS.PATCH_START	
	

	.IN 	swap.routines.inv.skills.asm	
	
INV_3.SKILLS.PATCH_END
	.EP ;end patch mode
	
INV_0.THRU.INV_03.SIZE = INV_3.SKILLS.PATCH_END-INV_0.STATS_SUMMARY.PATCH_START+1

;SIZE UNDERFLOW CHECK
	.DO INV_0.THRU.INV_03.SIZE<$200
	
	.ER	F,***The INV_0-INV_3 block of submodules is less than $200 bytes. Search for "INV_3 Extended Error message"
	;INV_3 Extended Error message
	;This is a problem because INV_8.1.DATA_STORAGE.START (contains INV_8.1.MASTER_PRICE_TABLE.DATA) is loaded into this block of memory by INV_8, and INV_8.1 is $200 bytes in size. 
	
	.FI ;END IF
	
	
INV_3.SKILLS.END	
@END
;==========================================================
;



;
;==========================================================
INV_4.1a.SHARED_ROUTINES.START
@START
	.PH INV_3.SKILLS.PATCH_END
INV_4.1a.DISPLAY_PLAYER_INVENTORY.PATCH_START
	
			.IN 	SWAP.ROUTINES.INV_4.1a.SHARED_ROUTINES.ASM

INV_4.1a.SHARED_ROUTINES.PATCH_END
	.EP ;end patch mode
INV_4.1a.SHARED_ROUTINES.END
@END
;==========================================================
;

;
;==========================================================
INV_4.1b.SHARED_ROUTINES.START
@START
	.PH INV_4.1a.SHARED_ROUTINES.PATCH_END
INV_4.1b.DISPLAY_PLAYER_INVENTORY.PATCH_START
	
			.IN 	SWAP.ROUTINES.INV_4.1b.SHARED_ROUTINES.ASM

INV_4.1b.SHARED_ROUTINES.PATCH_END
	.EP ;end patch mode
INV_4.1b.SHARED_ROUTINES.END
@END
;==========================================================
;

;
;==========================================================
INV_4.DISPLAY_PLAYER_INVENTORY.START
@START
	.PH INV_4.1b.SHARED_ROUTINES.PATCH_END
INV_4.DISPLAY_PLAYER_INVENTORY.PATCH_START
	
			.IN 	swap.routines.inv.display_inventory.ASM

INV_4.DISPLAY_PLAYER_INVENTORY.PATCH_END
	.EP ;end patch mode
INV_4.DISPLAY_PLAYER_INVENTORY.END
@END
;==========================================================
;


;
;==========================================================
INV_5 ;left blank for expansion of auto-launched modules
@START
	;.PH 
INV_5.PATCH_START

			;.IN 	c:\my_code\source_code\???.ASM

INV_5.PATCH_END
	.EP ;end patch mode
INV_5.END
@END
;==========================================================
;

;
;==========================================================
INV_6.READY_UNREADY.START
@START
	.PH INV_4.DISPLAY_PLAYER_INVENTORY.PATCH_END
INV_6.READY_UNREADY.PATCH_START

			.IN 	swap.routines.inv.ready_unready.ASM

INV_6.READY_UNREADY.PATCH_END
	.EP ;end patch mode
INV_6.READY_UNREADY.END
@END
;==========================================================
;

;
;==========================================================
INV_7.CALCULATE.COMBAT.STATS.START
@START
	.PH INV_6.READY_UNREADY.PATCH_END
INV_7.CALCULATE.COMBAT.STATS.PATCH_START
	
			.IN 	swap.routines.inv.calc.combat.stats.ASM

INV_7.CALCULATE.COMBAT.STATS.PATCH_END
	.EP ;end patch mode
INV_7.CALCULATE.COMBAT.STATS.END
@END
;==========================================================
;


INV.FILLER.START
@START
	.PH INV_7.CALCULATE.COMBAT.STATS.PATCH_END ;start patch mode
	
	; .NO $B900

; INV.DEBUG.LOG .BS $100
; INV.DEBUG.LOG.INDEX	.EQ INV.DEBUG.LOG+$FF

INV.DEBUG.LOG .EQ EVENT.FLAGS
INV.DEBUG.LOG.INDEX	.EQ INV.DEBUG.LOG+$FF
INV.DEBUG.LOG_PLUS_80	.EQ EVENT.FLAGS+$80

INV.FILLER.PATCH_START

	.NO INV.MAIN_MODULE.END-1 ;**OPT** Speed. Disk. optimize the .NO to the actual space needed. 
							 ;-1 is used to make sure the code ends $2 bytes before INV.PLAYER.INVENTORY.DATA starts at $BA00.
							 ;These 2 bytes are used to store the inventory array length for use with the sort routine. 
							 
INV.FILLER.PATCH_END
	.EP ;end patch mode
INV.FILLER.END
@END



;==============!!!***ENTERING SHARED MEMORY ZONE***!!!===============================================
;(sub_modules below this point are read into the same memory range as one or more sub_modules above)
@START


;INV_8.MERCHANT_TRANSACTIONS
@START

;
;==========================================================
INV_8.MERCHANT_TRANSACTIONS.START
@START
	.PH INV_4.GROUP2.SUBROUTINES.START ;this sub_module shares the same memory range as INV_6, INV_7, and part of INV_4
	;*****this .PH is inside the INV_4 include file. 
INV_8.MERCHANT_TRANSACTIONS.PATCH_START
	
			.IN 	swap.routines.inv.merchant_transactions.ASM

INV_8.MERCHANT_TRANSACTIONS.PATCH_END
	.EP ;end patch mode
INV_8.MERCHANT_TRANSACTIONS.END

INV_8.1.DATA_STORAGE.START
@START
	.PH INV_0.STATS_SUMMARY.PATCH_START ;this sub_module shares the same memory range as INV_6, INV_7
INV_8.1.DATA_STORAGE.PATCH_START
	
;-----
INV_8.1.MASTER_PRICE_TABLE.DATA									
;datagram: (sell_price_lo, sell_price_ho)
				.IN 	data.game.master_price_table.ASM
				
INV_8.1.MASTER_PRICE_TABLE.RECORD_SIZE	.EQ	$02 ;#CONSTANT

;text blocks
INV_8.TEXT_BLOCK.HEADER1			.AZ -/ITEM         PRICE/
INV_8.TEXT_BLOCK.GOLD				.AZ -/GOLD/
INV_8.TEXT_BLOCK.BUY_SELL			.AZ -/(B)uy       (S)ell/
													
INV_8.TEXT_BLOCK.BUY_QTY			.AZ -#$8D,#$8D,/How many?/			
INV_8.TEXT_BLOCK.GOLD_TOO_LOW		.AZ -#$8D,#$8D,/Are you trying to cheat me?? Come back when you have more gold./
INV_8.TEXT_BLOCK.ITEM_PURCHASED		.AZ -#$8D,#$8D,/Sold! Use it with care./

INV_8.TEXT_BLOCK.ITEM_PURCHASE_FAILED 	.AZ -#$8D,#$8D,/You can't carry that many!/
INV_8.TEXT_BLOCK.ABORT_TRANSACTION		.AZ -#$8D,#$8D,/Stop wasting my time!/

INV_8.TEXT_BLOCK.KNOWN_SELL_PRICE1				.AZ -#$8D,#$8D,/I'll give you /
;INV_8.TEXT_BLOCK.UNKNOWN_KNOWN_SELL_PRICE2		.AZ -#$8D,/gold pieces for it. Deal?/,#$8D,/(Y/,#$AF,/N, sell (A)ll)/
INV_8.TEXT_BLOCK.UNKNOWN_KNOWN_SELL_PRICE2		.AZ -#$8D,/gold pieces. Deal?/,#$8D,/(Y)es, (N)o, (A)ll/


INV_8.TEXT_BLOCK.UNKNOWN_SELL_PRICE1			.AZ -#$8D,#$8D,/Hmmm... I don't see many of those. I can only offer you /

INV_8.TEXT_BLOCK.ITEM_SOLD					.AZ -#$8D,#$8D,/Done! Here is your gold./				
INV_8.TEXT_BLOCK.CANT_CARRY_MORE_GOLD		.AZ -#$8D,#$8D,/You can't carry more gold./	
INV_8.TEXT_BLOCK.ALL_UNITS_READIED			.AZ -#$8D,#$8D,/You must unready the item first./	
INV_8.TEXT_BLOCK.ITEM_SALE.NOT_PERMITTED 	.AZ -#$8D,#$8D,/I've never seen one of those. No deal./	
 
INV_8.COMMAND_TABLE1.KNOWN_PRICE
@START


	

;COMMAND TABLE SIZE (bytes)
	.DB INV_8.COMMAND_TABLE1.RECORDS.END-INV_8.COMMAND_TABLE1.RECORDS.START+1 ;+1 the byte quantity includes this byte that we are writing to the file with this directive. 
INV_8.COMMAND_TABLE1.RECORDS.START

		

.CT.DISPLAY_KNOWN_PRICE
@START	
;MERCHANT RESPONSE (PART 1)

	;set command code: (LO nibble = print_routine_code (PRC), HO nibble = ascii_string_source_code (ASSC)
	.DA #$12 ;external ascii table, PRINT.TEXT.WINDOW

INV_8.DISPLAY_KNOWN_PRICE.TEXT_BLOCK1.LABEL
	;command parameter fields (PRC)
	.DA #INV_8.TEXT_BLOCK.KNOWN_SELL_PRICE1
	.DA /INV_8.TEXT_BLOCK.KNOWN_SELL_PRICE1
	
;VARIABLE

	;set command code: (LO nibble = print_routine_code (PRC), HO nibble = ascii_string_source_code (ASSC)
	.DA #$17 ;variable, PRINT.HEX16.LJ
	;command parameter fields (PRC)
	.DA #RESULT
	.DA /RESULT

;MERCHANT RESPONSE (PART 2)

	;set command code: (LO nibble = print_routine_code (PRC), HO nibble = ascii_string_source_code (ASSC)
	.DA #$12 ;external ascii table, PRINT.TEXT.WINDOW

	;command parameter fields (PRC)
	.DA #INV_8.TEXT_BLOCK.UNKNOWN_KNOWN_SELL_PRICE2	
	.DA /INV_8.TEXT_BLOCK.UNKNOWN_KNOWN_SELL_PRICE2	
	
@END
	

INV_8.COMMAND_TABLE1.RECORDS.END

INV_8.COMMAND_TABLE1.SIZE = INV_8.COMMAND_TABLE1.RECORDS.END-INV_8.COMMAND_TABLE1.RECORDS.START+1

;VERIFY COMMAND TABLE SIZE <= !256bytes
	.DO INV_8.COMMAND_TABLE1.SIZE>$100
	
	.ER	F,***INV_8.COMMAND_TABLE1 exceeds !256 bytes
	
	.FI ;END IF
@END

;-----

				
INV_8.1.DATA_STORAGE.PATCH_END
	.EP ;end patch mode


INV_8.1.DATA_STORAGE.SIZE = INV_8.1.DATA_STORAGE.PATCH_END-INV_8.1.DATA_STORAGE.PATCH_START


	
;SIZE OVERFLOW CHECK
	.DO INV_8.1.DATA_STORAGE.SIZE>INV_0.THRU.INV_03.SIZE
	
	.ER	F,***INV_8.1.DATA_STORAGE is great than the size of the INV_0-INV_3 block of submodules. Search for "INV_3 Extended Error message"
	;INV_3 Extended Error message
	;This is a problem because INV_8.1.DATA_STORAGE (contains INV_8.1.MASTER_PRICE_TABLE.DATA) is loaded into this block of memory by INV_8, and INV_8.1.
	;INV_8.1.MASTER_PRICE_TABLE.DATA is $200 bytes in size. 
	
	.FI ;END IF
	
	
INV_8.1.DATA_STORAGE.END



@END


@END
;==========================================================
;
;

INV_8.SHARED_FILLER.START
@START
	.PH INV_8.MERCHANT_TRANSACTIONS.PATCH_END ;start patch mode
	

INV_8.SHARED_FILLER.PATCH_START

	.NO INV.MAIN_MODULE.END-1 ;**OPT** Speed. Disk. optimize the .NO to the actual space needed. 
							 ;-1 is used to make sure the code ends $2 bytes before INV.PLAYER.INVENTORY.DATA starts at $BA00.
							 ;These 2 bytes are used to store the inventory array length for use with the sort routine. 
							 
INV_8.SHARED_FILLER.PATCH_END
	.EP ;end patch mode
INV_8.SHARED_FILLER.END
@END
@END
@END


;TM_1.TREASURE_MGT
@START

;
;==========================================================
TM_1.TREASURE_MGT.START
@START
	.PH INV_4.1a.DISPLAY_PLAYER_INVENTORY.PATCH_START ;this sub_module shares the same memory range as INV_4, INV_6, INV_7
TM_1.TREASURE_MGT.PATCH_START
	
			.IN 	swap.routines.inv.treasure_mgt.ASM

TM_1.TREASURE_MGT.PATCH_END
	.EP ;end patch mode
TM_1.TREASURE_MGT.END


@END
;==========================================================
;
;

TM_1.SHARED_FILLER.START
@START
	.PH TM_1.TREASURE_MGT.PATCH_END ;start patch mode
	

TM_1.SHARED_FILLER.PATCH_START

	.NO INV.MAIN_MODULE.END-1 ;**OPT** Speed. Disk. optimize the .NO to the actual space needed. 
							 ;-1 is used to make sure the code ends $2 bytes before INV.PLAYER.INVENTORY.DATA starts at $BA00.
							 ;These 2 bytes are used to store the inventory array length for use with the sort routine. 
							 
TM_1.SHARED_FILLER.PATCH_END
	.EP ;end patch mode
TM_1.SHARED_FILLER.END
@END
@END
@END






;INV.PLAYER.INVENTORY.DATA.START (destination read location)
;($BA00 - $BF00), !256 items max
		 

;==INVENTORY FILE OFFSETS==
@START
INV.FILE.OFFSETS

INV.PLAYER_INVENTORY_DATA.SEEK_BYTES = INV.PLAYER.INVENTORY.DATA.START-SRTN.INVENTORY.FILE.START

INV.ENTRANCE.SEEK_BYTES = INV.ENTRANCE.START-SRTN.INVENTORY.FILE.START
INV.ENTRANCE.READ_BYTES = INV.ENTRANCE.END-INV.ENTRANCE.START

INV_0.STATS_SUMMARY.SEEK_BYTES = INV_0.STATS_SUMMARY.START-SRTN.INVENTORY.FILE.START
INV_0.STATS_SUMMARY.READ_BYTES = INV_0.STATS_SUMMARY.END-INV_0.STATS_SUMMARY.START

INV_1.READIED_EQUIPMENT.SEEK_BYTES = INV_1.READIED_EQUIPMENT.START-SRTN.INVENTORY.FILE.START
INV_1.READIED_EQUIPMENT.READ_BYTES = INV_1.READIED_EQUIPMENT.END-INV_1.READIED_EQUIPMENT.START

INV_2.COMBAT_STATS.SEEK_BYTES = INV_2.COMBAT_STATS.START-SRTN.INVENTORY.FILE.START
INV_2.COMBAT_STATS.READ_BYTES = INV_2.COMBAT_STATS.END-INV_2.COMBAT_STATS.START

INV_3.SKILLS.SEEK_BYTES = INV_3.SKILLS.START-SRTN.INVENTORY.FILE.START
INV_3.SKILLS.READ_BYTES = INV_3.SKILLS.END-INV_3.SKILLS.START

INV_4.DISPLAY_PLAYER_INVENTORY.SEEK_BYTES = INV_4.DISPLAY_PLAYER_INVENTORY.START-SRTN.INVENTORY.FILE.START
INV_4.DISPLAY_PLAYER_INVENTORY.READ_BYTES = INV_4.DISPLAY_PLAYER_INVENTORY.END-INV_4.DISPLAY_PLAYER_INVENTORY.START
INV_4.DISPLAY_PLAYER_INVENTORY.READ_BYTES.MERCH_MODE = INV_4.GROUP2.SUBROUTINES.START-INV_4.DISPLAY_PLAYER_INVENTORY.PATCH_START



INV_4.1all.SHARED_ROUTINES.SEEK_BYTES = INV_4.1a.SHARED_ROUTINES.START-SRTN.INVENTORY.FILE.START
INV_4.1all.SHARED_ROUTINES.READ_BYTES = INV_4.1b.SHARED_ROUTINES.END-INV_4.1a.SHARED_ROUTINES.START


INV_4.1a.SHARED_ROUTINES.SEEK_BYTES = INV_4.1a.SHARED_ROUTINES.START-SRTN.INVENTORY.FILE.START
INV_4.1a.SHARED_ROUTINES.READ_BYTES = INV_4.1a.SHARED_ROUTINES.END-INV_4.1a.SHARED_ROUTINES.START

INV_4.1b.SHARED_ROUTINES.SEEK_BYTES = INV_4.1b.SHARED_ROUTINES.START-SRTN.INVENTORY.FILE.START
INV_4.1b.SHARED_ROUTINES.READ_BYTES = INV_4.1b.SHARED_ROUTINES.END-INV_4.1b.SHARED_ROUTINES.START



INV_6.READY_UNREADY.SEEK_BYTES = INV_6.READY_UNREADY.START-SRTN.INVENTORY.FILE.START
INV_6.READY_UNREADY.READ_BYTES = INV_6.READY_UNREADY.END-INV_6.READY_UNREADY.START

INV_7.CALCULATE.COMBAT.STATS.SEEK_BYTES = INV_7.CALCULATE.COMBAT.STATS.START-SRTN.INVENTORY.FILE.START
INV_7.CALCULATE.COMBAT.STATS.READ_BYTES = INV_7.CALCULATE.COMBAT.STATS.END-INV_7.CALCULATE.COMBAT.STATS.START
	
INV_8.MERCHANT_TRANSACTIONS.SEEK_BYTES = INV_8.MERCHANT_TRANSACTIONS.START-SRTN.INVENTORY.FILE.START
INV_8.MERCHANT_TRANSACTIONS.READ_BYTES = INV_8.MERCHANT_TRANSACTIONS.END-INV_8.MERCHANT_TRANSACTIONS.START

INV_8.1.DATA_STORAGE.SEEK_BYTES = INV_8.1.DATA_STORAGE.START-SRTN.INVENTORY.FILE.START
INV_8.1.DATA_STORAGE.READ_BYTES = INV_8.1.DATA_STORAGE.END-INV_8.1.DATA_STORAGE.START


;----

TM_1.TREASURE_MGT.SEEK_BYTES = TM_1.TREASURE_MGT.START-SRTN.INVENTORY.FILE.START
TM_1.TREASURE_MGT.READ_BYTES = TM_1.TREASURE_MGT.END-TM_1.TREASURE_MGT.START




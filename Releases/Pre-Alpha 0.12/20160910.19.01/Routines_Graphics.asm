;************************INCLUDE FILE*****************************
;(do not assemble stand-alone. For a stand-alone version of this routine see examples/rwts2)


;NOTE: THERE ARE VARIABLES USED HERE THAT ARE NOT DEFINED HERE. I SHOULD EITHER MOVE THE VARIABLES DEFINITIONS
;HERE FROM THE GRAPHICS ENGINE, OR USE DIFFERENT VARIABLES. 

;LIST OF FUNCTIONS;
;
;FLIP.PAGE					;SET ACTIVE PAGE TO BACKGROUND AND BACKGROUND PAGE TO ACTIVE
;SCLEAR						;CLEAR BOTH PAGES
;GET.LINE.ADDRESS			;GET BASE ADDRESS FOR LINE, FOR PAGE 1 OR PAGE 2

FLIP.PAGE 		;============SET ACTIVE PAGE TO BACKGROUND==========
@START
;PARAMETERS: PAGE (#$01 OR #$02)
;RETURN: NONE

;DETERMINE WHICH PAGE IS IN FOREGROUND
	LDA PAGE.FOREGROUND
	CMP #$02
	BEQ .PAGE2.CURRENTLY.ACTIVE
	CMP #$01				;DOES ACC = PAGE1? IF, YES FALL THROUGH TO PAGE 1 LOOKUP
	BNE .ERROR				;IF NO, INPUT NOT VALID, EXIT ERROR. 

.PAGE1.CURRENTLY.ACTIVE
	LDA PAGE2				;SET PAGE1 AS BACKGROUND, SET PAGE2 AS FOREGROUND
	LDA #$02				;SAVE TO PAGE VARIABLE
	STA PAGE.FOREGROUND
	LDA #$01
	STA PAGE.BACKGROUND
	RTS
	
.PAGE2.CURRENTLY.ACTIVE
	LDA PAGE1				;SET PAGE2 AS BACKGROUND, SET PAGE1 AS FOREGROUND
	LDA #$01				;SAVE TO PAGE VARIABLE
	STA PAGE.FOREGROUND
	LDA #$02
	STA PAGE.BACKGROUND
	RTS
	
.ERROR
;DISABLE.BS_RAM
	LDA $C082				;READ ENABLE ROM, DISABLE WRITE ON BSM (NORMAL STATE).
							;REQUIRED FOR BEFORE BRK BECAUSE APPLE MONITOR IS A ROM ROUTINE

	LDA TEXT
	BRK
@END
	
SCLEAR					 ;============Clear Hi-Res Screen (Page 1 and 2)==========
@START
;PARAMTERS: ACC[DEFAULT = BOTH, #$01, PAGE1, #$02, PAGE2, #$03 BACKGROUND PAGE] 
;OPTIONAL: (PAGE.BACKGROUND), only required if ACC == #$03 is passed			
;RETURN: NONE


;DETERMINE WHICH PAGE TO CLEAR
	CMP #$01
	BEQ .P1			;PAGE1
	CMP #$02		
	BEQ .P2			;PAGE2	
	CMP #$03
	BEQ	.P3			;BACKGROUND PAGE
.DEFAULT
	LDA #$60
	STA SCLEAR.PAGE.STOP.ADDRESS	;SETUP PAGE1&2 CLEAR, BY DEFAULT
	
	LDA #$20
	STA LINE.BASE.ADDR1+$1
	JMP .START
	
.P3 ;SETUP BACKGROUND PAGE CLEAR
		
	LDA PAGE.BACKGROUND
	CMP #$02
	BEQ .P2					;PAGE 2 IS BACKGROUND. 
	CMP #$01				
	BEQ .P1					;PAGE 1 IS BACKGROUND
	JMP .ERROR				;OTHERWISE, INPUT NOT VALID, EXIT ERROR. 


.P2	;SETUP PAGE2 CLEAR
	LDA #$60
	STA SCLEAR.PAGE.STOP.ADDRESS	
	
	LDA #$30
	STA LINE.BASE.ADDR1+$1
	JMP .START
	
	
.P1	;SETUP PAGE 1 CLEAR
	LDA #$40
	STA SCLEAR.PAGE.STOP.ADDRESS
	LDA #$20
	STA LINE.BASE.ADDR1+$1
	
.START
	
	LDA #$00
	STA LINE.BASE.ADDR1				;ALL 3 SCENARIOS HAVE $00 IN THE LO BYTE
	
.CLR1
	LDY #$00
	LDA	#$00
.CLR
	STA	(LINE.BASE.ADDR1), Y
	INY
	BNE .CLR
	INC LINE.BASE.ADDR1+$1
	LDA LINE.BASE.ADDR1+$1
	CMP SCLEAR.PAGE.STOP.ADDRESS
	BCC	.CLR1		;is acc less than cmp

	RTS

.ERROR
	BRK	
@END	
	
GET.LINE.ADDRESS1		;============GET BASE MEMORY ADDRESS FOR GIVEN LINE (X)=========
@START
;PARAMETERS: X-REG = line number, ACC = Page Number (#$1 or #$2)
;RETURN: LINE.BASE.ADDR (2)

;SAVE REGISTERS
	PHA

.START
	CMP #$02
	BEQ .LOOKUP.PAGE2
	CMP #$01				;DOES ACC = PAGE1? IF, YES FALL THROUGH TO PAGE 1 LOOKUP
	BNE .ERROR				;IF NO, INPUT NOT VALID, EXIT ERROR. 

	
.LOOKUP.PAGE1	
	LDA LINE.HO.P1,X		;GET LINE ADDRESS
	STA LINE.BASE.ADDR1+$1
	LDA LINE.LO,X
	STA LINE.BASE.ADDR1
	JMP .EXIT

.LOOKUP.PAGE2
	LDA LINE.HO.P2,X		;GET LINE ADDRESS
	STA LINE.BASE.ADDR1+$1
	LDA LINE.LO,X
	STA LINE.BASE.ADDR1
	;** FALLS THROUGH**
	
.EXIT
;RESTORE REGISTERS
	PLA
	
	RTS

.ERROR
	;Error if ACC not set to page 1 (#$01) or page 2 (#$02), when calling this routine
	JSR PREP.BRK
	BRK
@END

GET.LINE.ADDRESS2		;============DUPLICATE OF GET.LINE.ADDRESS1 SO TWO LINES CAN BE STORED IN MEMORY=========
@START
; ;PARAMETERS: X-REG = line number, ACC = Page Number (#$1 or #$2)
; ;RETURN: LINE.BASE.ADDR (2)

	CMP #$02
	BEQ .LOOKUP.PAGE2
	CMP #$01				;DOES ACC = PAGE1? IF, YES FALL THROUGH TO PAGE 1 LOOKUP
	BNE .ERROR				;IF NO, INPUT NOT VALID, EXIT ERROR. 

	
.LOOKUP.PAGE1	
	LDA LINE.HO.P1,X		;GET LINE ADDRESS
	STA LINE.BASE.ADDR2+$1
	LDA LINE.LO,X
	STA LINE.BASE.ADDR2
	RTS

.LOOKUP.PAGE2
	LDA LINE.HO.P2,X		;GET LINE ADDRESS
	STA LINE.BASE.ADDR2+$1
	LDA LINE.LO,X
	STA LINE.BASE.ADDR2
	RTS

.ERROR
	;Error if ACC not set to page 1 (#$01) or page 2 (#$02), when calling this routine
	JSR PREP.BRK
	BRK
@END

PAGE.MIRROR ;============COPIES FOREGROUND PAGE TO BACKGROUND PAGE=======
@START
;PARAMETERS: PAGE.FOREGROUND

;DETERMINE WHICH PAGE IS IN FOREGROUND
	LDA PAGE.FOREGROUND
	CMP #$02
	BEQ .PAGE2.CURRENTLY.FOREGROUND
	CMP #$01				;DOES ACC = PAGE1? IF, YES FALL THROUGH TO PAGE 1 LOOKUP
	BNE .ERROR				;IF NO, INPUT NOT VALID, EXIT ERROR. 

.PAGE1.CURRENTLY.FOREGROUND
		LDA #$00
		STA COPY.FROM_START
		LDA #$20
		STA COPY.FROM_START+$1
		LDA #$FF
		STA COPY.FROM_END
		LDA #$3F
		STA COPY.FROM_END+$1
		
		LDA #$00
		STA COPY.TO
		LDA #$40
		STA COPY.TO+$1
		
		JSR MEMORY.COPY
	
	JMP .EXIT
	
.PAGE2.CURRENTLY.FOREGROUND

		LDA #$00
		STA COPY.FROM_START
		LDA #$40
		STA COPY.FROM_START+$1
		LDA #$FF
		STA COPY.FROM_END
		LDA #$5F
		STA COPY.FROM_END+$1
		
		LDA #$00
		STA COPY.TO
		LDA #$20
		STA COPY.TO+$1
		
		JSR MEMORY.COPY

.EXIT
	RTS

.ERROR
;PAGE.MIRROR reports error; PAGE.FOREGROUND doesn't contain a valid hi-res page #
	JSR PREP.BRK
	BRK	
@END

DRAW.LINE ;=====DRAW SINGLE COLOR LINE OR RECTANGLE=======
@START
;PARAMTERS: ACC = PAGE, DRAW.START_LINE, DRAW.START_BYTE, *DRAW.STOP_BYTE, *DRAW.STOP_LINE, DRAW.BYTE.VALUE(2)
;ENTRANCE: DIRECT
;RETURN: NONE
;*set the stop byte/line to the last byte/line you want drawn +$1, because the index increment is before the conditional test. 
;**$01 = draw on hi-res page 1, $02 = draw on page 2, $03 = draw on both pages

;=====================SUBROUTINE DOCUMENTATION====================================
;
;Draws a single color line or rectangle using the parameters provided for the coordinates.  
;No shape tables. 
;
;Set the value of the byte to draw via the parameter DRAW.BYTE_VALUE(2)
;If you want to draw $00 (erase on black backgrounds), don't set DRAW.BYTE_VALUE(2) and 
;instead set the high-bit on the page parameter in the ACC.
;
;For example:
;
;ACC = $01 = draw on page 1, set DRAW.BYTE_VALUE
;ACC = $02 = draw on page 2, set DRAW.BYTE_VALUE
;ACC = $03 = draw on both pages, set DRAW.BYTE_VALUE
;ACC = $81 = draw on page 1, DRAW.BYTE_VALUE automatically gets set to $00 by this routine
;ACC = $82 = draw on page 2, DRAW.BYTE_VALUE automatically gets set to $00 by this routine
;ACC = $83 = draw on both pages, DRAW.BYTE_VALUE automatically gets set to $00 by this routine
;
;=================================================================================


;====TEMPLATES====
@START
		;====TEMPLATE: ERASE, DRAW.BYTE_VALUE = $00===
		; LDA #TWB.TOP_WINDOW.TOP_LINE		
		; STA DRAW.START_LINE
		;
		; LDA #TWB.TOP_WINDOW.LEFT_SBYTE
		; STA DRAW.START_BYTE
		;
		; LDA #TWB.TOP_WINDOW.RIGHT_SBYTE+$1
		; STA DRAW.STOP_BYTE
		;	
		; LDA #TWB.TOP_WINDOW.BOTTOM_LINE+$1
		; STA DRAW.STOP_LINE
		; LDA #$83		;set draw to both pages
			; ;we set high bit as a parameter to indicate we want the byte value for the draw to be $00
		; STA USE.PAGE
	; JSR DRAW.LINE
@END



.START	
	;ACC = page parameter and byte value parameter
	BPL .SAVE.PAGE.PARM ;if high bit is not set in ACC value, branch to .SAVE.PAGE.PARM
	PHA 		;push USE.PAGE parm to stack
	LDA #$00	;overide DRAW.BYTE_VALUE with $00, an "erase" value on black backgrounds.
	STA DRAW.BYTE_VALUE+$0
	STA DRAW.BYTE_VALUE+$1
	PLA 		;pull USE.PAGE parm from stack
	AND #$7F	;mask out the high bit, which converts the ACC value to the USE.PAGE parameter. 
.SAVE.PAGE.PARM	
	STA USE.PAGE ;expects a value of $00-$03
	
			; LDX #$AA
			; JSR PREP.BRK
			; BRK
			
.SAVE.REGISTERS
	TXA
	PHA
	TYA
	PHA

.INIT
	LDX DRAW.START_LINE
	LDY DRAW.START_BYTE
	
.DRAW.LOOP
	LDA USE.PAGE
	CMP #$03			;clear window on both hi-res pages?
	BEQ .DRAW.BOTH.PAGES	

	;ACC = USE.PAGE
	JSR GET.LINE.ADDRESS1
	JMP .DRAW.SINGLE.PAGE
	;**FALLS THROUGH**
	
.DRAW.BOTH.PAGES			
	LDA #$01	;get page1 address first
	JSR GET.LINE.ADDRESS1
	
	;CALCULATE PAGE2 ADDRESS 
	LDA LINE.BASE.ADDR1+$1
	CLC
	ADC #$20
	STA LINE.BASE.ADDR2+$1	;subtract $2000 from line address

	;SET LO ADDRESS
	LDA LINE.BASE.ADDR1
	STA LINE.BASE.ADDR2
	;**FALLS THROUGH**
	
.LOOP.ROW
	LDA DRAW.BYTE_VALUE+$0		;set value of byte to draw
	
	STA (LINE.BASE.ADDR1),Y	;PLOT (1st screen byte)
	STA (LINE.BASE.ADDR2),Y	;PLOT (1st screen byte)
	
	INY  					;next screen byte
	CPY DRAW.STOP_BYTE  ;at text window edge?
	BEQ .INCREMENT_LINE
	
	LDA DRAW.BYTE_VALUE+$1		;set value of byte to draw
	
	STA (LINE.BASE.ADDR1),Y	;PLOT (1st screen byte)
	STA (LINE.BASE.ADDR2),Y	;PLOT (1st screen byte)
	INY  					;next screen byte
	CPY DRAW.STOP_BYTE  ;at text window edge?
	BNE .LOOP.ROW
	;**FALLS THROUGH**
	
.INCREMENT_LINE
	LDY DRAW.START_BYTE	;reset screen byte to text window edge (it's actually the start byte in this routine)			
	INX						;next tile line
	
	CPX DRAW.STOP_LINE		;LAST LINE?							
	BCC .DRAW.LOOP			;IF NO, DRAW NEXT LINE (BCC: is X-REG < CPX value)	
	JMP .EXIT
	
	
.DRAW.SINGLE.PAGE
.LOOP.ROW2
	LDA #$00
	
	STA (LINE.BASE.ADDR1),Y	;PLOT (1st screen byte)
	
	INY  					;next screen byte
	CPY DRAW.STOP_BYTE
	BNE .LOOP.ROW2

	LDY DRAW.START_BYTE	;reset screen byte to text window edge			;SCREEN BYTE INDEX IN Y REGISTER	
	INX						;next tile line
	
	CPX DRAW.STOP_LINE		;IS TILE DONE?							
	BCC .DRAW.LOOP			;IF NO, DRAW NEXT LINE (BCC: is X-REG < CPX value)	
	;**FALLS THROUGH**

.EXIT

;RESTORE REGISTERS		
	PLA
	TAY
	PLA
	TAX
	
	RTS


@END

;=================DEFINE VARIABLES===============

GRAPHICS 			.EQ	$C050
HIRES				.EQ	$C057
PAGE1				.EQ	$C054
MIXOFF				.EQ	$C052
PAGE2				.EQ	$C055




SCLEAR.PAGE.STOP.ADDRESS	.BS		$01	
COPY.STOP.ADDRESS			.BS		$01		

PAGE.FOREGROUND				.BS $1							;1byt	USED WHEN CALLING DRAW.TILE SUBROUTINE (POSSIBLY OTHERS IN FUTURE) TO SPECIFY THE BACKGROUND PAGE (WHICH IS USUALLY THE ONE DRAWN ON)
PAGE.BACKGROUND				.BS	$1							;1byt	CONTAINS THE OPPOSITE VALUE OF PAGE, SO IT CAN BE USED BY ROUTINES THAT NEED TO DRAW TO THE BACKGROUND PAGE. 
PAGE.FOREGROUND.OVERRIDE	.BS $1							;1byt 	$01 = override on, $00 = off

LINE.BASE.ADDR1		.EQ	$EA				;2byt
LINE.BASE.ADDR2		.EQ	$EC				;2byt


LINE.BASE.ADDR3		.EQ	$E6				;2byt
LINE.BASE.ADDR4		.EQ	$E8				;2byt


COPYTO				.EQ $FA				;2byt
COPYFROM			.EQ $FC				;2byt

;Line Lookup Tables. LINE.LO is used for Hi-Res Page 1 and Page 2. 
;
;(THIS COMMENT NO LONGER APPLIES) *****see offloaded_variables.asm****
LINE.LO			.HS 00.00.00.00.00.00.00.00.80.80.80.80.80.80.80.80.00.00.00.00.00.00.00.00.80.80.80.80.80.80.80.80.00.00.00.00.00.00.00.00.80.80.80.80.80.80.80.80.00.00.00.00.00.00.00.00.80.80.80.80.80.80.80.80.28.28.28.28.28.28.28.28.A8.A8.A8.A8.A8.A8.A8.A8.28.28.28.28.28.28.28.28.A8.A8.A8.A8.A8.A8.A8.A8.28.28.28.28.28.28.28.28.A8.A8.A8.A8.A8.A8.A8.A8.28.28.28.28.28.28.28.28.A8.A8.A8.A8.A8.A8.A8.A8.50.50.50.50.50.50.50.50.D0.D0.D0.D0.D0.D0.D0.D0.50.50.50.50.50.50.50.50.D0.D0.D0.D0.D0.D0.D0.D0.50.50.50.50.50.50.50.50.D0.D0.D0.D0.D0.D0.D0.D0.50.50.50.50.50.50.50.50.D0.D0.D0.D0.D0.D0.D0.D0
LINE.HO.P1 		.HS 20.24.28.2C.30.34.38.3C.20.24.28.2C.30.34.38.3C.21.25.29.2D.31.35.39.3D.21.25.29.2D.31.35.39.3D.22.26.2A.2E.32.36.3A.3E.22.26.2A.2E.32.36.3A.3E.23.27.2B.2F.33.37.3B.3F.23.27.2B.2F.33.37.3B.3F.20.24.28.2C.30.34.38.3C.20.24.28.2C.30.34.38.3C.21.25.29.2D.31.35.39.3D.21.25.29.2D.31.35.39.3D.22.26.2A.2E.32.36.3A.3E.22.26.2A.2E.32.36.3A.3E.23.27.2B.2F.33.37.3B.3F.23.27.2B.2F.33.37.3B.3F.20.24.28.2C.30.34.38.3C.20.24.28.2C.30.34.38.3C.21.25.29.2D.31.35.39.3D.21.25.29.2D.31.35.39.3D.22.26.2A.2E.32.36.3A.3E.22.26.2A.2E.32.36.3A.3E.23.27.2B.2F.33.37.3B.3F.23.27.2B.2F.33.37.3B.3F
LINE.HO.P2 		.HS 40.44.48.4C.50.54.58.5C.40.44.48.4C.50.54.58.5C.41.45.49.4D.51.55.59.5D.41.45.49.4D.51.55.59.5D.42.46.4A.4E.52.56.5A.5E.42.46.4A.4E.52.56.5A.5E.43.47.4B.4F.53.57.5B.5F.43.47.4B.4F.53.57.5B.5F.40.44.48.4C.50.54.58.5C.40.44.48.4C.50.54.58.5C.41.45.49.4D.51.55.59.5D.41.45.49.4D.51.55.59.5D.42.46.4A.4E.52.56.5A.5E.42.46.4A.4E.52.56.5A.5E.43.47.4B.4F.53.57.5B.5F.43.47.4B.4F.53.57.5B.5F.40.44.48.4C.50.54.58.5C.40.44.48.4C.50.54.58.5C.41.45.49.4D.51.55.59.5D.41.45.49.4D.51.55.59.5D.42.46.4A.4E.52.56.5A.5E.42.46.4A.4E.52.56.5A.5E.43.47.4B.4F.53.57.5B.5F.43.47.4B.4F.53.57.5B.5F

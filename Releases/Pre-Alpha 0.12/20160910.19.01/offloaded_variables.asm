;************************INCLUDE FILE*****************************
;(do not assemble stand-alone.)
				;.OR		$1200			**Always put before .TF directive and never use again in program
				;.TF     VARIABLES.bin,BIN



;======SWAP SPACE=======
@START

SWAP_SPACE.MAIN_MEMORY			.EQ $A000
SWAP_SPACE.MAIN_MEMORY.END		.EQ $BFFF
SWAP_SPACE.MAIN_MEMORY.POINTER	.EQ $ED	;Zero page pointer for swap space memory region

SWAP_SPACE.AUX_MEMORY			.EQ $3900
SWAP_SPACE.AUX_MEMORY.END		.EQ $58FF

RZONE.ARRAY.TEMP_BUFFER			.EQ $B000 ;data is loaded here from disk temporarily when a new location is entered. Once loaded various zone tools subroutines are used to reorder and copy the data into the permenant RZONE.ARRAY memory location.
;RZONE.ARRAY.TEMP_BUFFER			.EQ $A600 ;data is loaded here from disk temporarily when a new location is entered. Once loaded various zone tools subroutines are used to reorder and copy the data into the permenant RZONE.ARRAY memory location.
;RZONE.ARRAY.TEMP_BUFFER			.EQ $B700 ;data is loaded here from disk temporarily when a new location is entered. Once loaded various zone tools subroutines are used to reorder and copy the data into the permenant RZONE.ARRAY memory location.

@END

;===========MAP OBJECT INFORMATION========
@START

MO.DOOR.OPEN.START		.EQ $24	;#CONSTANT (starting value for an open door)
MO.DOOR.OPEN.START2		.EQ $23	;#CONSTANT (alternate starting value for an open door)
MO.DOOR.OPEN.GRE 		.EQ $21 ;#CONSTANT
MO.DOOR.OPEN.LT 		.EQ $25 ;#CONSTANT
MO.DOOR.CLOSING 		.EQ $21 ;#CONSTANT  (door that will close this turn when MO.DRAW runs)
MO.DOOR.CLOSE_TRIGGER	.EQ $20	;#CONSTANT  (trigger for MO.DRAW to set MO record to closed door)
MO.DOOR.CLOSED.UNLOCKED .EQ $10 ;#CONSTANT
MO.DOOR.CLOSED.GRE 		.EQ $10 ;#CONSTANT
MO.DOOR.CLOSED.LT 		.EQ $20 ;#CONSTANT
MO.DOOR.ALL.GRE 		.EQ $10 ;#CONSTANT
MO.DOOR.ALL.LT  		.EQ $25 ;#CONSTANT
MO.DOOR.LOCKED.GRE		.EQ $11 ;#CONSTANT
MO.DOOR.LOCKED.LT		.EQ $20 ;#CONSTANT
MO.PORTCULLIS.LEFT		.EQ $30	;#CONSTANT
MO.PORTCULLIS.RIGHT		.EQ $31	;#CONSTANT
MO.PORTCULLIS.LOWERED	.EQ $32	;#CONSTANT

;SPECIAL
MO.NOT_PUSHABLE.GRE		.EQ $10	;#CONSTANT	non-transport objects with byte $3 >= this constant are not pushable
MO.SKIP.DRAW.FLAG		.EQ $FE	;#CONSTANT
	
@END

;============TILE INFORMATION=============
@START

;BUILDING MAP
TILE_ID.WINDOW_DOOR.GRE1		.EQ $13				;#CONSTANT		TILE TYPE ID
TILE_ID.WINDOW_DOOR.LT1			.EQ $1C				;#CONSTANT		TILE TYPE ID

TILE_ID.CELL_DOOR.GRE1			.EQ $1C				;#CONSTANT		TILE TYPE ID
TILE_ID.CELL_DOOR.LT1			.EQ $1F				;#CONSTANT		TILE TYPE ID

TILE_ID.LADDER_OUTHOUSE.GRE1	.EQ $51				;#CONSTANT		TILE TYPE ID
TILE_ID.LADDER_OUTHOUSE.LT1		.EQ $54				;#CONSTANT		TILE TYPE ID
TILE_ID.BED_LEFT_UNOCCUPIED		.EQ $49				;#CONSTANT		TILE TYPE ID
TILE_ID.BED_LEFT_OCCUPIED		.EQ $4A				;#CONSTANT		TILE TYPE ID
TILE_ID.BED_RIGHT				.EQ $4B				;#CONSTANT		TILE TYPE ID
TILE_ID.BED_COT.GRE1			.EQ $49				;#CONSTANT		TILE TYPE ID
TILE_ID.BED_COT.LT1				.EQ $4E				;#CONSTANT		TILE TYPE ID
TILE_ID.COT_UNOCCUPIED			.EQ $4C				;#CONSTANT		TILE TYPE ID
TILE_ID.COT_OCCUPIED			.EQ $4D				;#CONSTANT		TILE TYPE ID
TILE_ID.PORTCULLIS				.EQ $4E				;#CONSTANT		TILE TYPE ID
TILE_ID.PORTCULLIS_LEVER.LEFT	.EQ $4F				;#CONSTANT		TILE TYPE ID
TILE_ID.PORTCULLIS_LEVER.RIGHT	.EQ $50				;#CONSTANT		TILE TYPE ID

TILE_ID.OUTHOUSE_HOLE.UNOCCUPIED	.EQ $53				;#CONSTANT		TILE TYPE ID
TILE_ID.OUTHOUSE_HOLE.OCCUPIED		.EQ $54				;#CONSTANT		TILE TYPE ID

TILE_ID.ROAD.GRE1				.EQ $5B				;#CONSTANT		TILE TYPE ID
TILE_ID.ROAD.LT1				.EQ $5F				;#CONSTANT		TILE TYPE ID
; TILE_ID.FLOOR.GRE1			.EQ $5F				;#CONSTANT		TILE TYPE ID
; TILE_ID.FLOOR.LT1				.EQ $63				;#CONSTANT		TILE TYPE ID

TILE_ID.FLOOR_PATH.GRE1			.EQ $61				;#CONSTANT		TILE TYPE ID
TILE_ID.FLOOR_PATH.LT1			.EQ $63				;#CONSTANT		TILE TYPE ID
TILE_ID.UNDEAD_LORD				.EQ $8E				;#CONSTANT		TILE TYPE ID
TILE_ID.FIRE_A					.EQ $9D				;#CONSTANT		TILE TYPE ID
TILE_ID.FIRE_B					.EQ $9E				;#CONSTANT		TILE TYPE ID

TILE_ID.GUARD.GRE1				.EQ $97				;#CONSTANT	
TILE_ID.GUARD.LT1				.EQ $98				;#CONSTANT	

TILE_ID.WALL.BRICK				.EQ $08
TILE_ID.WALL.STONE				.EQ $09



;SURFACE MAP
TILE_ID.MOUNTAINS.TALL			.EQ $00

TILE_ID.SKIFF					.EQ $33				;#CONSTANT		TILE TYPE ID
TILE_ID.GRASS					.EQ $34				;#CONSTANT		TILE TYPE ID
TILE_ID.TALL_GRASS_A			.EQ $35				;#CONSTANT		TILE TYPE ID
TILE_ID.TALL_GRASS_B			.EQ $36				;#CONSTANT		TILE TYPE ID
TILE_ID.TREES.BIRCH				.EQ $39
TILE_ID.BEACH					.EQ $41				;#CONSTANT		TILE TYPE ID

TILE_ID.HORSE_A					.EQ $42				;#CONSTANT		TILE TYPE ID
TILE_ID.HORSE_B					.EQ $43				;#CONSTANT		TILE TYPE ID
TILE_ID.HORSE_C					.EQ $44				;#CONSTANT		TILE TYPE ID
;NOTE: MAP OBJECT RECORD ALWAYS HAS HORSE_C

TILE_ID.HILLS					.EQ $45				;#CONSTANT		TILE TYPE ID
TILE_ID.QUICKSAND				.EQ $46				;#CONSTANT		TILE TYPE ID

TILE_ID.CARAVEL					.EQ $7B				;#CONSTANT		TILE TYPE ID
TILE_ID.FRIGATE1.1				.EQ $7C				;#CONSTANT		TILE TYPE ID
TILE_ID.FRIGATE1.2				.EQ $7D				;#CONSTANT		TILE TYPE ID
TILE_ID.FRIGATE1.3				.EQ $7E				;#CONSTANT		TILE TYPE ID
TILE_ID.FRIGATE1.4				.EQ $7F				;#CONSTANT		TILE TYPE ID

TILE_ID.SURF					.EQ $88				;#CONSTANT		TILE TYPE ID
TILE_ID.SHALLOW_WATER			.EQ $89				;#CONSTANT		TILE TYPE ID
TILE_ID.DEEP_WATER				.EQ $8B				;#CONSTANT		TILE TYPE ID
TILE_ID.CROC_A					.EQ $92				;#CONSTANT		TILE TYPE ID
TILE_ID.CROC_B					.EQ $93				;#CONSTANT		TILE TYPE ID
TILE_ID.WYVERN					.EQ $95				;#CONSTANT		TILE TYPE ID
TILE_ID.PLAYER_ICON.HALF_SUNK	.EQ $99				;#CONSTANT		TILE TYPE ID
TILE_ID.PLAYER_ICON.FULL_SUNK	.EQ $9A				;#CONSTANT		TILE TYPE ID
TILE_ID.STORM					.EQ $A9				;#CONSTANT		TILE TYPE ID
TILE_ID.STORM.GRE				.EQ $A9				;#CONSTANT		TILE TYPE ID
TILE_ID.STORM.LT				.EQ $AD				;#CONSTANT		TILE TYPE ID
TILE_ID.SHARK					.EQ $FB

;SLOW PROGRESS NOTE: SET TO $FF FOR 0% SLOW PROGRESS; $00 FOR 100% AUTOMATIC SLOW PROGRESS
TILE.QUICKSAND.SINK.HEIGHT		.EQ	$05				;#CONSTANT		Height to which player icon sinks when standing in quicksand
TILE.QUICKSAND.SINK.AUTOMATIC	.EQ $0E				;#CONSTANT		The height to which the player is automatically sunk in quicksand, even if player is holding down a movement key
TILE.QUICKSAND.PLAYER.SLOW_PROGRESS.HEIGHT	.EQ $0D ;#CONSTANT		The height at which slow progress is a possibility. THIS IS SO THAT THE PLAYER, IF HOLDING DOWN MOVEMENT KEY, CAN EASILY TRAVERSE A COUPLE QUICK STAND TILES WITH ONLY MINOR DEALY.
TILE.QUICKSAND.PLAYER.SLOW_PROGRESS.RATIO	.EQ $40		;#CONSTANT		SLOW PROGRESS IF RANDOM # IS LESS THAN THIS VALUE

TILE.HILLS.PLAYER.SLOW_PROGRESS				.EQ $C0		;#CONSTANT		SLOW PROGRESS IF RANDOM # IS LESS THAN THIS VALUE

@END

;========SCREEN ARRAYS====
@START
;(hold data which determines the tile makeup on the view screen)


;SCREEN.TILE.DATA 			.BS $BB						;HOLDS TILE_TYPE DATA FOR EACH TILE ON VIEW SCREEN
SCREEN.TILE.DATA 			.EQ $0800					;HOLDS TILE_TYPE DATA FOR EACH TILE ON VIEW SCREEN

;	mirrors screen tile layout. 
;	Values for each tile are 0 (normal), 1 (dark)
;SCREEN.DARK.DATA			.BS $BB		;ENDS AT $92BA
SCREEN.DARK.DATA			.EQ $8BB	;$00 = visible, $01 = hidden (dark)

;SCREEN.DARK.DATA_BEFORE	.BS $BB		
SCREEN.DARK.DATA_BEFORE		.EQ $0976		

;	the data from screen.dark.data the move before


;SCREEN.MO_SPRITE.DATA		.BS	$BB		;TRACKS TILE LOCATION OF MAP OBJECTS (MOB) WHOS X,Y IS ON VIEW SCREEN
SCREEN.MO_SPRITE.DATA		.EQ $0A31		;TRACKS TILE LOCATION OF MAP OBJECTS (MOB) WHOS X,Y IS ON VIEW SCREEN

;SCREEN.MO_SPRITE_TYPE.DATA		.BS $BB		;tracks the type of sprite located in the corresponding element of SCREEN.MO_SPRITE.DATA. $00 = Mob. $01 = NPC. This is necessary so that ANIMATION_MANAGER.ASM knows which map objects array to look in. 
SCREEN.MO_SPRITE_TYPE.DATA		.EQ $0AEC	;tracks the type of sprite located in the corresponding element of SCREEN.MO_SPRITE.DATA. $00 = Mob. $01 = NPC. This is necessary so that ANIMATION_MANAGER.ASM knows which map objects array to look in. 


SCREEN.MO_GENERAL.DATA	.BS $BB		;TRACKS TILE LOCATION OF MAP OBJECTS (MOB) WHOS X,Y IS ON VIEW SCREEN
;SCREEN.MO_GENERAL.DATA	.EQ $07A7	;TRACKS TILE LOCATION OF MAP OBJECTS (MOB) WHOS X,Y IS ON VIEW SCREEN





;==========BORROWED MEMORY: THESE ARRAYS MUST STAY IN THIS SEQUENCE;===========
;NOTE: These memory locations are borrowed as a contiguous block by other arrays.
SCREEN.TILE.HOPPER			.BS $0B						;HOLDS ONE COLUMN OF TILES TILE_TYPE DATA ON DECK FOR SCREEN DRAWING (USED AFTER SCREEN SCROLLING)
SCREEN.DARK.HOPPER			.BS $0B						;(MIRROR OF SCREEN.TILE.HOPPER, BUT FOR DARKNESS FLAGS)
;================================================================================							

SCREEN.TILE.ROW.HOPPER 		.EQ SCREEN.TILE.HOPPER		;$11bytes HOLDS ONE ROW OF TILE_TYPE DATA. USED BY DARKNESS.ELS FOR OFFSCREEN TILE. BORROWS MEMORY FROM BOTH SCREEN.ROW.HOPPER AND SCREEN.DARK.HOPPER
@END
							
;========SCREEN TABLES====
@START
;(table related to view screen operations)

;Line Lookup Tables. LINE.LO is used for Hi-Res Page 1 and Page 2. 
;*****see routines_graphics.asm****
;LINE.HO.P1 		.HS 20.24.28.2C.30.34.38.3C.20.24.28.2C.30.34.38.3C.21.25.29.2D.31.35.39.3D.21.25.29.2D.31.35.39.3D.22.26.2A.2E.32.36.3A.3E.22.26.2A.2E.32.36.3A.3E.23.27.2B.2F.33.37.3B.3F.23.27.2B.2F.33.37.3B.3F.20.24.28.2C.30.34.38.3C.20.24.28.2C.30.34.38.3C.21.25.29.2D.31.35.39.3D.21.25.29.2D.31.35.39.3D.22.26.2A.2E.32.36.3A.3E.22.26.2A.2E.32.36.3A.3E.23.27.2B.2F.33.37.3B.3F.23.27.2B.2F.33.37.3B.3F.20.24.28.2C.30.34.38.3C.20.24.28.2C.30.34.38.3C.21.25.29.2D.31.35.39.3D.21.25.29.2D.31.35.39.3D.22.26.2A.2E.32.36.3A.3E.22.26.2A.2E.32.36.3A.3E.23.27.2B.2F.33.37.3B.3F.23.27.2B.2F.33.37.3B.3F
;LINE.LO			.HS 00.00.00.00.00.00.00.00.80.80.80.80.80.80.80.80.00.00.00.00.00.00.00.00.80.80.80.80.80.80.80.80.00.00.00.00.00.00.00.00.80.80.80.80.80.80.80.80.00.00.00.00.00.00.00.00.80.80.80.80.80.80.80.80.28.28.28.28.28.28.28.28.A8.A8.A8.A8.A8.A8.A8.A8.28.28.28.28.28.28.28.28.A8.A8.A8.A8.A8.A8.A8.A8.28.28.28.28.28.28.28.28.A8.A8.A8.A8.A8.A8.A8.A8.28.28.28.28.28.28.28.28.A8.A8.A8.A8.A8.A8.A8.A8.50.50.50.50.50.50.50.50.D0.D0.D0.D0.D0.D0.D0.D0.50.50.50.50.50.50.50.50.D0.D0.D0.D0.D0.D0.D0.D0.50.50.50.50.50.50.50.50.D0.D0.D0.D0.D0.D0.D0.D0.50.50.50.50.50.50.50.50.D0.D0.D0.D0.D0.D0.D0.D0
;LINE.HO.P2 		.HS 40.44.48.4C.50.54.58.5C.40.44.48.4C.50.54.58.5C.41.45.49.4D.51.55.59.5D.41.45.49.4D.51.55.59.5D.42.46.4A.4E.52.56.5A.5E.42.46.4A.4E.52.56.5A.5E.43.47.4B.4F.53.57.5B.5F.43.47.4B.4F.53.57.5B.5F.40.44.48.4C.50.54.58.5C.40.44.48.4C.50.54.58.5C.41.45.49.4D.51.55.59.5D.41.45.49.4D.51.55.59.5D.42.46.4A.4E.52.56.5A.5E.42.46.4A.4E.52.56.5A.5E.43.47.4B.4F.53.57.5B.5F.43.47.4B.4F.53.57.5B.5F.40.44.48.4C.50.54.58.5C.40.44.48.4C.50.54.58.5C.41.45.49.4D.51.55.59.5D.41.45.49.4D.51.55.59.5D.42.46.4A.4E.52.56.5A.5E.42.46.4A.4E.52.56.5A.5E.43.47.4B.4F.53.57.5B.5F.43.47.4B.4F.53.57.5B.5F

;HO/LO address for the tile shape tables in AUX memory. 
TILE.SHAPES.LO		 		.HS	00.20.40.60.80.A0.C0.E0.00.20.40.60.80.A0.C0.E0.00.20.40.60.80.A0.C0.E0.00.20.40.60.80.A0.C0.E0.00.20.40.60.80.A0.C0.E0.00.20.40.60.80.A0.C0.E0.00.20.40.60.80.A0.C0.E0.00.20.40.60.80.A0.C0.E0.00.20.40.60.80.A0.C0.E0.00.20.40.60.80.A0.C0.E0.00.20.40.60.80.A0.C0.E0.00.20.40.60.80.A0.C0.E0.00.20.40.60.80.A0.C0.E0.00.20.40.60.80.A0.C0.E0.00.20.40.60.80.A0.C0.E0.00.20.40.60.80.A0.C0.E0.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80.00.80
TILE.SHAPES.HO		 		.HS	70.70.70.70.70.70.70.70.71.71.71.71.71.71.71.71.72.72.72.72.72.72.72.72.73.73.73.73.73.73.73.73.74.74.74.74.74.74.74.74.75.75.75.75.75.75.75.75.76.76.76.76.76.76.76.76.77.77.77.77.77.77.77.77.78.78.78.78.78.78.78.78.79.79.79.79.79.79.79.79.7A.7A.7A.7A.7A.7A.7A.7A.7B.7B.7B.7B.7B.7B.7B.7B.7C.7C.7C.7C.7C.7C.7C.7C.7D.7D.7D.7D.7D.7D.7D.7D.7E.7E.7E.7E.7E.7E.7E.7E.7F.7F.7F.7F.7F.7F.7F.7F.80.80.81.81.82.82.83.83.84.84.85.85.86.86.87.87.88.88.89.89.8A.8A.8B.8B.8C.8C.8D.8D.8E.8E.8F.8F.90.90.91.91.92.92.93.93.94.94.95.95.96.96.97.97.98.98.99.99.9A.9A.9B.9B.9C.9C.9D.9D.9E.9E.9F.9F.A0.A0.A1.A1.A2.A2.A3.A3.A4.A4.A5.A5.A6.A6.A7.A7.A8.A8.A9.A9.AA.AA.AB.AB.AC.AC.AD.AD.AE.AE.AF.AF.B0.B0.B1.B1.B2.B2.B3.B3.B4.B4.B5.B5.B6.B6.B7.B7.B8.B8.B9.B9.BA.BA.BB.BB.BC.BC.BD.BD.BE.BE.BF.BF
;array elements (!DEC)			00.01.02.03.04.05.06.07.08.09.0A.0B.0C.0D.0E.0F.10.11.12.13.14.15.16.17.18.19.1A.1B.1C.1D.1E.1F.20.21.22.23.24.25.26.27.28.29.2A.2B.2C.2D.2E.2F.30.31.32.33.34.35.36.37.38.39.3A.3B.3C.3D.3E.3F.40.41.42.43.44.45.46.47.48.49.4A.4B.4C.4D.4E.4F.50.51.52.53.54.55.56.57.58.59.5A.5B.5C.5D.5E.5F.60.61.62.63.64.65.66.67.68.69.6A.6B.6C.6D.6E.6F.70.71.72.73.74.75.76.77.78.79.7A.7B.7C.7D.7E.7F.80.81.82.83.84.85.86.87.88.89.8A.8B.8C.8D.8E.8F.90.91.92.93.94.95.96.97.98.99.9A.9B.9C.9D.9E.9F.A0.A1.A2.A3.A4.A5



;the current element of the screen.tile.data, screen.dark.data or screen.dark.data_before arrays, are the index to the row/column arrays. return value is the column/row #.
SCREEN.INDEX.COLUMN			.HS	00.01.02.03.04.05.06.07.08.09.0A.0B.0C.0D.0E.0F.10.00.01.02.03.04.05.06.07.08.09.0A.0B.0C.0D.0E.0F.10.00.01.02.03.04.05.06.07.08.09.0A.0B.0C.0D.0E.0F.10.00.01.02.03.04.05.06.07.08.09.0A.0B.0C.0D.0E.0F.10.00.01.02.03.04.05.06.07.08.09.0A.0B.0C.0D.0E.0F.10.00.01.02.03.04.05.06.07.08.09.0A.0B.0C.0D.0E.0F.10.00.01.02.03.04.05.06.07.08.09.0A.0B.0C.0D.0E.0F.10.00.01.02.03.04.05.06.07.08.09.0A.0B.0C.0D.0E.0F.10.00.01.02.03.04.05.06.07.08.09.0A.0B.0C.0D.0E.0F.10.00.01.02.03.04.05.06.07.08.09.0A.0B.0C.0D.0E.0F.10.00.01.02.03.04.05.06.07.08.09.0A.0B.0C.0D.0E.0F.10
SCREEN.INDEX.ROW			.HS 00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.02.02.02.02.02.02.02.02.02.02.02.02.02.02.02.02.02.03.03.03.03.03.03.03.03.03.03.03.03.03.03.03.03.03.04.04.04.04.04.04.04.04.04.04.04.04.04.04.04.04.04.05.05.05.05.05.05.05.05.05.05.05.05.05.05.05.05.05.06.06.06.06.06.06.06.06.06.06.06.06.06.06.06.06.06.07.07.07.07.07.07.07.07.07.07.07.07.07.07.07.07.07.08.08.08.08.08.08.08.08.08.08.08.08.08.08.08.08.08.09.09.09.09.09.09.09.09.09.09.09.09.09.09.09.09.09.0A.0A.0A.0A.0A.0A.0A.0A.0A.0A.0A.0A.0A.0A.0A.0A.0A
SCREEN.INDEX.TILE_SBYTE		.HS 02.04.06.08.0A.0C.0E.10.12.14.16.18.1A.1C.1E.20.22.02.04.06.08.0A.0C.0E.10.12.14.16.18.1A.1C.1E.20.22.02.04.06.08.0A.0C.0E.10.12.14.16.18.1A.1C.1E.20.22.02.04.06.08.0A.0C.0E.10.12.14.16.18.1A.1C.1E.20.22.02.04.06.08.0A.0C.0E.10.12.14.16.18.1A.1C.1E.20.22.02.04.06.08.0A.0C.0E.10.12.14.16.18.1A.1C.1E.20.22.02.04.06.08.0A.0C.0E.10.12.14.16.18.1A.1C.1E.20.22.02.04.06.08.0A.0C.0E.10.12.14.16.18.1A.1C.1E.20.22.02.04.06.08.0A.0C.0E.10.12.14.16.18.1A.1C.1E.20.22.02.04.06.08.0A.0C.0E.10.12.14.16.18.1A.1C.1E.20.22.02.04.06.08.0A.0C.0E.10.12.14.16.18.1A.1C.1E.20.22
SCREEN.INDEX.TILE_LINE		.HS 08.08.08.08.08.08.08.08.08.08.08.08.08.08.08.08.08.18.18.18.18.18.18.18.18.18.18.18.18.18.18.18.18.18.28.28.28.28.28.28.28.28.28.28.28.28.28.28.28.28.28.38.38.38.38.38.38.38.38.38.38.38.38.38.38.38.38.38.48.48.48.48.48.48.48.48.48.48.48.48.48.48.48.48.48.58.58.58.58.58.58.58.58.58.58.58.58.58.58.58.58.58.68.68.68.68.68.68.68.68.68.68.68.68.68.68.68.68.68.78.78.78.78.78.78.78.78.78.78.78.78.78.78.78.78.78.88.88.88.88.88.88.88.88.88.88.88.88.88.88.88.88.88.98.98.98.98.98.98.98.98.98.98.98.98.98.98.98.98.98.A8.A8.A8.A8.A8.A8.A8.A8.A8.A8.A8.A8.A8.A8.A8.A8.A8


;The order of tile are checked in for obscuring tiles, by DARKNESS.REVIEW
SCREEN.DARK.SEARCH_INDEX	.HS 6D.5C.4B.4C.4D.5E.6F.6E.39.4A.5B.6C.7D.3A.3B.3C.3D.4E.5F.70.81.7E.7F.80.27.38.49.5A.6B.7C.8D.28.29.2A.2B.2C.2D.3E.4F.60.71.82.93.8E.8F.90.91.92.15.26.37.48.59.6A.7B.8C.9D.16.17.18.19.1A.1B.1C.1D.2E.3F.50.61.72.83.94.A5.9E.9F.A0.A1.A2.A3.A4.14.25.36.47.58.69.7A.8B.9C.1E.2F.40.51.62.73.84.95.A6.13.24.35.46.57.68.79.8A.9B.1F.30.41.52.63.74.85.96.A7.12.23.34.45.56.67.78.89.9A.20.31.42.53.64.75.86.97.A8

;Multiplication table for calculating the north/south offset for multiple tiles. 
;OTHER USE: ROW # IS THE INDEX, RETURNS THE SCREEN TILE # OF THE FIRST COLUMN IN THE SPECIFIED ROW. 
;(used in DARKNESS.ELS)
SCREEN.MULTIPLY_TABLE		.HS	00.11.22.33.44.55.66.77.88.99.AA	

;ROW # IS THE INDEX, RETURNS THE SCREEN TILE # OF THE LAST COLUMN IN THE SPECIFIED ROW. 
;(used in DARKNESS.ELS)
SCREEN.LAST_COLUMN.TABLE	.HS	10.21.32.43.54.65.76.87.98.A9.BA

SCREEN.LAST_ROW.TABLE		.HS	AA.AB.AC.AD.AE.AF.B0.B1.B2.B3.B4.B5.B6.B7.B8.B9.BA

@END

;========SHAPE TABLE OPERATIONS=======
@START
SHAPE							.EQ	$FA				;2byt			;Used by DRAW.TILE. Holds the pointer to the active shape table to be drawn. 	
SHAPE.HOPPER1					.BS $20  			;!32 BYTES
SHP.TBL.CNTR					.BS	$1				;1byt

SHAPE.SIZE						.EQ $1F				;#CONSTANT		(NUMBER OF BYTES-1) IN EACH TILE SHAPE TABLE
SHP.TBL.START.ADDRESS			.EQ $7000			;#CONSTANT. THE STARTING ADDRESS IN AUX MEMORY OF THE TILE SHAPE TABLES


@END





;-------START ABC ORDER--------



;======ANIMATION_MANAGER======
@START
ANIMATION.CALLED_BY				.BS $1			;Used to track the routine which called animation manager. $00 = not tracked (no special handling), $01 = KEYIN.STRING. This variable is reset when ANIMATION.MANAGER exits
ANIMATION.FORCED				.BS $1			;IF FLAG IS SET ($01), THEN AN ANIMATION ABORT TO DUE PLAYER KEY PRESS IS NOT ALLOWED, FORCING THE FULL DRAW OF THE NEXT ANIMATION FRAME.  
ANIMATION.FORCED.OVERRIDE		.BS $1			;USED FOR PLAYTESTING. IF FLAG IS SET ($01), THEN AN ANIMATION ABORT TO DUE PLAYER KEY PRESS IS NOT ALLOWED, FORCING THE FULL DRAW OF THE NEXT ANIMATION FRAME.   
ANIMATION.FRAME_STATE			.BS	$1			;CURRENT ANIMATION FRAME FOR ALL ANIMATION TILES ON THE VIEW SCREEN (0-3)

ANIMATION.TILE_RANGE.START		.EQ $80			;#CONSTANT	;BEGINNING OF ANIMATION TILE SECTION OF THE 256 TILE SHAPES.
ANIMATION.TOTAL_FRAMES			.EQ $03			;#CONSTANT	;TOTAL ANIMATION FRAMES PER TILE (0 COUNTS)

ANIMATION.SCREEN.TALLY			.BS	$1			;A TALLY OF THE NUMBER OF ANIMATED TILES ON THE VIEW SCREEN. UPDATED AFTER COMPLETING AN ANIMATION FRAME CYCLE. USED TO DETERMINE IF A DELAY SHOULD BE INSERTED TO SMOOTH OUT ANIMATION SPEED
ANIMATION.DEEP_WATER.TALLY		.BS $1			;A TALLY OF THE NUMEBR OF DEEP WATER TILES ON THE VIEW SCREEN, used to determine whether to force animation to complete when entire screen is deep water tiles

ANIMATION.DELAY_TRIGGER1		.EQ	$3E			;#CONSTANT	;A DELAY IS TRIGGERD IF MORE THAN THIS MANY ANIMATION TILES ARE ON THE CURRENT VIEW SCREEN
ANIMATION.DELAY1				.EQ $02			;#CONSTANT	;number of JSR WAIT (/w LDA #$FF) to delay for associated trigger
ANIMATION.DELAY_TRIGGER2		.EQ	$7C			;#CONSTANT	;A DELAY IS TRIGGERD IF MORE THAN THIS MANY ANIMATION TILES ARE ON THE CURRENT VIEW SCREEN
ANIMATION.DELAY2				.EQ $01			;#CONSTANT	;number of JSR WAIT (/w LDA #$FF) to delay for associated trigger
ANIMATION.WATER_RANGE.START 	.EQ $88			;#CONSTANT	;FIRST WATER TILE IN THE TILE SET. 
ANIMATION.WATER_RANGE.END 		.EQ $8C			;#CONSTANT	;LAST WATER TILE IN THE TILE SET + $1 

ANIMATION.CURRENT_TILE_TYPE		.BS	$1			;HOLDS THE TILE_TYPE FOR THE CURRENT TILE LOCATION BEING PROCESSED (HOLDS A TILE_TYPE LOADED FROM SCREEN.TILE.DATA OR SCREEN.MO_SPRITE.DATA)

ANIMATION.SCROLL.HOPPER 		.BS $2			;USED WHEN A BYTES FROM ANOTHER SHAPE ARE COPIED IN TO A SCROLLING TILE (EXAMPLE, PLAYER ICON SINKING IN WATER)
ANIMATION.SCROLL.COUNTER		.EQ SHP.TBL.CNTR	;USED IN .LOOP.SCROLL IN ANIMATION.SCROLL.PLAYER TO COUNT THE BYTES READ BY THE LOOP
;the following are used to determine which bytes to load from water shape table when player is sinking
;ANIMATION.SCROLL.WATER_TABLE0	.HS 00.02.04.06.08.0A.0C.0E.10.12.14.16.18.1A.1C.1E
;ANIMATION.SCROLL.WATER_TABLE1	.HS 01.03.05.07.09.0B.0D.0F.11.13.15.17.19.1B.1D.1F
		

	
;MULTI-TILE MOB HANDLING
ANIMATION.MT.TRACKING			.EQ SCREEN.TILE.HOPPER	;10byt	TRACKS MT OBJECTS AS ANIMATION MANAGER REVIEWS THE SCREEN. THE DATA IS USED TO DETERMINE THE TILE_TYPE TO USE FOR EACH OF THE 4 MT TILE #S PER OBJECT. 
ANIMATION.MT.INDEX				.BS $1			;HOLDS THE RECORD INDEX TO THE MOB IN THE CURRENT SCREEN LOCATION
ANIMATION.MT.TILE_NUMBER		.BS	$1			;HOLDS THE CURRENT MT TILE NUMBER OF THE MOB IN THE CURRENT SCREEN LOCATION
ANIMATION.MT.FINAL_TILE_TYPE	.BS $3		;HOLDS THE FINAL TILE_TYPE FOR MT MOBS, NET OF ANY ADJUSTMENTS FOR THE MT TILE # (0-3)


;WATER SCROLLLING
TILE.LINE.COPY_TO				.EQ SHAPE.HOPPER1+$00
TILE.LINE.COPY_FROM 			.EQ SHAPE.HOPPER1+$01
TILE.LINE.FIRST					.EQ SHAPE.HOPPER1+$02	;FIRST LINE IN THE TILE, TO WHICH THE BUFFER (HOLDING THE LAST LINE OF THE TILE) GETS COPIED

@END

;======COMPRESSION==========
@START
;unpacker variables, no need to change these
SRC.ZX7	=	$0
DST.ZX7 =	$2
;END.LZ4	=	$4

UNPACK.ZX7	= $BF00	;ZX7 unpacker subroutine


@END

;======DARKNESS_MANAGER======
@START
SCREEN.DARK.ALGORITHM.ROW				.BS	$1
SCREEN.DARK.ALGORITHM.COLUMN			.BS	$1
SCREEN.DARK.ALGORITHM.LOCATION			.BS $1

SCREEN.DARK.MIDDLE_ROW					.EQ $05		;#CONSTANT
SCREEN.DARK.MIDDLE_COLUMN				.EQ $08		;#CONSTANT

SCREEN.DARK.ALGORITHM.LOCATION_STOP		.BS $1
SCREEN.DARK.ALGORITHM.LOCATION_START	.BS $1
SCREEN.DARK.ALGORITHM.LOCATION_CURRENT	.BS $1

SCREEN.DARK.SEARCH_INDEX.STOP			.EQ $85		;#CONSTANT

;DESIGNATE OBSCURING TILES
;(SURFACE TILE SET)
DARK_FLAGS.EQ1							.EQ TILE_ID.MOUNTAINS.TALL	;#CONSTANT, mountains
DARK_FLAGS.EQ2							.EQ TILE_ID.TREES.BIRCH		;#CONSTANT, birch trees
;(BUILDING TILE SET)
DARK_FLAGS.EQ100						.EQ TILE_ID.WALL.BRICK	;#CONSTANT, brick walls
DARK_FLAGS.EQ101						.EQ TILE_ID.WALL.STONE	;#CONSTANT, stone walls


;USED IN ELS

SCREEN.DARK.ELS.TILE					.EQ SAVED.YREG.LOCAL	;HOLDS THE SCREEN LOCATION OF THE ELS OBJECT BEING EXAMINED FOR IT'S LIGHTING EFFECTS. 
SCREEN.DARK.ELS.ONSCREEN_ANCHOR			.EQ SAVED.YREG.LOCAL	;FOR OFFSCREEN ELS OBJECTS, HOLDS THE ONSCREEN LOCATION USED AS AN ANCHOR FOR WHILE THE ELS OBJECT BEING EXAMINED FOR IT'S LIGHTING EFFECTS. 

SCREEN.DARK.ELS.FLOATING_TILE			.EQ SAVED.ACC.LOCAL		;USED IN THE ALGORITHM FOR ELS LIGHTING TO ITERATE THROUGH THE ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME. 
SCREEN.DARK.ELS.COLUMN.COUNTER			.EQ SAVED.YREG.LOCAL1

;DESIGNATE EXTERNAL LIGHT SOURCE TILES

	;BUILDINGS
DARK_FLAGS.ELS.EQ1						.EQ $9B		;#CONSTANT, Lamp Post
DARK_FLAGS.ELS.EQ2						.EQ $9D		;#CONSTANT, Fire_A
DARK_FLAGS.ELS.EQ3						.EQ $9E		;#CONSTANT, Fire_B
DARK_FLAGS.ELS.EQ4						.EQ $A4		;#CONSTANT, Wall Sconce, left
DARK_FLAGS.ELS.EQ5						.EQ $9D		;#CONSTANT, **NOT USED** (.eq value is a placeholder)


;DELETE ME
TEMPORARY.VARIABLE	.BS $1


;PLS CONSTANTS
SCREEN.DARK.PLS.TORCH					.EQ	$01		;#CONSTANT. 
;**NOTE: SCREEN SIZE CHANGE: there are a bunch of static LDA/STAs that need to be updated in DARKNESS.PLS to implement the torch lighting pattern

@END

;============EVENT MANAGER=============
;***see TIME & EVENTS section below


;======FILES============
@START

;PRODOS FILENAMES
;format is filename length (bytes), filename. length is raw hex number, not ascii value

;MAIN FILES
SRTN.NPC.TALK			.AZ #$0D,/SRTN.NPC.TALK/			;ascii array, using LO values. Filename is limited to !15 characters
SRTN.NPC.TALK.ADDRESS	.EQ SWAP_SPACE.MAIN_MEMORY+$C00		;memory address where file is loaded


;SHAPE FILES
DATA.SHP.SURF 	.AZ #$0D,/DATA.SHP.SURF/	;ascii array, using LO values. Filename is limited to !15 characters
DATA.SHP.BLD	.AZ #$0C,/DATA.SHP.BLD/				;ascii array, using LO values. Filename is limited to !15 characters

DATA.MAP.SURF	.AZ #$0D,/DATA.MAP.SURF/	;ascii array, using LO values. Filename is limited to !15 characters
DATA.SPR.SURF	.AZ #$0D,/DATA.SPR.SURF/	;ascii array, using LO values. Filename is limited to !15 characters

;BUILDING FILES

;LOCATION 1
	;floor1 (map1)
DATA.MAP.M1		.AZ #$0B,/DATA.MAP.M1/	;ascii array, using LO values. Filename is limited to !15 characters
DATA.SPR.M1		.AZ #$0B,/DATA.SPR.M1/	;ascii array, using LO values. Filename is limited to !15 characters
DATA.TLK.L001	.AZ #$0D,/DATA.TLK.L001/	;ascii array, using LO values. Filename is limited to !15 characters
	;floor2 (map2)
DATA.MAP.M2		.AZ #$0B,/DATA.MAP.M2/	;ascii array, using LO values. Filename is limited to !15 characters
DATA.SPR.M2		.AZ #$0B,/DATA.SPR.M2/	;ascii array, using LO values. Filename is limited to !15 characters

;UNDERMAP FILES
DATA.MAP.ULV1	.AZ #$0D,/DATA.MAP.ULV1/	;ascii array, using LO values. Filename is limited to !15 characters
DATA.SPR.ULV1	.AZ #$0D,/DATA.SPR.ULV1/	;ascii array, using LO values. Filename is limited to !15 characters


;*also see offloaded_variables.bin, Data Files section


;FILES LOAD MEMORY ADDRESSES
DATA.OTHER.SUNRISE_SUNSET.AUX.START			.EQ $6C00 ;#CONSTANT

DATA.OTHER.SUNRISE_SUNSET.AUX.LO			.HS	00.BB.76.31.EC.A7
DATA.OTHER.SUNRISE_SUNSET.AUX.HO			.HS	6C.6C.6D.6E.6E.6F

;OTHER FILE INFORMATION
DATA.MAP.SURFACE.TOTAL.SECTORS				.EQ $20 ;#CONSTANT
DATA.MAP.ULV1.TOTAL.SECTORS					.EQ $20 ;#CONSTANT


;FILE RELATED VARIABLES
TOTAL.SECTORS				.BS $1 
USE.COMPRESSION_FLAGS		.BS $1  ($00=OFF | $01 = ON). If OFF, then all zones are compressed. If on, then WZONE.COMPRESSION.FLAGS determines whether a zone is compressed or not. 

;LOCATION.DATA.FILE.CURRENT: see MAP/PLAYER LOCATION


@END

;======GRAPHIC OPERATIONS======
@START

TILE.LINE						.BS	$1				;1byt			KEEPS TRACK OF THE CURRENT LINE IN DRAW.TILE

TILE.DEPTH.STANDARD				.EQ $10				;#CONSTANT		# OF LINES IN 1 TILE
TILE.DEPTH.HALF					.EQ $08				;#CONSTANT		NUMBER OF LINES TO DRAW FOR A "HALF TILE". 

;don't borrow TILE.DEPTH's memory for another variables. I think it has a persistent value most of the time. Borrowing it has caused the graphics to go wonky. 
TILE.DEPTH						.BS $1				;				STORES THE NUMBER OF LINES IN THE CURRENT TILE. USUALLY SET TO THE CONSTANT #TILE.DEPTH.STANDARD
TILE.LINE.START					.BS	$1				;1byt			START LINE OF CURRENT TILE TO BE DRAWN (DRAW.TILE)
TILE.LINE.STOP					.BS	$1				;1byt			STOP LINE OF CURRENT TILE TO BE DRAWN (DRAW.TILE)
TILE.LINE.COPY					.BS $1				;1byt			USED FOR COPYING TILES UP/DOWN IN SCROLL.SCREEN AND ITS' SUBROUTINES

TILE.SHAPE.SIZE					.EQ $20				;#CONSTANT 		NUMBER OF BYTES IN THE SHAPE TABLE FOR EACH TILE

	
	
;Graphics Screen Variables (i.e. the entire Apple Hi-Res screen)
SCREEN.STOP_BYTE				.EQ $28				;#CONSTANT		Last screen byte number (+1) on right edge of Apple Hi-Res Screen
SCREEN.EDGE_BYTE				.EQ $27				;#CONSTANT		Last screen byte number on right edge of Apple Hi-Res Screen

;Screen/Tile Draw Variables (i..e the map portion of the screen)
SCREEN.DRAW.START_BYTE			.EQ $02				;#CONSTANT		STARTING SCREEN BYTE OF FIRST TILE
SCREEN.DRAW.START_LINE			.EQ	$08				;#CONSTANT		STARTING LINE OF FIRST TILE
SCREEN.DRAW.STOP_BYTE			.EQ $22				;#CONSTANT		STOP SCREEN BYTE ON RIGHT SIDE
SCREEN.DRAW.STOP_LINE			.EQ	$B7				;#CONSTANT		STOP LINE AT SCREEN BOTTOM
SCREEN.DRAW.STOP_LINE2			.EQ	$A7				;#CONSTANT		DRAW.ROW.SINGLE LIKES THIS VALUE FOR SOME REASON, NOT SURE WHY
SCREEN.DRAW.LAST_COLUMN			.EQ	$20				;#CONSTANT		STARTING SCREEN BYTE FOR DRAWN THE COLUMN ON THE RIGHT EDGE OF SCREEN

SCREEN.DRAW.CURRENT_BYTE		.BS $1				;1byt			KEEPS TRACK OF THE CURRENT SCREEN BYTE IN DRAW.TILE
SCREEN.DRAW.BYTE1				.BS	$1				;1byt			USED IN DRAW.TILE.FOREGROUND TO TRACK SCREEN BYTES INSTEAD OF A REGISTER
SCREEN.DRAW.BYTE2				.BS	$1				;1byt			USED IN DRAW.TILE.FOREGROUND TO TRACK SCREEN BYTES INSTEAD OF A REGISTER
 
SCREEN.ROW.LAST					.EQ $0A				;#CONSTANT	(!10)
SCREEN.ROW.SIZE					.EQ $11				;#CONSTANT  (!17)
SCREEN.COLUMN.SIZE				.EQ	$0B				;#CONSTANT	(!11)
SCREEN.COLUMN.LAST				.EQ $10				;#CONSTANT	(!16)

SCREEN.ARRAY.LAST_ROW_START		.EQ	$AA				;#CONSTANT		STARTING ARRAY INDEX FOR COPYING TILE DATA INTO SCREEN.TILE.HOPPER
SCREEN.ARRAY.LAST_COLUMN_START	.EQ	$10				;#CONSTANT		STARTING ARRAY INDEX FOR COPYING TILE DATA INTO SCREEN.TILE.HOPPER
SCREEN.ARRAY.LAST_ELEMENT		.EQ	$BA				;#CONSTANT		THE LAST ELEMENT OF SCREEN.TILE.DATA ARRAY
SCREEN.ARRAY.LAST_ELEMENT2		.EQ	$BB				;#CONSTANT		THE LAST ELEMENT OF SCREEN.TILE.DATA ARRAY+$1 (USED FOR STOP VALUE IN CERTAIN SITUATIONS)
SCREEN.ARRAY.OFFSET				.EQ	$11				;#CONSTANT		OFFSET BETWEEN ROWS WHEN ITERATING THROUGH SCREEN.TILE.ARRAY (SAID ANOTHER WAY, ;NUMBER OF ELEMENTS TO ADVANCE IN SCREEN.TILE.ARRAY TO REFERENCE THE NEXT ROW IN THE SAME COLUMN)	
SCREEN.ARRAY.OFFSET_LEFT_DIAGONAL		.EQ $12		;#CONSTANT ;the left/right designation refers to the location of the top of diagonal in an X pattern.
SCREEN.ARRAY.OFFSET_RIGHT_DIAGONAL 		.EQ $10		;#CONSTANT ;the left/right designation refers to the location of the top of diagonal in an X pattern.

SCREEN.ARRAY.STOP_VALUE			.BS $01				;1byt			USED TO DETECTED THE END OF DATA WHEN ITERATING THROUGH A COLUMN IN SCREEN.TILE.DATA

SCREEN.ARRAY.PLAYER_LOCATION	.EQ	$5D				;#CONSTANT		CENTER OF THE SCREEN IN THE SCREEN.TILE.DATA ARRAY
SCREEN.ARRAY.ADJACENT_NORTH		.EQ $4C				;#CONSTANT		TILE DIRECTLY NORTH OF PLAYER LOCATION
SCREEN.ARRAY.ADJACENT_NORTH2	.EQ $3B				;#CONSTANT		2 TILES NORTH OF PLAYER LOCATION

SCREEN.ARRAY.ADJACENT_SOUTH		.EQ $6E				;#CONSTANT		TILE DIRECTLY SOUTH OF PLAYER LOCATION
SCREEN.ARRAY.ADJACENT_SOUTH2	.EQ $7F				;#CONSTANT		2 TILES SOUTH OF PLAYER LOCATION
SCREEN.ARRAY.ADJACENT_EAST		.EQ $5E				;#CONSTANT		TILE DIRECTLY EAST OF PLAYER LOCATION
SCREEN.ARRAY.ADJACENT_EAST2		.EQ $5F				;#CONSTANT		2 TILES EAST OF PLAYER LOCATION
SCREEN.ARRAY.ADJACENT_WEST		.EQ $5C				;#CONSTANT		TILE DIRECTLY WEST OF PLAYER LOCATION
SCREEN.ARRAY.ADJACENT_WEST2		.EQ $5B				;#CONSTANT		2 TILES WEST OF PLAYER LOCATION


SCROLL.STOP_BYTE				.EQ $24				;#CONSTANT		STOP SCREEN BYTE ON RIGHT SIDE WHEN SCREEN SCROLLING
SCROLL.WEST.STOP_BYTE			.EQ $22				;#CONSTANT		STOP SCREEN BYTE ON RIGHT SIDE WHEN SCREEN SCROLLING WEST. NOT SURE WHY THESE NEED TO BE DIFFERENT
SCROLL.STOP.LINE				.EQ $A7				;#CONSTANT		STOP LINE AT BOTTOM WHEN SCREEN SCROLLING

SAVED_TILE_TYPE					.BS $1				;1byt			DRAW.TILE.SINGLE USES THE TILE TYPE STORED IN THIS VARIABLE UNLESS IT IS SET TO $00


;GENERIC DRAWING/SCROLLING VARIABLES
LINE.START 						.EQ TILE.LINE.START
LINE.COPY						.EQ TILE.LINE.COPY
LINE.STOP						.EQ TILE.LINE.STOP

LINE.START.COPY_TO				.EQ LINE.START
LINE.START.COPY_FROM			.EQ LINE.COPY

DRAW.START_BYTE 	.EQ SCREEN.DRAW.BYTE1
DRAW.STOP_BYTE		.EQ TILE.LINE.STOP
DRAW.START_LINE		.EQ TILE.LINE.START
DRAW.STOP_LINE		.EQ TILE.LINE
DRAW.BYTE_VALUE		.EQ SHAPE.HOPPER1+$0 ;$2 byts.
	
@END

;======HI-RES CHARACTER GENERATION (HRCG)=======
@START

HRCG.SIZE.MINUS_1		.EQ $2FF	;#CONSTANT. Size of character set data, in bytes, minus 1. The minus 1 is so that is can be used to dynamically calculate the memory address of the last byte of data. 
	
HRCG.AUX.START			.EQ $5900	;#CONSTANT; Starting memory address in aux memory where Hi Res character set is stored until needed to print a character on screen
HRCG.AUX.END			.EQ $5BFF	;#CONSTANT; Starting memory address in aux memory where Hi Res character set is stored until needed to print a character on screen

HRCG.MAIN.START			.EQ $0C00	;#CONSTANT; Starting memory address in main memory where Hi Res character set is swaped in, when a character needs to be printed to screen
HRCG.MAIN.END			.EQ $0EFF	;#CONSTANT; Starting memory address in main memory where Hi Res character set is swaped in, when a character needs to be printed to screen

HRCG.SHAPE.OFFSET		.EQ $E0		;Stores the offset used to calculate the exact starting address of the shape table for a specific character, using the ASCII value of the character
HRCG.SHAPE.SIZE			.EQ $07		;#CONSTANT; the number of bytes in each character's shape table 

HRCG.BUFFER				.BS $8		;Buffere where a single character copies from aux memory is stored. The HRCG controller at $300 looks in this buffer for the bit map graphics data for all characters it is asked to print. 

@END

;======MAP=====
@START
;(relating the player position on the map and movement on it)

;---ENTERABLE MAPS---
;(note: used by (E)nter command to determine if player is at a map location which is enterable)
;FORMAT: LOCATION X, LOCATION Y, LOCATION CODE, LOCATION TYPE
;Stop value is $FF in byte 2
;												1ST			2nd		    3rd		    4th         5th         STOP VALUE
MAP.LOCATIONS_00			.HS					18.38.01.01.17.38.01.01.17.37.01.01.18.37.01.01.1D.30.40.03.00.00.FF												1ST			STOP VALUE
MAP.LOCATIONS_01			.HS					27.22.02.01.11.26.02.01.09.13.02.01.00.00.FF
MAP.LOCATIONS_02			.HS					27.22.01.01.11.26.01.01.09.13.01.01.00.00.FF
MAP.LOCATIONS_40			.HS					38.40.00.00.00.00.FF
;
;
;FORMAT: LOCATION CODE.DESTINATION, SOURCE GMAP.X, SOURCE GMAP.Y, GMAP.X, GMAP.Y
;Stop value is $FF in byte 0
;												1ST			   2ND	    	  STOP VALUE
MAP.LOCATIONS.START.POSITION_DATA	.HS			40.1D.30.38.40.00.38.40.1D.30.FF						

MAP.LOCATIONS.POINTER		.EQ	SHAPE				;HOLDS A POINTER TO THE MAP.LOCAITONS_xx ARRAY ASSOCIATED WITH THE PLAYER'S CURRENT LOCATION
MAP.LOCATIONS.RECORD		.EQ SHAPE.HOPPER1		;4 BYTES. HOLDS THE CURRENT RECORD WHEN A MAP.LOCATIONS.xx ARRAY IS BEING ITERATED
MAP.LOCATIONS.RECORD.LENGTH .EQ $04					;#CONSTANT. THE NUMBER OF BYTES FOR EACH RECORD IN THE MAP.LOCAITONS_xx ARRAYS. 
MAP.LOCATIONS.SP.RECORD		.EQ SHAPE.HOPPER1+$4	;5 BYTES. HOLDS THE CURRENT RECORD WHEN MAP.LOCATIONS.START.POSITION_DATA ARRAY IS BEING ITERATED
MAP.LOCATIONS.SP.RECORD.LENGTH .EQ $05				;#CONSTANT. THE NUMBER OF BYTES FOR EACH RECORD IN THE MAP.LOCAITONS_xx ARRAYS. 


;LOCATION TYPES
LOCATION.TYPE.SURFACE		.EQ $00				;#CONSTANT
LOCATION.TYPE.BUILDING		.EQ $01				;#CONSTANT
LOCATION.TYPE.BUILDING2		.EQ $02				;#CONSTANT
LOCATION.TYPE.UNDERMAP		.EQ $03				;#CONSTANT

;OTHER
FORWARD.TRANSPORT.BUFFER	.EQ SHAPE.HOPPER1+$1C ;4byts. Stores the transport record values for the location the player is exiting so they can be copied to a transport record for the location the player is entering. 

;------PLAYER LOCATION-----

PLAYER.MAP.LOCATION				.BS $1	;contains the location code of the player's current location. 
PLAYER.MAP.LOCATION_TYPE		.BS $1	;contains the location type (i.e. castle, dungeon etc) of the player's current location. 

PLAYER.MAP.LOCATION.LAST		.BS $A	;Tracks position data on the last location the player was in (including surface map). See Map Objects.xls for a datagram on this array

CURRENT.LOCATION.SPR_DATA		.BS $2 ;Tracks the memory address of the SPR data file associated with the enterable location the player is currently in
CURRENT.LOCATION.TLK_DATA		.BS $2 ;Tracks the memory address of the SPR data file associated with the enterable location the player is currently in

;TILE ID number: a term used to describe the value stored in RMAP, from which other variables such as SMAP, and SMAP.CURRENT are dervied. The tile ID is a unique reference number to a specific tile on the map (from a human perspective). To the computer it is meaningful because the value of Tile ID is also equal to the quantity of tiles on the map in GMAP.TILE.DATA up to and including the tile assocaited with Tile ID. 
GMAP					.BS $2			;Tracks the position on the map in computer terms. Specifically, it is the tile ID number of the tile at the center of the screen where the player stands. 
; GMAP.X					.EQ	$AB45		;Tracks player's x/y position on world map (whereas RMAP tracks position on the regional map which is 9 zones within the world map). Used to identify enterable location, and map edge detection. Future use. compass tracking, longitude. 
; GMAP.Y					.EQ $AB46		;""
GMAP.X					.BS $1		;Tracks player's x/y position on world map (whereas RMAP tracks position on the regional map which is 9 zones within the world map). Used to identify enterable location, and map edge detection. Future use. compass tracking, longitude. 
GMAP.Y					.BS $1		;""
GMAP.X.LAST				.BS $1		;Stores the GMAP X-axis of player prior to the execution of a movement command. Used to deal with differences in Mob and NPC sprite map tracking. 
GMAP.Y.LAST				.BS $1		;Stores the GMAP Y-axis of player prior to the execution of a movement command. Used to deal with differences in Mob and NPC sprite map tracking. 

SMAP					.BS $2			;2byt
SMAP.CURRENT			.BS $2			;2byt
RMAP					.BS $2			;TRACKS PLAYERS POSITION IN THE REGIONAL MAP ARRAY
RMAP.X					.BS $1			;Tracks player x/y axis on regional map. 
RMAP.Y					.BS $1			;Tracks player x/y axis on regional map. 
PLAYER.WMAP.ZONE		.BS $1			;PLAYERS CURRENT WORLD ZONE LOCATION
; RMAP					.EQ $AB40		;TRACKS PLAYERS POSITION IN THE REGIONAL MAP ARRAY
; RMAP.X					.EQ $AB42		;Tracks player x/y axis on regional map. 
; RMAP.Y					.EQ $AB43		;Tracks player x/y axis on regional map. 
; PLAYER.WMAP.ZONE		.EQ $AB44		;PLAYERS CURRENT WORLD ZONE LOCATION


;MAP MOVEMENT OFFSETS
OFFSET.UP				.EQ $30		;#CONSTANT
OFFSET.DOWN				.EQ $30		;#CONSTANT
OFFSET.HORIZONTAL		.EQ $01		;#CONSTANT


OFFSET.SCREEN			.EQ $F8	;#CONSTANT (offset from RMAP calculating RMAP of upper left screen tile)
OFFSET.SCREEN.LL		.EQ $E8	;#CONSTANT (offset from RMAP for calculating RMAP of lower left screen tile)
OFFSET.SCREEN.UR		.EQ $10 ;#CONSTANT (offset from SMAP for calculating RMAP of upper right screen tile)

;MAP CONVERSION TOOLS
TEMPX					.BS $1	;used for math calculations in CONVERT.xxx routines (see map_tools.asm) **SHARED**
TEMPY					.BS $1	;used for math calculations in CONVERT.xxx routines (see map_tools.asm) **SHARED**
TEMPY2					.BS $1	;used for math calculations in CONVERT.xxx routines (see map_tools.asm) **SHARED**


PARM.GMAP.X				.BS $1	;stores GMAP.X as a parameter for CONVERT.xxx routines (see map_tools.asm) **SHARED**
PARM1.GMAP.X			.EQ PARM.GMAP.X	;""
PARM2.GMAP.X			.EQ	TEMPX ;""

PARM.GMAP.Y				.BS $1	;stores GMAP.Y as a parameter for CONVERT.xxx routines (see map_tools.asm)
PARM1.GMAP.Y			.EQ PARM.GMAP.Y	;""
PARM2.GMAP.Y			.EQ	TEMPY ;""

PARM.RMAP.X				.EQ PARM.GMAP.X	;stores RMAP.X as a parameter for CONVERT.xxx routines (see map_tools.asm)
PARM.RMAP.Y				.EQ PARM.GMAP.Y	;stores RMAP.Y as a parameter for CONVERT.xxx routines (see map_tools.asm)
PARM.WZONE				.BS $1	;stores PLAYER.WMAP.ZONE as a parameter for CONVERT.xxx routines (see map_tools.asm)
PARM.RELATIVE.X			.EQ PARM.GMAP.X
PARM.RELATIVE.Y			.EQ PARM.GMAP.Y

RETURN.GMAP.X			.BS $1	;stores return value for CONVERT.GMAP_XY.RMAP_XY
RETURN.GMAP.Y			.BS $1	;stores return value for CONVERT.GMAP_XY.RMAP_XY
RETURN.RMAP.X			.EQ RETURN.GMAP.X	;stores return value for CONVERT.xxx routines (see map_tools.asm)
RETURN.RMAP.Y			.EQ RETURN.GMAP.Y	;stores return value for CONVERT.xxx routines (see map_tools.asm)
RETURN.RELATIVE.X		.EQ PARM.GMAP.X		;""
RETURN.RELATIVE.Y		.EQ PARM.GMAP.Y		;""
RETURN.SCREEN_ARRAY_INDEX .EQ RETURN.GMAP.X ;1 byte


;RETURN.DISTANCE			.EQ RETURN.GMAP.X 	;""

RETURN.RMAP				.BS $2	;stores return value for CONVERT.RMAP_XY.RMAP
RETURN.WZONE			.EQ PARM.WZONE	;stores return value for CONVERT.GMAP_XY.WZONE	




;Multiplication table for calculating the north/south offset for multiple tiles	
RMAP.MULTIPLY_TABLE.LO	.HS	00.30.60.90.C0.F0.20.50.80.B0.E0.10.40.70.A0.D0.00.30.60.90.C0.F0.20.50.80.B0.E0.10.40.70.A0.D0.00.30.60.90.C0.F0.20.50.80.B0.E0.10.40.70.A0.D0
RMAP.MULTIPLY_TABLE.HO 	.HS	00.00.00.00.00.00.01.01.01.01.01.02.02.02.02.02.03.03.03.03.03.03.04.04.04.04.04.05.05.05.05.05.06.06.06.06.06.06.07.07.07.07.07.08.08.08.08.08

@END

;======MAP OBJECT ARRAYS=====
@START
MAP_OBJECTS.MOB		.EQ SWAP_SPACE.MAIN_MEMORY+$900		;tracks x,y position (relative to player) and other data for MOBs (i.e. monsters, enemies of player)

MAP_OBJECTS.GENERAL	.EQ SWAP_SPACE.MAIN_MEMORY+$A00		;tracks x,y position (relative to player) and other data of transport map objects and "other" map objects
MAP_OBJECTS.GENERAL.OFFSET .EQ $A00						;the size of the offset in the above definition
MAP_OBJECTS.GENERAL.AUX .EQ SWAP_SPACE.AUX_MEMORY+MAP_OBJECTS.GENERAL.OFFSET ;the address of this map objects array when it is swapped out to aux memory via SWAP.MAIN_MEMORY.OUT 

MAP_OBJECTS.NPC		.EQ SWAP_SPACE.MAIN_MEMORY+$B00		;tracks actual x,y map coordinates and other data of NPCs (non-player characters)

NPC.SCHEDULE		.EQ SWAP_SPACE.MAIN_MEMORY+$C00		;tracks the map location, time of day, and other information which determines where on the map each NPC is located. 
@END
		
;======MAP_OBJECT_MANAGEMENT======	
@START

SPRITE.RECORD						.BS $C		;Hold the current map object record being processed by MO.DRAW
SPRITE.RECORD.SIZE					.EQ $C		;#CONSTANT. # of bytes in SPRITE.RECORD
GENERAL_MO.RECORD					.EQ SPRITE.RECORD ;same as SPRITE.RECORD but for general map objects


;MAP OBJECT CREATION
MAP_OBJECTS.CREATE.TRANSPORT.X				.EQ SCREEN.TILE.HOPPER+$A			;PARAMETER FOR MO.TRANSPORT.CREATE
MAP_OBJECTS.CREATE.TRANSPORT.Y				.EQ SCREEN.TILE.HOPPER+$B			;PARAMETER FOR MO.TRANSPORT.CREATE
MAP_OBJECTS.CREATE.TRANSPORT.TILE_TYPE		.EQ SCREEN.TILE.HOPPER+$C			;PARAMETER FOR MO.TRANSPORT.CREATE
MAP_OBJECTS.CREATE.TRANSPORT.SKIFFS			.EQ SCREEN.TILE.HOPPER+$D			;PARAMETER FOR MO.TRANSPORT.CREATE



;MAP/SCREEN LOCATION
MAP_OBJECTS.MAP_LOCATION	.BS $2		;STORES THE GMAP LOCATION A GIVEN MAP OBJECT
MAP_OBJECTS.TILE_LOCATION	.BS $1		;STORES THE SCREEN TILE # OF A GIVEN MAP OBJECT
MAP_OBJECTS.PLAYER_LOCATION .EQ $80		;#CONSTANT. THE X,Y LOCATION THAT REPRESENTS THE PLAYER AS IT RELATES TO MAP OBJECTS AND CALCULATING THEIR PROXIMITY TO THE PLAYER


;MAP/SCREEN OPERATIONS (GENERAL)
MANAGE_OBJECTS.NPC_MOB.INDEX.FLAG	.BS $01		;since the MOB and NPC map object arrays are not the same size, this flag tracks whether the index points to a MOB record only or a MOB & NPC Record. $00 = Mob & NPC, $01 = Mob only,
MANAGE_OBJECTS.NPC_MOB.RECORD.FLAG	.BS $01		;tracks whether the sprite object loop is in mob or NPC mode. ;$00=mob record, $01=npc record, >=$02=next map object record

GMAP.X.TO_CONVERT					.EQ TEMPX	;Used to hold the value for GMAP to player-relative.X/Y conversions because the value could be GMAP.X/Y or GMAP.X/Y.LAST
GMAP.Y.TO_CONVERT					.EQ TEMPY	;""
; CONVERT.SPRITE.GMAP.X				.EQ TEMP16 		;Used to hold the value of either a MOB or NPC's GMAP.X/Y during the conversion to player relative X/Y
; CONVERT.SPRITE.GMAP.Y				.EQ TEMP16+$1   ;""



MAP_OBJECTS.X.LAST_COLUMN 			.EQ $88		;#CONSTANT. STORES THE VALUE OF THE LAST COLUMN ON THE X-AXIS
MAP_OBJECTS.X.FIRST_COLUMN			.EQ $78		;#CONSTANT. STORES THE VALUE OF THE FIRST COLUMN ON THE X-AXIS
MAP_OBJECTS.Y.LAST_ROW 				.EQ $85		;#CONSTANT. STORES THE VALUE OF THE LAST ROW ON THE Y-AXIS
MAP_OBJECTS.Y.FIRST_ROW				.EQ $7B		;#CONSTANT. STORES THE VALUE OF THE 2ND ROW ON THE Y-AXIS

MAP_OBJECTS.X_APPROACH				.HS	76.77.89.8A	;X-AXIS APPROACH VALUES, FOR MOBS IN THE COLUMN/ROW ON THE EDGE OF VIEW SCREEN. FIRST COLUMN -1, -2, LAST COLUMN +1,+2. DOUBLE MOVERS ARE TAKEN INTO CONSIDERATION. 
MAP_OBJECTS.Y_APPROACH				.HS	79.7A.86.87	;Y-AXIS APPROACH VALUES, FOR MOBS IN THE COLUMN/ROW ON THE EDGE OF VIEW SCREEN. FIRST ROW -1,-2, LAST ROW +1,+2. DOUBLE MOVERS ARE TAKEN INTO CONSIDERATION. 

MOB.POSITION.X_GR					.EQ TEMPX	;based on the position of a mob (net of current player move, before mob moves). if != $00 then mob's x position is greater than player. 
MOB.POSITION.X_LT					.EQ TEMPY	;based on the position of a mob (net of current player move, before mob moves). if != $00 then mob's x position is less than player. 
MOB.POSITION.Y_GR					.EQ TEMPY2	;based on the position of a mob (net of current player move, before mob moves). if != $00 then mob's y position is greater than player.
MOB.POSITION.Y_LT					.EQ PARM.GMAP.X	;based on the position of a mob (net of current player move, before mob moves). if != $00 then mob's y position is less than player. 

MAP_OBJECTS.SS.X_FLAG.LOWER			.BS $1		;STORES THE FLOATING VALUES REPRESENTING THE EDGE OF THE REGIONAL MAP IN MOB X/Y TERMS, WHICH ADJUSTS AS THE PLAYER MOVES. 
MAP_OBJECTS.SS.X_FLAG.UPPER			.BS $1		;STORES THE FLOATING VALUES REPRESENTING THE EDGE OF THE REGIONAL MAP IN MOB X/Y TERMS, WHICH ADJUSTS AS THE PLAYER MOVES.
MAP_OBJECTS.SS.Y_FLAG.LOWER			.BS $1		;STORES THE FLOATING VALUES REPRESENTING THE EDGE OF THE REGIONAL MAP IN MOB X/Y TERMS, WHICH ADJUSTS AS THE PLAYER MOVES.
MAP_OBJECTS.SS.Y_FLAG.UPPER			.BS $1		;STORES THE FLOATING VALUES REPRESENTING THE EDGE OF THE REGIONAL MAP IN MOB X/Y TERMS, WHICH ADJUSTS AS THE PLAYER MOVES.



MAP_OBJECTS.SS.X_FLAG.LOWER.START	.EQ $67		;#CONSTANT. Marks the mob x/y left edge of the regional map when player is at the starting zone position. Use for SS in-region check.
MAP_OBJECTS.SS.X_FLAG.UPPER.START	.EQ $98		;#CONSTANT. Marks the mob x/y right edge of the regional map when player is at the starting zone position. Use for SS in-region check.
MAP_OBJECTS.SS.Y_FLAG.LOWER.START	.EQ $68		;#CONSTANT. Marks the mob x/y top edge of the regional map when player is at the starting zone position. Use for SS in-region check.
MAP_OBJECTS.SS.Y_FLAG.UPPER.START	.EQ $99		;#CONSTANT. Marks the mob x/y bottom edge of the regional map when player is at the starting zone position. Use for SS in-region check.

MOB.SCREEN_STATUS.START				.BS $1		;BEFORE THE EFFECT OF THE PLAYER MOVE IS APPLIED, IS THE CURRENT MOB RECORD ONSCREEN? $00=YES, $01=NO
MOB.SCREEN_STATUS.NPM				.BS $1		;AFTER THE EFFECT OF THE PLAYER MOVE IS APPLIED, IS THE CURRENT MOB RECORD ONSCREEN? $00=YES, $01=NO

MOB.SCREEN_STATUS.SS				.BS $1		;AFTER THE EFFECT OF THE PLAYER MOVE IS APPLIED, IF $01 THE CURRENT MOB RECORD BEING PROCESED FOR MOVEMENT HAS THE SS FLAG SET, AND THAT MOB IS CURRENTLY NOT LOCATED ON THE VIEW SCREEN


;MAP/SCREEN OPERATIONS (ONSCREEN CHECK)
MAP_OBJECTS.X_FLAG.LOWER	.EQ $78		;#CONSTANT. LEFT SIDE X BOUNDARY. See Screen Map, in map matrix worksheet, in Game Map spreadsheet
MAP_OBJECTS.X_FLAG.UPPER	.EQ $89		;#CONSTANT. RIGHT SIDE X BOUNDARY+1. See Screen Map, in map matrix worksheet, in Game Map spreadsheet
MAP_OBJECTS.Y_FLAG.LOWER	.EQ $7B		;#CONSTANT. UPPER SIDE Y BOUNDARY. See Screen Map, in map matrix worksheet, in Game Map spreadsheet
MAP_OBJECTS.Y_FLAG.UPPER	.EQ $86		;#CONSTANT. LOWER SIDE X BOUNDARY+1. See Screen Map, in map matrix worksheet, in Game Map spreadsheet
		
MOB.RZONE.POSITION			.EQ MOB.POSITION.X_GR	;1byt	Stores a value used to compare to the player RMAP.X/Y to determine if the SS Mob is location in the regional map

;MAP OBJECT DATA
MAP_OBJECTS.RECORD_LENGTH	.EQ	$04		;#CONSTANT. NUMBER OF FIELDS (BYTES) IN A MAP OBJECTS RECORD. IT'S A QTY FOR INCREMENTING SO $00 COUNTS AS 1. CURRENTLY IT'S THE SAME FOR BOTH ARRAYS (MAP_OBJECTS.GENERAL, MAP_OBJECTS.MOBS)										
MAP_OBJECTS.X_ADJ			.BS $1		;STORES THE ADJUSTMENT TO PLAYER LOCATION NEEDED TO CALCUALTE SCREEN TILE FOR A MAP OBJECT, BASED ON ITS X LOCATION.
MAP_OBJECTS.Y_ADJ			.BS $2		;SAME CONCEPT AS X_ADJ, BUT NEEDS 2BYTES BECAUSE Y ADJUSTMENTS CAN BE MUCH LARGER. 

;MISC
SPRITE.DRAWTILE.OVERRIDE	.BS $1		;used to force a sprite tile to be drawn even if under certain conditional logic would other prevent it from being draw.
SPRITE.ERASETILE.OVERRIDE	.BS $1		;used to force a sprite tile to be drawn even if under certain conditional logic would other prevent it from being erased.

;FLAGS
MOB.FLAG0					.BS	$1
MOB.FLAG1					.BS	$1
MOB.FLAG2					.BS	$1
MOB.FLAG3					.BS	$1
MOB.FLAG4					.BS	$1
MOB.FLAG5					.BS	$1
MOB.FLAG6					.BS	$1
MOB.FLAG7					.BS	$1
SPRITE.FLAGS_BYTE3			.EQ	MOB.FLAG0	;USED WITH A LOOP FOR WRITING VALUES TO ALL FLAGS AT ONCE

GENERAL.FLAG0				.EQ MOB.FLAG0
GENERAL.FLAG1				.EQ MOB.FLAG1
GENERAL.FLAG2				.EQ MOB.FLAG2
GENERAL.FLAG3				.EQ MOB.FLAG3
GENERAL.FLAG4				.EQ MOB.FLAG4
GENERAL.FLAG5				.EQ MOB.FLAG5
GENERAL.FLAG6				.EQ MOB.FLAG6
GENERAL.FLAG7				.EQ MOB.FLAG7
MAP_OBJECTS.GENERAL_FLAGS	.EQ	MOB.FLAG0	;USED WITH A LOOP FOR WRITING VALUES TO ALL FLAGS AT ONCE
@END

;=====MOB/TRANSPORT MOVEMENT=====
@START
MOB.MOVE.CURRENT			.BS $1		;IF A MOB DECIDED TO MOVE, THIS VARIABLE HOLDS THE DIRECTION CODE. SAME DIRECTION CODES AS FOR PLAYER MOVEMENT (SEE GAME_LOOP.ASM)
MOB.MOVE.COUNTER			.BS $1		;COUNTS MOVES FOR DOUBLE-MOVER MOBS
MOB.MOVE.ERASE_COUNTER		.BS $1		;RECORD WHEN ERASE TILE IS EXECUTED ON A GIVEN TURN FOR A MOB, SO THAT DOUBLE MOVER'S DON'T ERASE TWICE
MOB.MOVE.OPTIONS_PRIMARY	.BS $5		;SIZED TO $5 SO THE MOVE DECISION ARRAYS CAN BE INIT IN ONE LOOP
MOB.MOVE.OPTIONS_SECONDARY	.BS $5		;SIZED TO $5 SO THE MOVE DECISION ARRAYS CAN BE INIT IN ONE LOOP
MOB.MOVE.OPEN_PATHS			.BS $5		;SIZED TO $5 SO THE MOVE DECISION ARRAYS CAN BE INIT IN ONE LOOP

MOB.MOVE.TOTAL_OPEN_PATHS	.BS $1		;USED TO GUIDE THE PARSING OF THE RANDOM NUMBER RESULTS USED TO SELECT THE MOVE OPTION
MOB.MOVE.CANDIDATE			.BS $1		;USED TO STORE THE MOVE DIRECTION CODE OF THE MOVE THE MOB WANTS TO MAKE, AND WILL MAKE UNLESS BLOCKED.
MOB.MOVE.LAST				.BS	$1		;RECORDS THE LAST MOVE THE MOB MADE. IN THE INITIAL IMPLEMENTATION, IT WOULD NOT RECORD A PASS AS A MOVE, SO MOBS NEVER PASS TWICE
MOB.MOVE.SLOW.PROGRESS 		.EQ SCREEN.TILE.HOPPER+$9	;SET TO $01 IF MOB ENCOUNTERS SLOW PROGRESS ON A GIVEN MOVE. NEEDED FOR DOUBLE MOVERS, TO FORCE A TILE DRAW BECAUSE SLOW PROGRESS = PASS AND NORMALLY TILES AREN'T DRAWN ON A PASS. 


SPRITE.USE.ADHOC.PATHFINDER	.EQ $5		;Distance (in tiles) between player and sprite for when adhoc pathfinder algorithm is used to control sprite movement (if distance >= this constant, then use adhoc pathfinder)

;MOVEMENT COLLISION RULES
MOB.COLLISION_OVERRIDE		.BS $1		;$00 = OFF, $01 = ON
MOB.MOVES.BLOCKED			.BS $05		;STORES A VALUE INDICATING WHETHER EACH OF THE TILES ADJACENT TO THE MOB IS BLOCKED ($00 = PERMITTED, $01 BLOCKED)


	
MOB.MT.ADJACENT_TILES		.EQ SHAPE.HOPPER1			;$8byt. Stores the screen tile # of all adjacent tiles to a MT MOB, organized into 4 directional groups of 4 tiles each. 
MOB.MT.NORTH_GROUP			.EQ SHAPE.HOPPER1			;$2byt. Stores the screen tile # of the 4 tiles adjacent to the MT MOB in the direction noted. Used for collision controls.
MOB.MT.SOUTH_GROUP			.EQ SHAPE.HOPPER1+$02		;$2byt. Stores the screen tile # of the 4 tiles adjacent to the MT MOB in the direction noted. Used for collision controls.
MOB.MT.EAST_GROUP			.EQ SHAPE.HOPPER1+$04		;$2byt. Stores the screen tile # of the 4 tiles adjacent to the MT MOB in the direction noted. Used for collision controls.
MOB.MT.WEST_GROUP			.EQ SHAPE.HOPPER1+$06		;$2byt. Stores the screen tile # of the 4 tiles adjacent to the MT MOB in the direction noted. Used for collision controls.

MOB.ADJACENT_TILES			.EQ SCREEN.TILE.HOPPER		;4byt. STORES THE TILE #'S OF THE TILES ADJACENT TO THE MOB FOR USE WITH COLLISION CHECKS. BORROWS THE MEMORY USED BY SCREEN.TILE.HOPPER 
;MOB.ADJACENT_TILES			.BS $4			;4byt. STORES THE TILE #'S OF THE TILES ADJACENT TO THE MOB FOR USE WITH COLLISION CHECKS. BORROWS THE MEMORY USED BY SCREEN.TILE.HOPPER 

MOB.MT.TILE_LOCATIONS		.EQ SCREEN.TILE.HOPPER+$4	;4byt. STORES THE SCREEN TILE # OF EACH TILE OF A MULTI-TILE MOB. BORROWS THE MEMORY USED BY SCREEN.TILE.HOPPER
MOB.MT.TILE_TYPES			.EQ SCREEN.DARK.HOPPER		;4byt. STORES THE TILE TYPES OF ALL 4 TILES IN A MT MOB. BORROWS MEMORY USED FOR SCREEN.DARK.HOPPER. 
MOB.MT.GROUP_COUNTER		.EQ SHP.TBL.CNTR			;1byt. COUNTER FOR THE #COLLISION CHECK ROUTINE FOR MULTI-TILE MOBS. BORROWS MEMORY. 
MOB.MT.POSITION.X			.EQ SCREEN.TILE.HOPPER+$8	;1byt. STORES THE X-AXIS OF TILE0 OF THE MT MOB. BORROWS MEMORY. 
MOB.MT.ADJACENT_TILES.PTR 	.EQ $FA						;STORES A POINTER TO THE DIRECTIONAL GROUP IN MOB.MT.ADJACENT_TILES FOR MULT-TILE MOBS COLLISION CONTROLS.

TRANSPORT.MT.TILE_LOCATIONS .EQ SCREEN.TILE.HOPPER+$4   ;SEE MOB.MT.TILE_LOCATIONS
TRANSPORT.MT.TILE_TYPES	 	.EQ SCREEN.DARK.HOPPER		;SEE MOB.MT.TILE_TYPES
TRANSPORT.MT.POSITION.X 	.EQ SCREEN.TILE.HOPPER+$8	;SEE MOB.MT.POSITION.X
;TRANSPORT.MT.ADJACENT_TILES	.EQ SHAPE.HOPPER1			;$8byt. Stores the screen tile # of all adjacent tiles to a MT MOB, organized into 4 directional groups of 4 tiles each. 
; TRANSPORT.MT.GROUP_COUNTER	.EQ SHP.TBL.CNTR			;SEE MOB.MT.GROUP_COUNTER
; TRANSPORT.MT.ADJACENT_TILES.PTR 	.EQ $FA				;STORES A POINTER TO THE DIRECTIONAL GROUP IN MOB.MT.ADJACENT_TILES FOR MULT-TILE MOBS COLLISION CONTROLS.

TRANSPORT.MT.COLLISSION.HOPPER	.EQ SHAPE.HOPPER1			;$2byt. Stores the screen tile # of the two tiles in the candidate move direction which need to be checked by collision controls.

; TRANSPORT.MT.NORTH_GROUP		.EQ SHAPE.HOPPER1			;$2byt. Stores the screen tile # of the 4 tiles adjacent to the MT MOB in the direction noted. Used for collision controls.
; TRANSPORT.MT.SOUTH_GROUP		.EQ SHAPE.HOPPER1+$02		;$2byt. Stores the screen tile # of the 4 tiles adjacent to the MT MOB in the direction noted. Used for collision controls.
; TRANSPORT.MT.EAST_GROUP			.EQ SHAPE.HOPPER1+$04		;$2byt. Stores the screen tile # of the 4 tiles adjacent to the MT MOB in the direction noted. Used for collision controls.
; TRANSPORT.MT.WEST_GROUP			.EQ SHAPE.HOPPER1+$06		;$2byt. Stores the screen tile # of the 4 tiles adjacent to the MT MOB in the direction noted. Used for collision controls.


COLLISION_FLAG.MOB_SEA.START	.EQ $F3		;FIRST TILE IN SEA MOB RANGE, USE TO DETERMINE IF THE CURRENT MOB OBJECT IS A LAND MOB OR SEA MOB
COLLISION_FLAG.MOB_LAND.LT1		.EQ	$33		;#CONSTANT
COLLISION_FLAG.MOB_LAND.GRE		.EQ	$80		;#CONSTANT
COLLISION_FLAG.MOB_LAND.LT2		.EQ	$8C		;#CONSTANT
COLLISION_FLAG.MOB_LAND.EQ1		.EQ	$46		;#CONSTANT

COLLISION_FLAG.MOB_CROC.GRE1	.EQ	$63		;#CONSTANT
COLLISION_FLAG.MOB_CROC.LT1		.EQ	$7B		;#CONSTANT
COLLISION_FLAG.MOB_CROC.EQ1		.EQ	$41		;#CONSTANT
COLLISION_FLAG.MOB_CROC.EQ2		.EQ	$88		;#CONSTANT
@END

;========MOB GENERATION=======
@START

GAME.MOB_GEN.CONTROL		.BS	$1		;STORES $00 FOR MOB GEN = OFF, HOLDS $01 FOR MOB GEN = ON
GAME.TURN.CONTROL			.BS	$1		;STORES $00 FOR PLAYER TURN, HOLDS $01 FOR MOB/NPC TURN

MOB.GEN.QUEUE				.BS $1		;WHEN MOB GENERATION IS ABORTED DUE TO PLAYER KEYPRESS, #$01 IS ADDED TO THIS VARIABLE SO THAT GENERATION CAN CATCHUP WHEN THE PROCESSOR IS FREE
;MOB.GEN.QUEUE				.EQ $910D	;WHEN MOB GENERATION IS ABORTED DUE TO PLAYER KEYPRESS, #$01 IS ADDED TO THIS VARIABLE SO THAT GENERATION CAN CATCHUP WHEN THE PROCESSOR IS FREE

MOB.GEN.SEA_FLAG			.BS $1		;RANDOM GENERATOR SELECTED A SEA MOB TYPE IF THIS FLAG IS SET TO #$01
MOB.GEN.PROBABILITY			.BS $1		;CHANCE THAT GAME WILL ATTEMPT TO GENERATE A MOB ON A GIVEN RUN OF MOB.GENERATION, PROVIDED THAT IT'S NOT PLAYERS TURN

;MOB.GEN.SS_QTY				.EQ SHAPE.HOPPER1	;The current number of SS in the current region
MOB.GEN.SS_QTY				.BS $1		;The current number of off screen SS in the current region

MOB.GEN.SS_LIMIT			.EQ $10		;#CONSTANT. THE MAXIMUM NUMBER OF SS PERMITTED TO BE ACTIVE IN THE CURRENT REGION (NO NEW ONES GENERATED BEYOND THIS LIMIT)
;MOB.GEN.ARRAY_FULL_COUNTER	.EQ SHAPE.HOPPER1+$01	;WHEN THE MAP OBJECTS/MOB ARRAY IS FULL, THIS COUNTER IS USED TO INCREMENT THE RECORD THAT WILL BE OVERWRITTEN, SO IT'S NOT ALWAYS THE SAME ONE.
MOB.GEN.ARRAY_FULL_COUNTER	.BS $1		;WHEN THE MAP OBJECTS/MOB ARRAY IS FULL, THIS COUNTER IS USED TO INCREMENT THE RECORD THAT WILL BE OVERWRITTEN, SO IT'S NOT ALWAYS THE SAME ONE.


MOB.CANDIDATE.RMAP			.BS $2		;STORES THE RANDOM NUMBER GENERATED FOR A NEW MOB'S LOCATION, BEFORE THE LOCATION HAS BEEN CHECKED FOR COLLISION
;MOB.CANDIDATE.GMAP			.EQ $9102		;STORES THE RANDOM NUMBER GENERATED FOR A NEW MOB'S LOCATION, BEFORE THE LOCATION HAS BEEN CHECKED FOR COLLISION

MOB.CANDIDATE.TYPE			.BS $1		;STORES THE TILE_TYPE VALUE (BYTE2 OF THE MOB RECORD) FOR A NEW MOB BEING CREATED
MOB.CANDIDATE.FLAGS			.BS $1		;STORES THE FLAG VALUE (BYTE3 OF THE MOB RECORD) FOR A NEW MOB BEING CREATED

MOB.GEN.RANDOM_LO.START		.EQ	$01		;#CONSTANT. USED FOR RANDOM NUMBER GENERATION. CORRESPONDS TO THE LO BYTE OF THE SCREEN ARRAY
MOB.GEN.RANDOM_LO.END		.EQ	$FF		;#CONSTANT. USED FOR RANDOM NUMBER GENERATION. CORRESPONDS TO THE LO BYTE OF THE SCREEN ARRAY
MOB.GEN.RANDOM_HO.START		.EQ	$00		;#CONSTANT. USED FOR RANDOM NUMBER GENERATION. CORRESPONDS TO THE LO BYTE OF THE SCREEN ARRAY
MOB.GEN.RANDOM_HO.END		.EQ	$08		;#CONSTANT. USED FOR RANDOM NUMBER GENERATION. CORRESPONDS TO THE LO BYTE OF THE SCREEN ARRAY

MOB.CANDIDATE.MAP.X			.BS $1		;STORES CANDIDATE MOB'S MAP X-AXIS LOCATION. DIFFERENT THAN THE X,Y USED TO STORE MOB'S RELATIVE POSITION TO PLAYER
MOB.CANDIDATE.MAP.Y			.BS $1		;STORES CANDIDATE MOB'S MAP X-AXIS LOCATION. DIFFERENT THAN THE X,Y USED TO STORE MOB'S RELATIVE POSITION TO PLAYER
MOB.CANDIDATE.RELATIVE.X	.BS $1		;STORES CANDIDATE MOB'S RELATIVE (TO PLAYER) X-AXIS LOCATION. 
MOB.CANDIDATE.RELATIVE.Y	.BS $1		;STORES CANDIDATE MOB'S RELATIVE (TO PLAYER) Y-AXIS LOCATION.

; MOB.CANDIDATE.MAP.X			.EQ $9106		;STORES CANDIDATE MOB'S MAP X-AXIS LOCATION. DIFFERENT THAN THE X,Y USED TO STORE MOB'S RELATIVE POSITION TO PLAYER
; MOB.CANDIDATE.MAP.Y			.EQ $9107	;STORES CANDIDATE MOB'S MAP X-AXIS LOCATION. DIFFERENT THAN THE X,Y USED TO STORE MOB'S RELATIVE POSITION TO PLAYER
; MOB.CANDIDATE.RELATIVE.X	.EQ $9108	;STORES CANDIDATE MOB'S RELATIVE (TO PLAYER) X-AXIS LOCATION. 
; MOB.CANDIDATE.RELATIVE.Y	.EQ $9109	;STORES CANDIDATE MOB'S RELATIVE (TO PLAYER) Y-AXIS LOCATION.


;GENERATION FLAGS (COLLISION AND DETERMINE IF SEA MOB)		
MOB.GEN_FLAG.GRE				.EQ $88		;#CONSTANT
MOB.GEN_FLAG.LT2				.EQ $8C		;#CONSTANT
MOB.GEN_FLAG.LT1				.EQ $33		;#CONSTANT
@END

;========NPC MOVEMENT/SCHEDULES=====
@START


;===========NPC.PATHFINDER=========
PATHFINDER.SPRITE.RECORD			.BS $0C		;Holds the information on the sprite for which pathfinder is generating a path. 

NPC.PATHFINDER.ABORT_FLAG			.BS $01 	;$00 = No abort, $01 = aborted path is pending completion
KEYPRESS.ABORT.ITERATIONS.DEFAULT	.EQ $03		;#CONSTANT. required iterations before auto-abort 
;set to $FF to disable auto abort. normally default value is $03
KEYPRESS.ABORT.ITERATIONS			.BS $01		;usually set to the default value (see above constant). Or set to $FF to disable auto abort.


NPC.PATHFINDER.DIRECTIONS_CHECKED	.BS $4		;tracks which directions, from the current tile, have been checked for open paths.
NPC.PATHFINDER.TILE_NUMBER.TALLY	.BS $1		;the next tile number available to be assigned by the pathfinder subroutine, for use in the NPC.PATHFINDER.SEARCH.PATHS array
NPC.PATHFINDER.CURRENT.TILE			.BS $1		;the tile number, unique to the pathfinder subroutine, associated with the current tile used as the center of the search pattern. 
NPC.PATHFINDER.CURRENT.TILE.X		.BS $1		;the RMAP.X and RMAP.Y axis of the current tile number are recorded in the NPC.PATHFINDER.SEARCH.PATHS array as the source x,y for all neigbor tiles. 
NPC.PATHFINDER.CURRENT.TILE.Y		.BS $1		;""
NPC.PATHFINDER.CURRENT.DISTANCE		.BS $1		;distance from the current tile to the destination. 
NPC.PATHFINDER.CURRENT.RMAP			.BS $1		;the RMAP associated with the current tile used as the center of the search pattern. 
NPC.PATHFINDER.NEIGHBOR.X			.BS $1		;X-axis of the most recetly acquired neighbor tile.
NPC.PATHFINDER.NEIGHBOR.Y			.BS $1		;Y-axis of the most recetly acquired neighbor tile.
NPC.PATHFINDER.NEIGHBOR.RMAP		.BS $2		;RMAP of the most recetly acquired neighbor tile.



NPC.PATHFINDER.PRIORITY.QUE			.EQ $AF00	;$100bytes stores the order in which the tile_numbers discovered are applied to the search pattern to discover new neigbor tiles. 	
; NPC.PATHFINDER.PRIORITY.QUE			.EQ RWBUFF	;$100bytes stores the order in which the tile_numbers discovered are applied to the search pattern to discover new neigbor tiles. 

NPC.PATHFINDER.PRIORITY.QUE.SIZE			.EQ NPC.PATHFINDER.PRIORITY.QUE		;the first byte of the priority que holds the # of records in the array, which is incremented each time a record is added and decremented each time a record is deleted. 
NPC.PATHFINDER.PRIORITY.QUE.RECORD_TALLY	.BS $1	;number of 2byte records in the priority que, including the 2 byte length header. For this reason, it is equal to the number of records in the que +1
NPC.PATHFINDER.PRIORITY.QUE.RECORD_INDEX	.BS $1  ;derived from NPC.PATHFINDER.PRIORITY.QUE.RECORD_TALLY. Used to toggle between writing new records after last record in que or overwriting last record in que. 
NPC.PATHFINDER.PRIORITY.QUE.PROCESSED.RECORDS	.BS $1	;the number of processed records which are included in NPC.PATHFINDER.PRIORITY.QUE.SIZE. 
PATHFINDER.STREET.PREFERENCE					.BS $1  ;PARAMETER. The value to add to the distance of non-street tiles in order to help pathfinder generate a path that uses streets when available.  

;----------------------------------
;*****MUST START ON PAGE BOUNDARY
NPC.PATHFINDER.SEARCH.PATHS			.EQ $B000	;16-BIT ($19Ebytes) Built by the pathfinder subroutine to contain the path from the NPCs current location (when the algorithm is run) and the destination location that the NPC is trying to travel to. 
; NPC.PATHFINDER.SEARCH.PATHS			.EQ ZONE_TOOLS.OUTPUT_BUFFER	;16-BIT ($19Ebytes) Built by the pathfinder subroutine to contain the path from the NPCs current location (when the algorithm is run) and the destination location that the NPC is trying to travel to. 
;----------------------------------
SEARCH.PATHS.NEIGHBORS_ADDED.COUNTER	.BS $1		;stores the number of neighbors added each iteration so that it is detectable when no neighbors are added.
SEARCH.PATHS.RECORD.SIZE			.EQ $08		;#CONSTANT. the number of bytes in each record stored in NPC.PATHFINDER.SEARCH.PATHS
SEARCH.PATHS.LO_INDEX				.BS $1 		;used to track the lo byte index when iterating NPC.PATHFINDER.SEARCH.PATHS
SEARCH.PATHS.HIMEM					.EQ $BAFF	;the upper limit of the memory reserved for the NPC.PATHFINDER.SEARCH.PATHS array 

NPC.PATHFINDER.SEARCH.PATHS.POINTER		.EQ $EC		;2byt. Used by .open.paths to load data into NPC.PATHFINDER.SEARCH.PATHS, when an open path is found for a given tile.
NPC.PATHFINDER.SEARCH.PATHS.POINTER2	.EQ $FC		;2byt. Used by .LOAD.NEXT.TILE to lookup data from NPC.PATHFINDER.SEARCH.PATHS, to load the next path tile.
SEARCH.PATHS.POINTER.SAVED				.BS $01		;This pointer needs to be persistent through an entire instance of pathfinder. This variable saves the value of the pointer when a keypress abort occurs so it can be reloaded upon re-entry.

NPC.PATHFINDER.FINAL.PATH			.EQ $BF00	;stores the final path, which is derviced from the data in NPC.PATHFINDER.SEARCH.PATHS after the algorith completes.  
FINAL.PATH.HIMEM					.EQ $BFFF	;the upper limit of the memory reserved for the NPC.PATHFINDER.FINAL.PATH array 
FINAL.PATH.RECORD.COUNTER			.BS $1		;counts records written to NPC.PATHFINDER.FINAL.PATH so that the last record's index can be calculated. The last record will be the next move the NPC makes to reach destination. 
FINAL.PATH.INDEX					.EQ FINAL.PATH.RECORD.COUNTER ;used in NPC.MOVE_MANGER to point to the next move in an NPC's existing path

NPC.PATHFINDER.DESTINATION.TILE.X	.BS $1		;the RMAP.X and RMAP.Y axis of the tile which NPC wants to move to. 
NPC.PATHFINDER.DESTINATION.TILE.Y	.BS $1		;""
PATH_TILE.SHORTEST.DISTANCE			.BS $1		;the path tile # that has the lowest distance to destination. Used by the algorithm to prioritize the search. 
PATHFINDER.SHORTEST.DISTANCE.COUNTER .BS $1		;used to track when a neighbor is found which is closer to the destination than the previous closest tile found. If at least one such neighbor is found in a given iteration, no sort is performed.
NPC.PATHFINDER.NEXT.SOURCE_TILE		.BS $1		;when assembling the final path, this is the next source path tile #, working backwards from destination to NPC's current position.


PATHFINDER.SWAP.DISTANCE			.BS $1		;used for temp data storage when moving records around in the priority que. 
PATHFINDER.SWAP.TILE_NUMBER			.BS $1		;""


ACQUIRE.LOOP.COUNTER				.BS $1 		;counter for the loop which uses a T shaped search pattern to acquire new neighbors
ITERATION.COUNTER					.BS $1
;ABORT.COUNTER						.BS $1		;Tracks the number of iterations 
NPC.MOVE.COUNTER					.BS $1 ;***TEMP
DIRECTION.TEST.COUNTER				.BS $1		;incremented each time a direction, for a given tile, is tested for open paths. When this counter == $04 then all directions have been tested.



;TEMP FOR TESTING. REMOVE
;GAME_LOOP.ITERATION.COUNTER			.BS $1
;SCHEDULER.ITERATION.COUNTER			.BS $1

NPC.PATHFINDER.CLOSED_SET			.EQ $BB00	;$03C1 bytes (ends at $B3C0). tracks tiles which have been examined by pathfinder already
NPC.PATHFINDER.CLOSED_SET.POINTER	.EQ $EA		;2byt
CLOSED_SET.OFFSET					.BS $20		;number of bytes per row in the closet set array 
NEIGHBOR.ADJUSTED.X					.EQ MAP_OBJECTS.X_ADJ ;stores the x-axis of a prospective neighbor, adjusted to align with the closed_set array memory map. 
NEIGHBOR.ADJUSTED.Y					.EQ MAP_OBJECTS.Y_ADJ ;"" (y-axis)
CURRENT.TILE.ADJUSTED.X				.EQ NEIGHBOR.ADJUSTED.X
CURRENT.TILE.ADJUSTED.Y				.EQ NEIGHBOR.ADJUSTED.Y
CLOSED_SET.X.ADJ					.EQ $08		;#CONSTANT
CLOSED_SET.Y.ADJ					.EQ $07		;#CONSTANT


;corresponding !y-axis				00.01.02.03.04.05.06.07.08.09.10.11.12.13.14.15.16.17.18.19.20.21.22.23.24.25.26.27.28.29.30.31
CLOSED_SET.MULTIPLY_TABLE.LO	.HS 00.20.40.60.80.A0.C0.E0.00.20.40.60.80.A0.C0.E0.00.20.40.60.80.A0.C0.E0.00.20.40.60.80.A0.C0.E0
CLOSED_SET.MULTIPLY_TABLE.HO	.HS 00.00.00.00.00.00.00.00.01.01.01.01.01.01.01.01.02.02.02.02.02.02.02.02.03.03.03.03.03.03.03.03

;SORTING VARIABLES	
BUBBLE.SORT.LIST.SIZE				.BS $1
BUBBLE.SORT.LIST.POINTER			.EQ $EA
BUBBLE.SORT.LIST.EXCHANGE_FLAG 		.BS $1

;INDEX SORT

h_low           .HS 02.08.18.50.F2.D8.8A.A0.E2
h_high          .HS 00.00.00.00.00.00.08.19.4C


h_start_index   .BS $1
h_index         .BS $1
h               .BS $2
in_address      .BS $2
arr_start       .BS $2
arr_end         .BS $2
i               .BS $2
v               .BS $2
v_plus_1        .BS $2


J			.EQ $fa                   ; Uses two bytes. Has to be on zero-page
j_plus_h	.EQ $fc                   ; Uses two bytes. Has to be on zero-page
arr_length	.EQ j_plus_h              ; Can safely use the same location as
                                      ; j_plus_h, but doesn't have to be on ZP

									  
									  
;==============NPC.PATHGENERATOR===========
									  
NPC.PATHGENERATOR.SAVED_PATHS.AUX	.EQ $5C00	;#CONSTANT. Start address of the AUX memory reserved for saved NPC paths.						  
;SAVED.PATH.HO_ADDRESS.OFFSET	.BS $1		;the offset stored in this variable plus #SAVED.PATH.AUX_START equals the start memory address for the path for a specific NPC

NPC.PATHFINDER.FINAL.PATH.POINTER	.EQ NPC.PATHFINDER.SEARCH.PATHS.POINTER2
NPC.SCHEDULE.POINTER				.EQ $EA	

;SAVED.PATH.MAXIMUM: SAVED.PATH.LOOKUP.TABLE & NPC.PATHGENERATOR.SAVED_PATHS.AUX must have a large enough memory reservation to accomidate the number of paths specified by the constant #SAVED.PATH.MAXIMUM
SAVED.PATH.LOOKUP.TABLE				.EQ ZONE_TOOLS.OUTPUT_BUFFER ;$40byt. 
SAVED.PATH.LOOKUP.TABLE.SIZE		.EQ $40	;#CONSTANT. number of bytes in lookup table and NPC.PATHGENERATOR.SAVED_PATHS.AUX has memory for. 
SAVED.PATH.LOOKUP.TABLE.LAST_RECORD_START .EQ $3C ;#CONSTANT. # of bytes in Que - record size (6). (For a $40 byte array, the last record start is $3C, not $3D, because $0 is the first byte)
SAVED.PATH.LOOKUP.TABLE.INDEX		.EQ ZONE_TOOLS.OUTPUT_BUFFER+$7C	;$1byt. Stores the index to the last empty record found when iterating the array	
SAVED.PATH.MAXIMUM					.EQ $0F ;#CONSTANT. Max number of saved paths -1  that the lookup table and the
SAVED.PATH.COUNTER					.EQ ZONE_TOOLS.OUTPUT_BUFFER+$7D	;$1byt. Counts iterations of the SAVED.PATH array	
SAVED.PATH.NUMBER					.EQ ZONE_TOOLS.OUTPUT_BUFFER+$7E	;$1byt. Value updated from SAVED.PATH.COUNTER each time an empty record is found. Used to calculate the HO address offset when saving to aux memory
					

NPC.PATHGENERATOR.QUE				.EQ ZONE_TOOLS.OUTPUT_BUFFER+$40	;$32byt. Stores the anchor locations which will need paths soon
NPC.PATHGENERATOR.QUE.SIZE			.EQ $3C ;#CONSTANT.
NPC.PATHGENERATOR.QUE.LAST_RECORD_START	.EQ $36	;#CONSTANT. # of bytes in Que - record size (6). (For a $3C byte array, the last record start is $36, not $37, because $0 is the first byte)
PATHGENERATOR.QUE.INDEX				.EQ ZONE_TOOLS.OUTPUT_BUFFER+$7F	;$1byt. Stores the index to the last empty record found when iterating the array


PATHGENERATOR.LOOK_AHEAD.DAY_TRANSITION.HOUR	.EQ $19	;!BCD! #CONSTANT. This is the hour after which a special routine is needed to detrmine whether a scheduler record occurs before or after the current time. (i.e. if the look ahead period is 3 hours, and it is 23:00, then 01:00 is within the look ahead period even though 01 is less than 23. For this reason a special routine is required to evalute whether the scheduler entry is in the past or in the future) 	
PATHGENERATOR.LOOK_AHEAD.HOURS					.EQ $02	;!BCD! #CONSTANT. The number of hours +0, ahead which NPC.GENERATOR will generate paths for anchors in the scheduler arrray. If this value is changed PATHGENERATOR.LOOK_AHEAD.HOURS must be changed too. For example, if the time is 1:00am and the look ahead hours is set to 1, then any schedule entries with a time of 2:59am or sooner is within the lookahead period. Only hours are considered in the calculation (schedule entry hour - current hour), minutes are ignored. Note that the minimum value is $02, which means 1 hour, 59 minutes. 

NPC.MAXIMUM.ANCHORS					.EQ $A0	;#CONSTANT. Maximum number of NPCs anchor locations per building map.

;the following must have as much memory allocated as the value of NPC.MAXIMUM.ANCHORS 
;NPC.ANCHORS.X						.EQ ZONE_TOOLS.OUTPUT_BUFFER+$C0	;$A0 byts. Flows over into ZONE_TOOLS.INPUT_BUFFER. X-axis of all Anchor locations for the building the player is currently in, if any.
;NPC.ANCHORS.Y						.EQ ZONE_TOOLS.INPUT_BUFFER+$60		;$A0 byt. Y-axis of all Anchor locations for the building the player is currently in, if any.
NPC.ANCHORS.X						.BS NPC.MAXIMUM.ANCHORS	
NPC.ANCHORS.Y						.BS NPC.MAXIMUM.ANCHORS	



;======NPC TRANSIT & ANCHOR MOVEMENT=======
TRANSIT.NEXT_MOVE.INDEX				.EQ ZONE_TOOLS.OUTPUT_BUFFER+$80	;$1byt. the index to byte in the saved path which holds the next move for a particular NPC in transit to another anchor location			
TRANSIT.NEXT_MOVE.X					.EQ ZONE_TOOLS.OUTPUT_BUFFER+$81	;$1byt. the X-axis of the next move for an NPC in transit to another anchor location
TRANSIT.NEXT_MOVE.Y					.EQ ZONE_TOOLS.OUTPUT_BUFFER+$82	;$1byt. the X-axis of the next move for an NPC in transit to another anchor location

DESTINATION_REACHED_WHILE_SEEKING	.BS $1	;If an NPC is seeking due to a blocked path, and the seek tile is the destination tile of the path, this flag is used to indicate that. $01 = on, $00 = off. 


PLAYER.BLOCKED.NPC.COUNTER			.EQ ZONE_TOOLS.OUTPUT_BUFFER+$83	;$1byt. A tally of the number of times the player was in the path of an NPC. Resets after threshold is reached. Used in PLAYER.HARASSMENT.CHECK

;PLAYER.BLOCKED.NPC.THRESHOLD		.EQ $03	;#CONSTANT. Number of times a player must be in the path of an NPC before the NPC will react verbally. Used in PLAYER.HARASSMENT.CHECK	
PLAYER.BLOCKED.NPC.THRESHOLD		.EQ $03	;#CONSTANT. Number of times a player must be in the path of an NPC before the NPC will react verbally. Used in PLAYER.HARASSMENT.CHECK	
NPC.ASSIGNED_PATHS 					.EQ MOB.MOVE.OPEN_PATHS	;stores the paths that have already been assigned as primary move options in PRIORITIZE.NPC.PATHS

NPC.ACTIVE.ANCHOR.X					.EQ ZONE_TOOLS.OUTPUT_BUFFER+$84	;$1byt. Used anytime the X,Y of an NPC's active anchor need to be saved temporarily, such as in FLOCKING_POINT.CHECK
NPC.ACTIVE.ANCHOR.Y					.EQ ZONE_TOOLS.OUTPUT_BUFFER+$85	;$1byt. Used anytime the X,Y of an NPC's active anchor need to be saved temporarily, such as in FLOCKING_POINT.CHECK


DISTANCE.NORTH.OF_FLOCKING_POINT	.EQ MAP_OBJECTS.Y_ADJ	;$1byt.	
DISTANCE.SOUTH.OF_FLOCKING_POINT	.EQ MOB.POSITION.Y_GR	;$1byt.
DISTANCE.EAST.OF_FLOCKING_POINT		.EQ MAP_OBJECTS.X_ADJ	;$1byt.
DISTANCE.WEST.OF_FLOCKING_POINT		.EQ MOB.POSITION.X_GR	;$1byt.

; DISTANCE.NORTH.OF_FLOCKING_POINT	.BS $1	;$1byt.	
; DISTANCE.SOUTH.OF_FLOCKING_POINT	.BS $1	;$1byt.
; DISTANCE.EAST.OF_FLOCKING_POINT		.BS $1	;$1byt.
; DISTANCE.WEST.OF_FLOCKING_POINT		.BS $1	;$1byt.

NPC.SPECIAL_FLAG01.FORCED_PASS		.EQ $80	;#CONSTANT. 50% pass. An in-transit NPC will pass if random # is less than this value. 
NPC.SPECIAL_FLAG02.FORCED_PASS		.EQ $AA	;#CONSTANT. 66% pass. An in-transit NPC will pass if random # is less than this value. 
PASS.PROBABILITY					.EQ ZONE_TOOLS.OUTPUT_BUFFER+$86	;$1byt.

;****DELETE THIS***
;TEMP.ARRAY							.EQ $A500
	

NPC.FLOCKING_POINT.RADIUS			.EQ ZONE_TOOLS.OUTPUT_BUFFER+$87	;1byte. Stores # of moves NPC is permitted to travel from flocking point in any direction.
NPC.FLOCKING_POINT.RADIUS1			.EQ $01	;#CONSTANT. Sets the radius to $01 tiles. 	
NPC.FLOCKING_POINT.RADIUS2			.EQ $02	;#CONSTANT. Sets the radius to $02 tiles. 	
NPC.FLOCKING_POINT.RADIUS3			.EQ $03	;#CONSTANT. Sets the radius to $03 tiles. 	
NPC.FLOCKING_POINT.RADIUS4			.EQ $04	;#CONSTANT. Sets the radius to $04 tiles. 	

;==============NPC.INIT===========	

MAXIMUM.NPCS.PER.BUILDING	.EQ $20 ;#CONSTANT. The maximum number of NPCs which can exist in on a building map and thus the max NPC records in a talk data file.
NPC.RECORD.SIZE				.EQ $08 ;#CONSTANT. number of bytes in NPC map object record
MAXIMUM.NPC.RECORD_NUMBER	.EQ MAXIMUM.NPCS.PER.BUILDING-1*NPC.RECORD.SIZE ;#CONSTANT. (currently should be $F8) The highest value that an NPC record # can be, which is equal to the maxium number of (NPCs per building-1) * the NPC record size. The -1 is because the max # of NPCs is a quantity and the first NPC record # starts with $00.


NPC.SCHEDULE.WORKSPACE				.EQ ZONE_TOOLS.INPUT_BUFFER ;$C0 bytes. A temporary table created when figuring out which scheduler record to use for the NPCs init values. 	
NPC.SCHEDULE.WORKSPACE.SIZE			.EQ $FF

;NPC.INIT.ITERATION_COUNTER	.EQ SAVED.ACC.LOCAL ;used by NPC.INIT.NPC_RECORDS to detect if the iteration is after the first in order to detect X-REG = flipped to $00 as the exit value. This requires an interation counter because the X-REG increment is at the top of the loop.

;===========ADHOC PATHFINDER======
NPC.PATHFINDER.ADOC.FLAG			.BS $01	;1byte. $FF = on, $00 = off. Used to let NPC.PATHFINDER subroutine know that it is being used for an adhoc generated path rather than for NPC scheduled paths

	
@END

;========NPC TALK=====
@START


NPC.TALK.RECORD				.EQ ZONE_TOOLS.INPUT_BUFFER+$0	;1byt. Holds the map objects array record index for the NPC which the player is talking to
NPC.TALK.RECORD.INDEX		.EQ ZONE_TOOLS.INPUT_BUFFER+$1	;2byt. Holds the HO/LO byte index to the start of the current NPC record in the NPC.TALK.ARRAY
NPC.TALK.SCREEN_LOCATION	.EQ ZONE_TOOLS.INPUT_BUFFER+$3 ;$1byts. The screen tile location of the NPC the player is talking to. 

NPC.TALK.TEXT.INDEX		.EQ $D0	;Index to a block of text which NPC.TALK requests for display on the video screen. 	

NPC.TALK.ARRAY			.EQ SRTN.NPC.TALK.ADDRESS-$C00	;#CONSTANT. memory address where unpacked data is loaded for NPC player is talking to.  As long as NPC.TALK (SRTN.NPC.TALK.ADDRESS) is loaded to $AC00, then this constant points to $A000.
NPC.TALK.ARRAY.SIZE		.EQ $900						;#CONSTANT.
NPC.TALK.ARRAY.END		.EQ SRTN.NPC.TALK.ADDRESS-$301	;#CONSTANT. memory address where unpacked data end. As long as NPC.TALK (SRTN.NPC.TALK.ADDRESS) is loaded to $AD00, then this constant points to $A8FF.
NPC.TEXT.BLOCK.STOP_VALUE .EQ $00 ;#CONSTANT. This is the stop value added to ASCII tables by the SBASM cross assembler, which is used to create all NPC talk data files. 

NPC.TALK.ARRAY.PACKED	.EQ SRTN.NPC.TALK.ADDRESS+$E00	;#CONSTANT. memory address where packed data is loaded for NPC player is talking to. As long as NPC.TALK (SRTN.NPC.TALK.ADDRESS) is loaded to $AC00, then this constant points to $B900.
NPC.TALK.ARRAY.PACKED.SIZE .EQ $500 ;#CONSTANT.
NPC.TALK.ARRAY.PACKED.END .EQ SRTN.NPC.TALK.ADDRESS+$12FF	;#CONSTANT. memory address where unpacked data end. As long as NPC.TALK (SRTN.NPC.TALK.ADDRESS) is loaded to $AC00, then this constant points to $BEFF.


NPC.TALK.KEYWORD		.EQ ZONE_TOOLS.INPUT_BUFFER+$4  ;$20byts. Holds the string input from player when talking to an NPC
NPC.TALK.KEYWORD.COPY	.EQ ZONE_TOOLS.INPUT_BUFFER+$24 ;$20byts. Holds a copy of NPC.TALK.KEYWORD
NPC.TALK.KEYWORD.STOP_VALUE	.EQ $00 ;#CONSTANT.

CURSOR.POSITION.SAVED	.EQ ZONE_TOOLS.INPUT_BUFFER+$44 ;$2byts. Holds saved cursor position when flipping between the NPC.TALK.INPUT subroutine (get player's question) and the PRINT.TEXT.WINDOW subroutine to output NPC text to the screen

;NTALK PROGRAMMING LANGUAGE
NTALK.COMMAND.START_CODE		.EQ $A4 ;#CONSTANT. The ASCII value used to indicate the start of an NTALK command
NTALK.COMMAND.FIND_RECORD		.EQ $D2 ;#CONSTANT. The ASCII value used to indicate the command to find an NPC Record value. 
NTALK.COMMAND.FIND_INTRO		.EQ $C9 ;#CONSTANT. The ASCII value used to indicate the command to find the introduction text block
NTALK.COMMAND.FIND_KEYWORD		.EQ $A1 ;#CONSTANT. The ASCII value used to indicate the command to find the specified keyword 
NTALK.COMMAND.END_CODE			.EQ $AE ;#CONSTANT. The ASCII value used to indicate the end of an NTALK command
NTALK.COMMAND.SUBCOMMAND_CODE 	.EQ $BA ;#CONSTANT. The ASCII value used to indicate the end of an NTALK command
NTALK.SUB_COMMAND.EVENT_CONT_CODE	.EQ $C5 ;#CONSTANT. The ASCII value used to indicate the contingent event subcommand, which makes the current command only available based on the value of the event flag # specified in the next byte. The subsequent byte contains the on/off status of the flag required for the command to be eligible. 
NTALK.SUB_COMMAND.EVENT_PUSH_CODE	.EQ $D0 ;#CONSTANT. The ASCII value used to indicate the push event subcommand, which sets the value of the specified event flag (in the next byte) after the current command is executed. The subsequent byte contains the on/off status of the flag that will be pushed 
NTALK.SUB_COMMAND.YELL_CODE		.EQ $D9 ;#CONSTANT. The ASCII value used to indicate the yell subcommand, which makes the current command contingent on the player being in yell mode. 
NTALK.SUB_COMMAND.WHISPER_CODE	.EQ $D7 ;#CONSTANT. The ASCII value used to indicate the whisper subcommand, which makes the current command contingent on the player being in whisper mode. 
NTALK.SUB_COMMAND.NORMAL_CODE	.EQ $CE ;#CONSTANT. The ASCII value used to indicate the normal subcommand, which makes the current command contingent on the player being in normal mode. 
NTALK.SUB_COMMAND.ADULT_CODE	.EQ $C1 ;#CONSTANT. The ASCII value used to indicate the adult_mode subcommand, which makes the current command contingent on the adult game mode being active. 
NTALK.SUB_COMMAND.NPC_TERM_CODE .EQ $D4 ;#CONSTANT. The ASCII value used to indicate the NPC has a % chance of terminating the conversation, and telling the player to stick it. Or something like that. 
NTALK.SUB_COMMAND.HOUR_CONT_CODE .EQ $C8 ;#CONSTANT. The ASCII value used to indicate the text block is contingent on the hour of the day. 
NTALK.SUB_COMMAND.KEYWORD_INSERT_CODE	.EQ $CB ;#CONSTANT. The ASCII value used to indicate the insert keyword subcommand, which inserts the player input keyword into the text block at the location of the subcommand.  

;NTALK.SEARCH
NTALK.VOICE_MODE			.EQ ZONE_TOOLS.INPUT_BUFFER+$46 ;$1byts. current voice mode when talking to NPCs ($00 = normal, $01 = yell, $02 = whisper)	
NTALK.VOICE_MODE.MAX		.EQ $03 ;#CONSTANT. The quant0ity of voice modes. 
NTALK.VOICE.NORMAL			.EQ $00	;#CONSTANT. The voice mode value when normal mode is enabled
NTALK.VOICE.YELL			.EQ $01	;#CONSTANT. The voice mode value when yell mode is enabled
NTALK.VOICE.WHISPER			.EQ $02	;#CONSTANT. The voice mode value when whisper mode is enabled

NTALK.SEARCH.MODE		.EQ ZONE_TOOLS.INPUT_BUFFER+$47 ;$1byts. $00 = find record, $01 = find intro text, $02 = find keyword 
NTALK.FLAG.BYE				.EQ ZONE_TOOLS.INPUT_BUFFER+$48 ;$1byts. Set to $01 if the player's input to NPC.TALK.INPUT was "BYE", otherwise defaults to #$00.			

NTALK.TEXT_BLOCK.START		.EQ ZONE_TOOLS.INPUT_BUFFER+$49 ;2bytes. Stores a pointer to the start of the text block. Current only used for the keyword insert subcommand. 
NTALK.MODIFIED.TEXT_BLOCK	.EQ NPC.TALK.ARRAY.PACKED	;#CONSTANT. When a text block in a talk data file is modified, this address where the modified text is stored. 
NPC.TALK.KEYWORD.ORIGINAL			.EQ ZONE_TOOLS.INPUT_BUFFER+$4B ;$20byts. Holds a copy of NPC.TALK.KEYWORD, which is preserved as the original for the duration of NPC.SEARCH. 

NPC.TALK.FILE.RECORD_ID				.EQ ZONE_TOOLS.INPUT_BUFFER+$6B ;$1byts. NPC ID of the first packed data record 
NPC.TALK.FILE.PACKED_RECORD_LENGTH	.EQ ZONE_TOOLS.INPUT_BUFFER+$6C ;$2byts. Length (2 bytes) of the packed data in the record
NPC.TALK.FILE.RECORD_COUNTER		.EQ ZONE_TOOLS.INPUT_BUFFER+$6E ;$1byts. this counter is incremented each time a record is read in from the curret NPC Talk data file.

;NTALK.ARRAY.SEARCH
NTALK.SEARCH.MATCH_QTY	.EQ ZONE_TOOLS.INPUT_BUFFER+$6F ;$1byts. Number of characters that must be the same for a match to be found. For exampe, if this variable is set to 4 then if the first 4 characters of the keyword are found then the entire keyword is considered to be found. The number of characters must include the NTALK keyword subcommand code of "$!"
NTALK.KEYWORD.POINTER	.EQ $D2 ;a pointer to the keyword which is being search for within an array.
NTALK.ARRAY.POINTER		.EQ ZONE_TOOLS.INPUT_BUFFER+$70 ;$2byts. Parameter to NPC.ARRAY.SEARCH, containing the address of the array to be searched, usually NPC.TALK.ARRAY
NTALK.ARRAY.POINTER.RETURN	 .EQ $E2 ;pointer to the array being searched for a keyword. Usually points to NPC.TALK.ARRAY. It is also a return value, returing the updated pointer position, pointing to the next byte after first character after the end of the keyword. 

NTALK.ARRAY.POINTER.RETURN.HO.SAVED .EQ ZONE_TOOLS.INPUT_BUFFER+$72 ;$1byt
NTALK.ARRAY.POINTER.RETURN.LO.SAVED .EQ ZONE_TOOLS.INPUT_BUFFER+$73 ;$1byt
NTALK.ARRAY.STOP.VALUE	.EQ ZONE_TOOLS.INPUT_BUFFER+$74 ;$1byts. $00 = find record, $01 = find intro text, $03 = find keyword 

NTALK.KEYWORD.STOP_VALUE			.EQ ZONE_TOOLS.INPUT_BUFFER+$75 ;$1byts. Stores parameter for the stop value of the keyword string
NTALK.KEYWORD.BUFFER				.EQ ZONE_TOOLS.INPUT_BUFFER+$76 ;$20byts. Holds a copy of NPC.TALK.KEYWORD or whichever keyword is provided to NPC.ARRAY.SEARCH via the keyword pointer. The pointer keyword array is copied into this buffer so X-REG can be used as the index. 
NTALK.KEYWORD.1ST_CHAR.UCASE		.EQ ZONE_TOOLS.INPUT_BUFFER+$96 ;$1byts. 
NTALK.KEYWORD.POINTER.UPDATED		.EQ ZONE_TOOLS.INPUT_BUFFER+$97 ;$2byts. NPC.SEARCH.ARRAY returns the final value of the keyword pointer via this variable. It is equal to the byte after the keyword array's stop value.  

NTALK.END.OF.FILE		.EQ $FF ;#CONSTANT. Indicates the end of the NPC.TALK.ARRAY has been reached.
NTALK.END.OF.RECORD		.EQ $FC ;#CONSTANT. Indicates the end of a record in the NPC.TALK.ARRAY has been reached.

NTALK.KEYWORD.UCASE			.EQ ZONE_TOOLS.INPUT_BUFFER+$99 ;$1byts. Holds the uppercase value (for letters) of the next keyword character during the search loop. 
NTALK.ARRAY.UCASE			.EQ ZONE_TOOLS.INPUT_BUFFER+$9A ;$1byts. Holds the uppercase value (for letters) of the next search array character during the search loop.

;NTALK.SEARCH.LOOP
NTALK.SEARCH.RETURN.SUB_COMMAND.FLAGS .EQ ZONE_TOOLS.INPUT_BUFFER+$9B ;$20byts.
SUB_COMMAND.FLAGS.STOP_VALUE	.EQ	$20	;#CONSTANT. Should be equal to the # of bytes of NTALK.SEARCH.RETURN.SUB_COMMAND.FLAGS 
NTALK.COMMAND_FOUND.INDEX	.EQ ZONE_TOOLS.INPUT_BUFFER+$BB ;$2byts. Index to the last character of the primary command (+$1) last searched for in the NPC TALK array. Used as the starting element to search for subcommands. So if the command searched for was $R, the index would point to the character after the R
NTALK.FLAG.INTERNAL_SEARCH	.EQ ZONE_TOOLS.INPUT_BUFFER+$BD ;$1byts. This flag is on when internal searches, such as for the command end code, are being done. This flag is used to override the minimum characters required for a match as specified by NTALK.SEARCH.MATCH_QTY

;NTALK.PARSE.KEYWORD
NTALK.CURSE_WORD.COUNTER			.EQ ZONE_TOOLS.INPUT_BUFFER+$BE ;$1byts
NTALK.TOTAL.CURSE_WORDS				.EQ $08		


; ;***RESERVED** ZONE_TOOLS.INPUT_BUFFER+$F2 - $FF (PRODOS.IO)

@END

;======PLAYER MOVEMENT======
@START

PLAYER.MOVE.CURRENT 			.BS	$1					;CONTAINS THE DIRECTION OF PLAYERS REQUESTED MOVE, AFTER #COLLISION CHECKS. 
PLAYER.MOVE.CANDIDATE_TILE_LOC 	.EQ	SHAPE.HOPPER1		;CONTAINS THE TILE IN THE DESTINATION OF THE PLAYERS REQUESTED MOVE, BEFORE #COLLISION CHECKS. (1 TILE AWAY FROM PLAYER)
PLAYER.MOVE.CANDIDATE_TILE_LOC2	.EQ SHAPE.HOPPER1+$1	;CONTAINS THE TILE IN THE DESTINATION OF THE PLAYERS REQUESTED MOVE, BEFORE #COLLISION CHECKS. (2 TILES AWAY FROM PLAYER)
PLAYER.MOVE.JUMP				.BS $1					;CONTAINS $01 IF THE PLAYER EXECUTES A JUMP COMMAND WHILE ON A HORSE
PLAYER.MOVE.COUNTER				.BS $1					;TRACKS WHETHER PLAYER MOVE 1 OR 2 IS BEING PROCESSED WHEN FAST HORSE IS ACTIVE. NEEDED WHEN (J)UMP COMMAND IS USED, WHICH TEMPORARILY ENABLES FAST HORSE. 
PLAYER.MOVE.FORCED				.BS $1					;$01 == FORCED. USED WHEN MOVE.N/S/E/W ARE CALLED IN SITUATIONS OTHER THNA A PLAYER KEYPRESS TRIGGER (I.E. TO USE THEM TO MOVE PLAYERS LOCATION AUTOMATICALLY FOR SOME REASON, SUCH AS WHEN AN FRIGATE (MT OBJECT) IS BOARDED AND THE SHIP ISN'T CENTERED ON THE SCREEN. 
PLAYER.TILE.LAST				.BS $1					;THE TILE TYPE THE PLAYER WAS STANDING ON AT THE END OF THE LAST MOVE

;PLAYER #COLLISION RULES  --WALKING
COLLISION_FLAG.WALKING.LT1		.EQ	$0B		;#CONSTANT
COLLISION_FLAG.WALKING.GRE2		.EQ	$80		;#CONSTANT
COLLISION_FLAG.WALKING.LT2		.EQ	$8C		;#CONSTANT
COLLISION_FLAG.WALKING.GRE3		.EQ	$80		;#CONSTANT
COLLISION_FLAG.WALKING.LT3		.EQ	$88		;#CONSTANT

;PLAYER #COLLISION RULES  --CARAVEL--
COLLISION_FLAG.CARAVEL.LT		.EQ $8A		;#CONSTANT


;PLAYER #COLLISION RULES  --FRIGATE--
COLLISION_FLAG.FRIGATE.LT		.EQ $8B		;#CONSTANT


;PLAYER #COLLISION RULES  --SKIFF--
COLLISION_FLAG.SKIFF.LT			.EQ $63		;#CONSTANT	
COLLISION_FLAG.SKIFF.EQ1		.EQ $7C		;#CONSTANT
COLLISION_FLAG.SKIFF.EQ2		.EQ $8B		;#CONSTANT

;PLAYER #COLLISION RULES  --HORSE--
COLLISION_FLAG.HORSE.LT1		.EQ $0B		;#CONSTANT
COLLISION_FLAG.HORSE.GRE		.EQ $80		;#CONSTANT
COLLISION_FLAG.HORSE.LT2		.EQ $8B		;#CONSTANT
COLLISION_FLAG.HORSE.EQ1		.EQ $46		;#CONSTANT

;PLAYER #COLLISION RULES  --WYVERN--
COLLISION_FLAG.WYVERN.LT1		.EQ	$0B		;#CONSTANT
COLLISION_FLAG.WYVERN.GRE		.EQ	$80		;#CONSTANT
COLLISION_FLAG.WYVERN.LT2		.EQ	$8C		;#CONSTANT
@END

;======PLAYER VARIABLES======
@START

;GAME SETTINGS

GAME.ADULT.MODE		.BS $1	;$00 = OFF, $01 = ON

;ICON RELATED
PLAYER.HEIGHT.DEFAULT				.EQ $10			;#CONSTANT. INTENTIONALLY SET TO TILE HEIGHT+$3. THIS IT THE HEIGHT SET AT GAME LAUNCH AND AFTER PLAYER RETURNS TO A REGULAR TILE AFTER STEPPING ON A SINKING TILE LIKE QUICKSAND
PLAYER.HEIGHT						.BS $1			;HEIGHT IN LINES. USED TO CONTROL SPECIAL EFFECTS LIKE SINKING IN SHALLOW WATER
PLAYER.WALKING.TILE					.BS	$1			;STORE THE TILE ID OF THE PLAYER ICON WHEN NO TRANSPORT IS ACTIVE
PLAYER.WALKING.TILE.DEFAULT			.BS $1			;STORES THE DEFAULT TILE ID FOR THE PLAYER ICON IN CASE IT GETS CHANGED TEMPORARILY
PLAYER.ICON.BUFFER					.BS $20			;STORES THE CURRENT WALKING PLAYER ICON. KEEPS TRACK OF CHANGES TO IT SUCH AS WHEN THE PLAYER SINKS IN WATER.


;TRANSPORT RELATED
PLAYER.TILE.ACTIVE					.BS $1			;THE TILE TYPE OF THE TRANSPORT RECORD POINTED TO BY THE INDEX STORED IN PLAYER.TRANSPORT.ACTIVE
PLAYER.TRANSPORT.ACTIVE				.BS $1			;TRACKS AN INDEX TO THE TRANSPORT OBJECT BOARDED. IF SET TO $FF, PLAYER IS WALKING AND PLAYER.MAP.ICON IS USED TO DETERMINE TILE_TYPE FOR PLAYER ICON. 
PLAYER.TRANSPORT.SPEED				.BS $1			;THE NUMBER OF MOVES THE PLAYER GETS FOR EVERY ONE MOB MOVE. $00 = 1 MOVE. > $00 = 2 MOVES
PLAYER.TRANSPORT.STATUS				.BS $1			;$00 = NOT SET, $02 = FAST HORSE, $04 = WYVERN  (THIS VARIABLE EXISTS SO THAT PLAYER.TRANSPORT.SPEED CAN BE USED BY OTHER COMMANDS (LIKE JUMP) WITHOUT LOOSING KNOWLEDGE OF TRANSPORT STATUS (I.E. FAST HORSE ENABLED) WHEN THE OTHER COMMAND WAS ISSUED)
PLAYER.TRANSPORT.FRIGATE.SKIFF_MAX	.EQ $02			;#CONSTANT. THE MAXIMUM NUMBER OF SKIFFS A FRIGATE CAN HOLD
PLAYER.TRANSPORT.MT.TILE_LOCATIONS	.BS $4			;STORES THE SCREEN LOCATIONS OF ANY ACTIVE MULTI TILE TRANSPORT. THE LOCATIONS VERY BASED ON WHICH TILE OF THE MO THE PLAYER BOARDS. 

PLAYER.TRANSPORT.MT.TILE_LOCATION0	.EQ	$5D			;#CONSTANT. THE SCREEN ARRAY LOCATIONS OF THE PLAYER WHEN MULTI-TILE TRANSPORT IS ACTIVE 
PLAYER.TRANSPORT.MT.TILE_LOCATION1	.EQ	$5E			;#CONSTANT. THE SCREEN ARRAY LOCATIONS OF THE PLAYER WHEN MULTI-TILE TRANSPORT IS ACTIVE 
PLAYER.TRANSPORT.MT.TILE_LOCATION2	.EQ	$6E			;#CONSTANT. THE SCREEN ARRAY LOCATIONS OF THE PLAYER WHEN MULTI-TILE TRANSPORT IS ACTIVE 
PLAYER.TRANSPORT.MT.TILE_LOCATION3	.EQ	$6F			;#CONSTANT. THE SCREEN ARRAY LOCATIONS OF THE PLAYER WHEN MULTI-TILE TRANSPORT IS ACTIVE 



;#PLAYER.MT.ADJACENT_TILES are constants that refer to the tile locations adjacent to a
;Frigate (multi-tile transport) when it is the active transport for the player. 
;
;The constants map to the screen array as follows, where 0-3 are the tiles #s of the multi-tile shape
; NN
;W01E
;W23E
; SS
;
;0-3 correspond to the screen array locations in the PLAYER.TRANSPORT.MT.TILE_LOCATION(0-3) set of constants


PLAYER.MT.ADJACENT_TILES.NORTH0	.EQ $4C				;#CONSTANT. THE SCREEN ARRAY LOCATIONS OF THE TILE ADJACENT TO THE PLAYER WHEN MULTI-TILE TRANSPORT IS ACTIVE 
PLAYER.MT.ADJACENT_TILES.NORTH1	.EQ $4D				;#CONSTANT. THE SCREEN ARRAY LOCATIONS OF THE TILE ADJACENT TO THE PLAYER WHEN MULTI-TILE TRANSPORT IS ACTIVE 
PLAYER.MT.ADJACENT_TILES.SOUTH0	.EQ $7F				;#CONSTANT. THE SCREEN ARRAY LOCATIONS OF THE TILE ADJACENT TO THE PLAYER WHEN MULTI-TILE TRANSPORT IS ACTIVE 
PLAYER.MT.ADJACENT_TILES.SOUTH1	.EQ $80				;#CONSTANT. THE SCREEN ARRAY LOCATIONS OF THE TILE ADJACENT TO THE PLAYER WHEN MULTI-TILE TRANSPORT IS ACTIVE 
PLAYER.MT.ADJACENT_TILES.EAST0	.EQ $5F				;#CONSTANT. THE SCREEN ARRAY LOCATIONS OF THE TILE ADJACENT TO THE PLAYER WHEN MULTI-TILE TRANSPORT IS ACTIVE 
PLAYER.MT.ADJACENT_TILES.EAST1	.EQ $70				;#CONSTANT. THE SCREEN ARRAY LOCATIONS OF THE TILE ADJACENT TO THE PLAYER WHEN MULTI-TILE TRANSPORT IS ACTIVE 
PLAYER.MT.ADJACENT_TILES.WEST0	.EQ $5C				;#CONSTANT. THE SCREEN ARRAY LOCATIONS OF THE TILE ADJACENT TO THE PLAYER WHEN MULTI-TILE TRANSPORT IS ACTIVE 
PLAYER.MT.ADJACENT_TILES.WEST1	.EQ $6D				;#CONSTANT. THE SCREEN ARRAY LOCATIONS OF THE TILE ADJACENT TO THE PLAYER WHEN MULTI-TILE TRANSPORT IS ACTIVE 


;MAP RELATED		
PLAYER.MAP.ICON				.BS $1		;HOLDS THE TILE_TYPE OF THE PLAYERS WALKING ICON (NOT BOARDED TRANSPORT)
;PLAYER.COLLISSION_OVERRIDE	.BS $1		;$00 = OFF, $01 = ON
PLAYER.COLLISSION_OVERRIDE	.BS $1		;$00 = OFF, $01 = ON
PLAYER.DARKNESS_OVERRIDE	.BS $1		;$00 = OFF, >=$01 = ON	
PLAYER.PLS_STATUS			.BS $1		;PLAYER LIGHT SOURCE. $00 = OFF, $01 = TORCH

PLAYER.MAP.X				.BS $1		;STORES PLAYER'S MAP X-AXIS (DIFFERENT THAN THE X,Y USED FOR TRACKING MOB LOCATIONS)
PLAYER.MAP.Y				.BS $1		;STORES PLAYER'S MAP X-AXIS (DIFFERENT THAN THE X,Y USED FOR TRACKING MOB LOCATIONS)
;PLAYER.MAP.X				.EQ $9104	;STORES PLAYER'S MAP X-AXIS (DIFFERENT THAN THE X,Y USED FOR TRACKING MOB LOCATIONS)
;PLAYER.MAP.Y				.EQ $9105	;STORES PLAYER'S MAP X-AXIS (DIFFERENT THAN THE X,Y USED FOR TRACKING MOB LOCATIONS)
PLAYER.COMMAND.LAST			.BS $1		;STORES THE UPPER CASE ASCII VALUE OF THE LAST VALID COMMAND ISSUED BY THE PLAYER. THIS VALUE IS SET AT THE END OF THE SUBROUTINE FOR THE ASSOCIATED COMMAND. 
PLAYER.COMMAND.CURRENT		.BS $1
;PLS CONSTANTS
;see DARKNESS section

@END

;========SCREEN OPERATIONS======
@START

SCREEN.COLUMN.STOP	.BS $1						;STORES THE STOP VALUE WHEN LOADING A COLUMN OF TILES (TILE.LOOKUP.COLUMN)
SCREEN.ARRAY.INDEX 			.EQ SHAPE.HOPPER1+$0	
RZONE.ARRAY.COLUMN.INDEX 	.EQ SHAPE.HOPPER1+$1

RMAP.LOOKUP					.BS $2						;USED TO STORE AN RMAP VALUE FOR PURPOSES OF LOOKING UP A TILE TYPE USING TILE.LOOKUP.SINGLE OR THE IN-LINE CODE EQUIVILENT
	
@END

;======SWAP SPACE=======
;See beginning of this file

;============TEXT WINDOWS & SCREEN BORDERS================
@START

;SCREEN BORDER
SCREEN_BORDER.TOP_LINE		.EQ $04	;#CONSTANT
SCREEN_BORDER.BOTTOM_LINE	.EQ $BC	;#CONSTANT
SCREEN_BORDER.LR_SBYTE		.EQ $27	;#CONSTANT. Lower right screen byte



;TEXT WINDOW: RIGHT (NPC TALK)

;border dimensions
TWB.RIGHT_WINDOW.TOP_LINE		.EQ $04	;#CONSTANT.
TWB.RIGHT_WINDOW.BOTTOM_LINE	.EQ $BC	;#CONSTANT.
TWB.RIGHT_WINDOW.LEFT_SBYTE		.EQ $18	;#CONSTANT. left edge screen byte
TWB.RIGHT_WINDOW.RIGHT_SBYTE	.EQ $27 ;#CONSTANT. right edge screen byte
TWB.RIGHT_WINDOW.WIDTH			.EQ $08 ;#CONSTANT. of tiles in NPC Talk Text Window
TWB.RIGHT_WINDOW.LEFT_TILE_COLUMN	.EQ $0B ;#CONSTANT. the screen tile column number of the left side of the text window

;text space dimensions (hi-res)
TWS.RIGHT_WINDOW.TOP_LINE		.EQ $05	;#CONSTANT
TWS.RIGHT_WINDOW.BOTTOM_LINE	.EQ $BB	;#CONSTANT
TWS.RIGHT_WINDOW.LEFT_SBYTE		.EQ $19	;#CONSTANT. left edge screen byte
TWS.RIGHT_WINDOW.RIGHT_SBYTE	.EQ $26 ;#CONSTANT. right edge screen byte
TWS.RIGHT_WINDOW.WIDTH			.EQ $07 ;# of tiles in NPC Talk Text Window

;TEXT WINDOW: INPUT (NPC TALK)
;border dimensions
TWB.TALK_INPUT_WINDOW.TOP_LINE		.EQ $93	;#CONSTANT.
TWB.TALK_INPUT_WINDOW.LEFT_SBYTE	.EQ $18	;#CONSTANT. left edge screen byte
TWB.TALK_INPUT_WINDOW.RIGHT_SBYTE	.EQ $27 ;#CONSTANT. right edge screen byte

;text space dimensions (hi-res)
TWS.TALK_INPUT_WINDOW.TOP_LINE		.EQ $97	;#CONSTANT
TWS.TALK_INPUT_WINDOW.BOTTOM_LINE	.EQ $A3	;#CONSTANT
TWS.TALK_INPUT_WINDOW.LEFT_SBYTE	.EQ $1A	;#CONSTANT. left edge of top line, it's shorter than width of window.
TWS.TALK_INPUT_WINDOW.RIGHT_SBYTE	.EQ $26 ;#CONSTANT. right edge screen byte, it's shorter than width of window.

;setup
TWS.TALK_INPUT_WINDOW.PROMPT_START.HTAB	.EQ $19	;#CONSTANT. The VTAB of the cursor after the window is reset, before any input is received. 
TWS.TALK_INPUT_WINDOW.PROMPT_START.VTAB	.EQ $13	;#CONSTANT. The HTAB of the cursor after the window is reset, before any input is received. 

TWS.TALK_INPUT_WINDOW.CURSOR_START.HTAB	.EQ $1A	;#CONSTANT. The HTAB of the cursor after the window is reset, before any input is received. 
TWS.TALK_INPUT_WINDOW.CURSOR_START.VTAB	.EQ $13	;#CONSTANT. The VTAB of the cursor after the window is reset, before any input is received. 

		
TW.RIGHT_WINDOW.CLEAN_UP.FLAG	.BS	$01	;controls whether DRAW.SCREEN will erase the right edge and first two bytes of the top/bottom lines of the text window border. 
TW.RIGHT_WINDOW.STATUS.FLAG		.EQ TW.RIGHT_WINDOW.CLEAN_UP.FLAG  ;$00 = not active, $01 = active

SCREEN_BYTE.COUNTER		.EQ ZONE_TOOLS.INPUT_BUFFER+$80 ;$1byt
USE.PAGE			 	.EQ ZONE_TOOLS.INPUT_BUFFER+$81 ;$1byt
LINE.COUTNER 			.EQ SCREEN_BYTE.COUNTER


;TEXT WINDOW HI-RES DIMENSIONS: TOP
TWB.TOP_WINDOW.TOP_LINE		.EQ $00 ;#CONSTANT
TWB.TOP_WINDOW.BOTTOM_LINE	.EQ $07 ;#CONSTANT
TWB.TOP_WINDOW.LEFT_SBYTE	.EQ $00 ;#CONSTANT. Lower right screen byte
TWB.TOP_WINDOW.RIGHT_SBYTE	.EQ $27 ;#CONSTANT. Lower right screen byte

;TEXT WINDOW HI-RES DIMENSIONS: BOTTOM
TWB.BOTTOM_WINDOW.TOP_LINE		.EQ $B8 ;#CONSTANT
TWB.BOTTOM_WINDOW.BOTTOM_LINE	.EQ $BF ;#CONSTANT
TWB.BOTTOM_WINDOW.LEFT_SBYTE	.EQ $00 ;#CONSTANT. Lower right screen byte
TWB.BOTTOM_WINDOW.RIGHT_SBYTE	.EQ $27 ;#CONSTANT. Lower right screen byte

;TEXT WINDOW HI-RES DIMENSIONS: RIGHT-SMALL (GENERAL SCREEN)
TWB.RIGHT_S_WINDOW.TOP_LINE		.EQ $00 ;#CONSTANT
TWB.RIGHT_S_WINDOW.BOTTOM_LINE	.EQ $C0 ;#CONSTANT
TWB.RIGHT_S_WINDOW.LEFT_SBYTE	.EQ $24 ;#CONSTANT. Lower right screen byte
TWB.RIGHT_S_WINDOW.RIGHT_SBYTE	.EQ $27 ;#CONSTANT. Lower right screen byte
@END


;==TEXT WINDOW FUNCTION==
@START
;dimensions
TWF.LEFT_SBYTE			.EQ $F0	;1byt
TWF.WIDTH				.EQ $F1	;1byt
TWF.RIGHT_SBYTE			.EQ $F2	;1byt. Right screen byte of text space +$1 (which means it is equal to the screen byte of the right edge border of the window)
TWF.TOP_ROW				.EQ $F3	;1byt
TWF.BOTTOM_ROW			.EQ $F4	;1byt


;printing characters
TWF.STRING				.EQ $E4	;2byt. zero page pointer for the input string
TWF.STRING.STOP.VALUE	.EQ	$00	;#CONSTANT


TEXT.WINDOW.BUFFER		.EQ	ZONE_TOOLS.INPUT_BUFFER+$82 ;$40byt
TEXT.WINDOW.CHAR		.EQ ZONE_TOOLS.INPUT_BUFFER+$C2 ;$1byt   Current character when parsing STRING


TEXT.WINDOW.BUFFER.TALLY	.EQ ZONE_TOOLS.INPUT_BUFFER+$C3 ;$1byt.   # of characters in the buffer
TWF.BOTTOM_ROW.TRIGGER		.EQ ZONE_TOOLS.INPUT_BUFFER+$C4 ;$1byt.  The row which triggers the scroll prompt

;Scrolling
TEXT.CHAR.DEPTH				.EQ $08	;#CONSTANT. number of lines in a text character
TWF.SCROLLING.STOP_LINE		.EQ ZONE_TOOLS.INPUT_BUFFER+$C5 	;$1byt.
TWF.PRINTED_LINE.COUNTER	.EQ ZONE_TOOLS.INPUT_BUFFER+$C6 	;$1byt. Tracks the number of lines printed to the text screen. Used to determine when the <ANY KEY> prompt should be displayed.
	
@END	
	
;============TILE INFORMATION=============
;****See beginning of file


;============TIME & EVENTS=============
@START
TIME.SUN.STATUS				.BS $1		;$00 = SUN RISING, $01 = DAY, $02 = SUN SETTING, $03 = NIGHT
TIME.SUN.COUNTER			.BS $1		;COUNTS DOWN FROM $04 FOR SUNSET, COUNTS UP FROM $00 FOR SUNRISE
TIME.SUN.SUB_COUNTER		.BS $1		;COUNTS THE MOVES BETWEEN INCREMENTS TO TIME.SUN.COUNTER
TIME.SUN.SUB_COUNTER.STOP	.EQ $02		;#CONSTANT. MOVES BETWEEN PHASES ON SUNSET AND SUNRISE

TIME.CURRENT.HOUR			.BS $1		;!BCD!. 24-hour clock. The current game time, hours. 
TIME.CURRENT.MINUTE			.BS $1		;!BCD!. 24-hour clock. The current game time, minutes. 
TIME.MOVES.PER_MINUTE		.EQ	$02		;#CONSTANT. The number of moves that must occur for the game clock to advance 1 minute
TIME.MOVES.COUNTER			.BS $1		;Tracks the number of moves that have occured since the game clock was incremented by 1 minute.

TIME.DISPLAY.HOUR			.BS $1		;!BCD!. 12-hour clock. The current game time, hours. 
TIME.DISPLAY.MINUTE			.BS $1		;!BCD!. 12-hour clock. The current game time, minutes. 
TIME.DISPLAY.AM_PM			.BS $1		;$HEX$. $00=AM, $01=PM

EVENT.SUNRISE.HOUR 			.EQ $05			;#CONSTANT. The time that sunrise occurs.
EVENT.SUNRISE.MINUTE		.EQ	$30			;#CONSTANT. ""
EVENT.SUNSET.HOUR 			.EQ $20			;#CONSTANT. The time that sunset occurs.
EVENT.SUNSET.MINUTE			.EQ	$30			;#CONSTANT. ""

EVENT.FLAGS					.BS $100	;$100byt. Stores boolean flags ($01 = on, $00 off) that trigger certain events, allow/dissallow certain things, or otherwise dynamically affect gameplay 

;EVENT CONSTANTS
EVENT.UNDEAD_LORD.FIRE_DROP.PROB	.EQ $20	;if random # is less than this value, fire is dropped. Roughly 15% chance if random number generator was working correctly. My intention is for it to be more like 50% chance or 25% chance.  

@END

;========ZONE OPERATIONS==========

;*****see OFFLOADED VARIABLES2.ASM***


;========SYSTEM VARIABLES/LABELS=======
AUX.READ_ADDRESS.START 		.BS $2

DEBUG.LOG							.EQ $3000 ;***HARD CODED REFERENCE**


;TEMPCOUNTER		.BS $1

;========MISC=======
@START

TROUBLESHOOTING.HOOK			.BS $1				;$01 = HOOK SET. CODE CAN BE INSERTED IN A ROUTINE TO BREAK IF THE HOOK IS SET.
TROUBLESHOOTING.HOOK2			.BS $1				;$01 = HOOK SET. CODE CAN BE INSERTED IN A ROUTINE TO BREAK IF THE HOOK IS SET.

CALLED_BY.DRAW.SCREEN			.BS	$1				;1byt			IF SET TO $01, INDICATES THAT DRAW.SCREEN IS THE CALLING ROUTINE. THIS VARAIBLES IS SEPERATE BECAUSE FLOW CONTROL DECISIONS ARE MADE BASED ON IT. 
CALLED_BY.DRAW.TILE.PLAYER.STANDARD_ICON			.BS	$1				;1byt			IF SET TO $01, INDICATES THAT .STANDARD_ICON IN DRAW.TILE.PLAYER IS THE CALLING ROUTINE. THIS VARAIBLES IS SEPERATE BECAUSE FLOW CONTROL DECISIONS ARE MADE BASED ON IT. 
CALLED_BY						.BS $1				;1byt			USED TO TRACE THE CALLING ROUTINE. $00 = NOT SET
		;CALLED_BY CODE CHART
		;$00 = NOT SET  (KNOWN LOCATIONS WHERE IT'S NOT SET:  DRAW.TILE.PLAYER)
		;$01 = NOT USED (TO AVOID CONFUSION WITH DRAW.SCREEN, WHICH USES CALLED_BY.DRAW.SCREEN)
		;$02 = MOVE.PASS
		;$03 = MOVE.NORTH
		;$04 = MOVE.SOUTH
		;$05 = MOVE.EAST 
		;$06 = MOVE.WEST
		;$07 = TRANSPORT.ENTRANCE
		;$08 = .MOB.MOVE.ERASETILE
		;$09 = .MOB.MOVE.ERASETILE.MT
		;$0A = .MOB.DRAWTILE.ENTRANCE2   1ST INSTANCE
		;$0B = .MOB.DRAWTILE.ENTRANCE2   2ND INSTANCE
		;$0C = MOB.DRAWTILE.MT
		;$0D = DRAW.MISC
		;$0E = DRAWTILE
		;$0F = TRANSPORT.DRAWTILE.MT

@END
		
;========TEMPORARY=======
;PLAYER_ICON		.HS AA.D5.AA.D5.CA.D4.AA.D5.A8.C5.A8.C5.A2.D1.8A.D4.8A.D4.8A.D4.8A.D4.A2.D1.A2.D1.A2.D1.A2.D1.A8.C5

;see game_loop.asm, at the end of the file				

				
	;.NO $2000 	;advance program counter to this address, backfill $00




				









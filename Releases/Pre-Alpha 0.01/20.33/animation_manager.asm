;************************INCLUDE FILE*****************************
;(do not assemble stand-alone. For a stand-alone version of this routine see examples/rwts2)

;=====================ANIMATION_MANAGER.ASM DOCUMENTATION====================================
;Note: For a higher level discussion of the implementation of animation in the game
;See the "Animation" Section in Technical Overview.doc (/my_code/documentation). The "Animated Tiles" section
;of Graphics Details.doc talks in detail about how shape tables for animated tiles are setup. 
;
;See Chart 1.1 (my_code/documentation) for an illistration of the flow control
;of the subroutines in this file. 
; 
;The entrance to all animation routines is ANIMATION.UPDATE. 
;
;=================================================================================


ANIMATION.UPDATE 		;============INCREMENTS FRAME FOR ALL ANIMATION TILES ON-SCREEN=======
@START
;PARAMTERS: NONE
;ENTRANCE: DIRECT
;RETURN: ANIMATION.FRAME_STATE


;=====================SUBROUTINE DOCUMENTATION====================================
;
;This subroutine is the entrance to all animation routines. It is called
;by GAME.PRIMARY_LOOP while waiting for a keypress.
;The outerloop iterates through each tile in SCREEN.TILE.DATA looking for animation tiles.
;
;=================================================================================



;NOTES
;If a key is pressed, animation for water tiles is skipped but is processed for all other
;tile types. 
;
;A cycling the animation frames, a delay is inserted unless a key was process since the
;routine was called. The delay is needed to slow down animation with a small number of
;animated tiles on the screen. 
;
;The amount of the delay depends on the number of animated tiles on the screen.


;DISABLE.BS_RAM
	LDA $C082				;READ ENABLE ROM, DISABLE WRITE ON BSM (NORMAL STATE).
							;REQUIRED FOR ANIMATION.UPDATE BECAUSE WAIT IS USED, A ROM ROUTINE. 

;INIT VARIABLES, COUNTERS, INDEXES
	LDA #$00
	STA ANIMATION.SCREEN.TALLY
	;STA ANIMATION.DEEP_WATER.TALLY
	
	LDX #$00							;INIT COUTER FOR LOOP
	LDA	#$FF							;SET ACC VALUE FOR USE IN LOOP
	TAY									;INIT Y-REG TO #$FF TO THAT INY AT START OF OUTERLOOP FLIPS IT TO #$00
LOOP
	STA	ANIMATION.MT.TRACKING,X			;INIT #$FF TO THIS ARRAY INSTEAD OF #$00 BECAUSE #$00 COULD BE A VALID MOB RECORD INDEX VALUE
	INX
	CPX #$10
	BNE LOOP
		
OUTERLOOP1
	INY									;NEXT TILE

;LOAD TILE_TYPE OF THE NEXT TILE IN CURRENT ROW
	LDA SCREEN.TILE.DATA,Y
		
		; CMP #$88
		; BEQ ANIMATION.SCROLL.WATER_STEP
		; CMP #$89
		; BEQ ANIMATION.SCROLL.WATER_STEP	
		; CMP #$8A
		; BEQ ANIMATION.SCROLL.WATER_STEP		
		; JMP ANIMATION.TILE.TESTS

; ANIMATION.SCROLL.WATER_STEP
	; JMP ANIMATION.SCROLL.WATER
	
ANIMATION.TILE.TESTS
@START
;=====================SUBROUTINE DOCUMENTATION====================================
;
;ANIMATION.TILE.TESTS (in ANIMATION.UPDATE) determines if there is a map object (i.e. transport, mob) located
;at the current screen tile location. If yes, then it subsitutes the Tile_ID for the map_object before 
;falling through to TEST.TILE_TYPE. In the case of Mobs, the determining the Tile_ID
;is complicated due to support for multi-tile mobs. See notes on DETERMINE.MOB.TILE_TYPE below.
;
;=================================================================================


; ;IS TILE DEEP WATER?
; ;(note: this tally is used to determine whether to force animation to complete when entire screen is deep water tiles)
	; CMP #TILE_ID.DEEP_WATER
	; BNE .CHECK.FOR.MOB
	; INC ANIMATION.DEEP_WATER.TALLY
	; ;**FALLS THROUGH**
	
;IS TILE SHAPE ANIMATED?
.CHECK.FOR.MOB
	LDX SCREEN.MO_MOB.DATA,Y			;DOES CURRENT TILE HAVE A MOB MO?	
	CPX #$FF
	BEQ .CHECK.FOR.TRANSPORT			;IF NO, THEN CHECK FOR TRANSPORT
			
	JMP DETERMINE.MOB.TILE_TYPE			;RETURNS THE TILE_TYPE IN ACC. IF MOB IS MULTI-TILE, THE NECESSARY ADJUSTMENTS ARE MADE TO THE TILE_TYPE IN THE MO RECORD FOR THE MOB

.CHECK.FOR.TRANSPORT ;(AND ANIMATED PLAYER WALKING TILES)
	CPY #SCREEN.ARRAY.PLAYER_LOCATION
	BNE .USE.SCREEN_ARRAY_INDEX			;IF THIS ITERATION IS PROCESSING THE PLAYER LOCATION THEN THE TRANSPORT INDEX, IF ANY IS ACTIVE, MUST BE RETREIVED FROM  PLAYER.TRANSPORT.ACTIVE
	LDX PLAYER.TRANSPORT.ACTIVE	
	CPX #$FF							;DOES PLAYER HAVE ACTIVE TRANSPORT?
	BEQ .NO.TRANSPORT.ACTIVE			;IF NO, THEN NO ANIMATION SHOULD BE DRAW, NEXT TILE OR EXIT
	LDA MAP_OBJECTS.TRANSPORT+$2,X		;LOAD TILE TYPE OF ACTIVE TRANSPORT	
	JMP TEST.TILE_TYPE
.NO.TRANSPORT.ACTIVE
	LDA PLAYER.WALKING.TILE				;PLAYER IS WALKING. LOAD TILE TYPE OF PLAYER WALKING ICON
	JMP TEST.TILE_TYPE
	
.USE.SCREEN_ARRAY_INDEX					;IF THIS ITERATION IS PROCESSING THE PLAYER LOCATION, CONTINUE TO USE SCREEN.MO_TRANSPORT.DATA,Y AS THE INDEX TO THE MAP OBJECT ARRAY.
	LDX SCREEN.MO_TRANSPORT.DATA,Y		;DOES CURRENT TILE HAVE A TRANSPORT	
	CPX #$FF
	BEQ TEST.TILE_TYPE					;IF NO, THEN SKIP AHEAD TO TEST TILE TYPE FOR ANIMATION	
	LDA MAP_OBJECTS.TRANSPORT+$2,X		;LOAD TILE TYPE OF TRANSPORT AT THE CURRENT SCREEN ARRAY LOCATION (Y-REG)

@END

TEST.TILE_TYPE
@START
;=====================SUBROUTINE DOCUMENTATION====================================
;
;TEST.TILE_TYPE is a bit of spaghetti code. It is the gatekeeper to ANIMATION.TILE.FRAME_CYCLE,
;which does the actual graphics plotting. The first thing it does is branch to 
;EXIT_TEST if the Tile_ID it's passed in the ACC is not in the animated tile range.
;This makes it difficult to use ANIMATION.SCROLL.PLAYER on non-animated player icon tiles.
;
;If a Tile_Type is animated, it is not automatically refered ANIMATION.TILE.FRAME_CYCLE for graphics
;plotting. There are exceptions where an animated tile should not be drawn
;and exceptions to those exceptions (you can probably see why this section of code got complicated)
;Just to make it more complex, TEST.TILE_TYPE also tests for Tile_IDs that have special
;animation features (currently just quicksand).
;
;Exceptions: When an Animated Tile Should not be Drawn
;tall grass, darkness, player location
;1) If the screen tile location is flagged as dark
;2) If the Tile_ID passed is for a Mob, but the underlying terrain tile is tall grass (Mobs go into stealth mode)
;3) If the current screen location in the ltop is the the player location
;				This requires checking to see if the player has active transport and if that active transport is a frigate (multi-tile object) because the player location is then 4 screen locations. 
;Exceptions to the Exceptions
;3) if the player has active transport and the transport tile is animated, then the tile should be drawn. 
;3) if the player icon is an animated Tile_ID. 
;
;----Special Animation Features---
;This subroutine doesn't have enough to do so we also tasked it with checking 
;to see if the Tile_ID passed has any special animation features. 
;
;1) Quicksand. If the Tile_ID is quicksand then a sinking effect is created by scrolling the player icon. This is done by a call to SCROLL.PLAYER.ICON.
;=================================================================================

	;ACC WILL HAVE TILE_TYPE FROM EITHER SCREEN.TILE.DATA (LOADED AT START OF .OUTTERLOOP), FROM .CHECK.FOR.MOB, OR FROM .CHECK.FOR.TRANSPORT
	STA ANIMATION.CURRENT_TILE_TYPE		;SAVED FOR USE IN .ANIMATION.TILE.FRAME_CYCLE. 	
	CMP #ANIMATION.TILE_RANGE.START		;IS CURRENT TILE A MAP ANIMATION TILE?
	BCS	.TEST.DARKNESS					;IF YES, PROCEED TO DARKNESS TEST
	JMP EXIT_TEST						;IF NO, NEXT TILE OR EXIT

.TEST.DARKNESS
;IS TILE HIDDEN (DARKNESS) 
	LDX SCREEN.DARK.DATA,Y			
	CPX #$01
	BNE .TEST.TALL_GRASS
.EXIT_TEST_STEP	
	JMP EXIT_TEST						;IF YES, NEXT TILE OR EXIT

.TEST.TALL_GRASS
;IS TILE TALL GRASS? (MOBS ARE STEALTHY, NO ANIMATION)	
	LDA SCREEN.TILE.DATA,Y
	CMP #TILE_ID.TALL_GRASS_A
	BEQ .EXIT_TEST_STEP					;IF YES, NEXT TILE OR EXIT
	CMP #TILE_ID.TALL_GRASS_B
    BEQ .EXIT_TEST_STEP					;IF YES, NEXT TILE OR EXIT
	
	;***FALLS THROUGH***
	
.NOTDARK
.NOT.TALL_GRASS
.TEST.PLAYER_LOCATION			
;IS TILE PLAYER LOCATION?
;NOTE: This is needed because the player could be standing on an animated tile.  		
	CPY #SCREEN.ARRAY.PLAYER_LOCATION
	BNE .CHECK.MT.PLAYER.LOCATIONS	
		
	LDX PLAYER.TRANSPORT.ACTIVE			
	CPX #$FF							;DOES PLAYER HAVE ACTIVE TRANSPORT?
	BEQ .TEST.FOR.SPECIAL_TILE_FEATURES2	;IF NO, THEN NO ANIMATION SHOULD BE DRAW, NEXT TILE OR EXIT

		
	LDA MAP_OBJECTS.TRANSPORT+$2,X		;LOAD TILE TYPE OF ACTIVE TRANSPORT
	CMP #ANIMATION.TILE_RANGE.START		;IS TRANSPORT TILE AN ANIMATION TILE? (E.G. WYVERN)
	BCS .ACTIVE.TRANSPORT.ANIMATED		;IF YES, DRAW ANIMATION
	JMP EXIT_TEST							;IF NO, DON'T DRAW ANIMATION. NEXT TILE OR EXIT

.TEST.FOR.SPECIAL_TILE_FEATURES2
;IS PLAYER STANDING IN QUICKSAND(PLAYER SINKS)
	LDA SCREEN.TILE.DATA,Y
	
	CMP #TILE_ID.QUICKSAND
	BNE .IS.PLAYER.ANIMATED					;IF NO, NEXT TEST
	JSR ANIMATION.SCROLL.PLAYER				;SKIP STANDARD ANIMATION AND SCROLL PLAYER TILE TO CREATE SINKING EFFECT
	JMP EXIT_TEST
	
	;MOTH-BALLED CODE
	; ; CMP #ANIMATION.WATER_RANGE.START	;IS TILE_TYPE < START OF WATER TILE RANGE?
	; ; BCC .IS.PLAYER.ANIMATED				;IF YES, NEXT CHECK 
	
	; ; CMP #ANIMATION.WATER_RANGE.END		;IS TILE_TYPE >= END OF WATER TILE RANGE+$1?
	; ; BCS .IS.PLAYER.ANIMATED				;IF YES, NEXT CHECK 
	
	; ; JSR ANIMATION.SCROLL.PLAYER			;PLAYER IS IN WATER. SKIP STANDARD ANIMATION AND SCROLL PLAYER TILE TO CREATE SINKING EFFECT
	; ; JMP EXIT_TEST

	
.IS.PLAYER.ANIMATED
;IS PLAYER TILE ANIMATED?
	LDA PLAYER.WALKING.TILE
	CMP #ANIMATION.TILE_RANGE.START		;IS CURRENT TILE A MAP ANIMATION TILE?
	BCS	.PLAYER.WALKING.ICON.ANIMATED	;IF YES, PROCESS ANIMATION FOR THIS TILE
	JMP EXIT_TEST						;IF NO, NEXT TILE OR EXIT


.CHECK.MT.PLAYER.LOCATIONS
;CHECK IF TRANSPORT IS ACTIVE FIRST BECAUSE ITS THE FASTER TEST. IN THE ABOVE ROUTINE WE NEED TO REST THE REGULAR PLAYER LOCATION WHETHER TRANSPORT IS ACTIVE OR NOT SO REGUALR PLAYER ICON DOESN'T GET DRAWN OVER WITH ANIMATION
	LDX PLAYER.TRANSPORT.ACTIVE			
	CPX #$FF									;DOES PLAYER HAVE ACTIVE TRANSPORT?
	BEQ .NO.MT.TRANSPORT.ACTIVE					;IF NO, THEN NO ANIMATION SHOULD BE DRAW, TEST EXIT.
	
	LDA MAP_OBJECTS.TRANSPORT+$2,X				;LOAD TILE TYPE OF ACTIVE TRANSPORT
	CMP #TILE_ID.FRIGATE1.1						;IS TRANSPORT A SINGLE TILE OBJECT? (FRIGATES ARE THE ONLY MULTI-TILE TRANSPORT IN THE GAME. IF MORE WERE ADDED, THEN EITHER TWO TILE_TYPE CHECKS ARE NEEDED OR A MULTI-TILE FLAG WOULD BE NEEDED
	BNE .NO.MT.TRANSPORT.ACTIVE					;IF YES, NO NEED TO CHECK THE LOCATIONS THE PLAYER ICON WOULD OCCUPY WHEN MULTI-TILE TRANSPORT IS ACTIVE. 
			
	CPY #PLAYER.TRANSPORT.MT.TILE_LOCATION1		;CHECK MULTI-TILE PLAYER TRANSPORT LOCATIONS
	BEQ .IS.PLAYER.MT.LOCATION						;IF PLAYER LOCATION, DON'T DRAW ANIMATION, TEST EXIT	
	CPY #PLAYER.TRANSPORT.MT.TILE_LOCATION2		;CHECK MULTI-TILE PLAYER TRANSPORT LOCATIONS
	BEQ .IS.PLAYER.MT.LOCATION						;IF PLAYER LOCATION, DON'T DRAW ANIMATION, TEST EXIT	
	CPY #PLAYER.TRANSPORT.MT.TILE_LOCATION3		;CHECK MULTI-TILE PLAYER TRANSPORT LOCATIONS
	BEQ .IS.PLAYER.MT.LOCATION						;IF PLAYER LOCATION, DON'T DRAW ANIMATION, TEST EXIT	
	JMP .NOTPLAYER_TILE
	
.IS.PLAYER.MT.LOCATION	
	JMP EXIT_TEST								;IF YES, NEXT TILE OR EXIT

	
.ACTIVE.TRANSPORT.ANIMATED
	STA ANIMATION.CURRENT_TILE_TYPE		;UPDATED. THIS IS REQUIRED BECAUSE THE ACTIVE TRANSPORT INDEX IS NOT STORED IN THE TRANSPORT SCREEN ARRAY, SO THE ONLY WAY TO DETECT AN ACTIVE TRANSPORT OBJECT IS TO CHECK PLAYER.TRANSPORT.ACTIVE VARIABLE. 
.PLAYER.WALKING.ICON.ANIMATED
.NO.MT.TRANSPORT.ACTIVE
.NOTPLAYER_TILE
;HAS PLAYER PRESSED A KEY SINCE THIS ROUTINE WAS RUN? IF SO, SKIP WATER TILE ANIMATION	
	; CMP #ANIMATION.WATER_RANGE.START	;IS TILE_TYPE < START OF WATER TILE RANGE?
	; BCC ANIMATION.TILE.FRAME_CYCLE		;IF YES, CONTINUE
	
	; CMP #ANIMATION.WATER_RANGE.END		;IS TILE_TYPE >= END OF WATER TILE RANGE+$1?
	; BCS ANIMATION.TILE.FRAME_CYCLE		;IF YES, CONTINUE
	
	; LDA KB_BUFFER						;LOAD NEXT KEY PRESS FROM BUFFER
    ; BPL ANIMATION.TILE.FRAME_CYCLE		;IF NO KEY PRESS, CONTINUE
	; JMP EXIT_TEST						;IF KEY PRESSED, LEAVE IT IN BUFFER AND RETURN TO GAME LOOP FOR KEYPRESS PROCESSING
	
	
@END

ANIMATION.TILE.FRAME_CYCLE ; ========DRAWS NEXT ANIMATION FRAME FOR ONE TILE======
@START

;=====================SUBROUTINE DOCUMENTATION====================================
;
;ANIMATION.TILE.FRAME_CYCLE is very straightforward. It is an in-line 
;version of DRAW.TILE.SINGLE & DRAW.TILE from Graphics_Engine.ASM. A few
;this occur worth mentioning before the in-line code starts at .CALC.SHAPE.TABLE
;
;1) A counter is incremented that tracks the numbe of animation tiles on 
;the screen, which is used in .EXIT to determine if a delay should be 
;inserted between the cycling of animation frames.
;
;2) Crocodile. Some checks are done on the Tile_ID that was passed and the Tile_ID 
;in SCREEN.TILE.DATA for the current screen location. If the checks conclude that
;there is a crocodile mob located in a surf water tile, then mob's Tile_ID is 
;changed because crocodiles have a different Tile_ID in water than they do on land. 
;
;=================================================================================



;DRAWS TO FOREGROUND
	
;PARAMTERS: Y-REG (SCREEN POSITION AS MAPPED TO ELEMENT OF SCREEN.TILE.DATA)
;RETURN: NONE
;ENTRANCE: DIRECT
	
	STY TEMP
	LDA #SCREEN.ARRAY.LAST_ELEMENT
	CMP TEMP
	BCS .START
	JMP ERROR2
	
.START	
		
	INC ANIMATION.SCREEN.TALLY		;KEEP TRACK OF THE # OF ANIMATED TILES ON THE VIEW SCREEN

	
;DETERMINE TILE_TYPE OF THE CURRENT ANIMATION TILE TO CYCLE
	LDA ANIMATION.CURRENT_TILE_TYPE
;IS MOB A CROCODILE?
	CMP #TILE_ID.CROC_A					;DOES MOB HAVE CROC PRIMARY TILE_ID?
	BNE .CALC.SHAPE.TABLE				;IF NO, CALCULATE SHAPE TABLE

	LDA SCREEN.TILE.DATA,Y				;LOAD MAP TILE MOB SITS ON
	CMP #TILE_ID.SURF					;IS CROC IN SURF WATER?
	BNE .CALC.SHAPE.TABLE				;IF NO, CALCULATE SHAPE TABLE
	
	LDA #TILE_ID.CROC_B					;IF YES, SUBSTITUTE ALTERNATE CROC TILE_ID (IN WATER ENVIRONMENT) 
	JMP .CALC.SHAPE.TABLE.ENTRANCE2	

;In-line: DRAW.TILE.SINGLE & DRAW.TILE (Graphics_Engine.ASM)
.CALC.SHAPE.TABLE
;CALCULATE SHAPE TABLE ADDRESS
	LDA ANIMATION.CURRENT_TILE_TYPE
.CALC.SHAPE.TABLE.ENTRANCE2	
	TAX								
	LDA TILE.SHAPES.LO,X			;LOAD SHAPE TABLE BASE ADDRESS INTO OP2
	STA OP2	
	LDA TILE.SHAPES.HO,X
	STA OP2+$1
@MIDDLE

;ANIMATION.FRAME_STATE holds the current animation frame number for all animation tiles
;on the view screen. This variable can be used as an offset to the shape table base address
;to identify the address for the current animation frame for the shape table already loaded
;into SHAPE in the routine above.
;
;Each frame is $20 bytes (!32), so we can use ASL multiplication to calcualte the offset. 

;**OPT** Speed. Now that there are 4 animation frames instead of 6, 8-bit addition could be used for the offset
;because page boundaries would never be crossed by the offset. If I add some 8 frame animation tiles I think
;8 bit addition will work there as well because each tile will take an entire page. Just increment the HO byte.
;Even though some delays are inserted, this will still help performance what there
;are lots of animation tiles on the screen (such as water) as no delay is inserted then.

	LDA ANIMATION.FRAME_STATE		;LOAD CURRENT ANIMATION FRAME
	
	ASL ;X2						
	ASL ;X4							
	ASL ;X8							
	ASL ;X16						
	ASL ;X32

	STA OP1							;LOAD SHAPE TABLE BASE OFFSET INTO OP1
	
	LDA #$00
	STA OP1+$1

;=======INLINE CODE FOR ADC.16========	
;TILE.SHAPES.HO/LO(2)+ ACC(1) [ANIMATION FRAME OFFSET]


; DO THE MATH
	CLD 
    CLC                          ;ALWAYS BEFORE ADD
    LDA OP1
    ADC OP2
    STA AUX_MOVE.START
		 
    LDA OP1+$1
    ADC OP2+$1					;carry flag not cleared via CLC intentionally, it's part of 16-bit adding. 
    STA AUX_MOVE.START+$1
	
;======================================
	
	LDA #SHAPE.SIZE				;# OF BYTES IN SHAPE TABLE
	STA OP1
	LDA #$00
	STA OP1+$1

	LDA AUX_MOVE.START
	STA OP2
	LDA AUX_MOVE.START+$1
	STA OP2+$1
;=======INLINE CODE FOR ADC.16========	
;SHAPE.SIZE(1)+ AUX_MOVE.START(2)


; DO THE MATH
	CLD 
    CLC                          ;ALWAYS BEFORE ADD
    LDA OP1
    ADC OP2
    STA AUX_MOVE.END
		 
    LDA OP1+$1
    ADC OP2+$1					;carry flag not cleared via CLC intentionally, it's part of 16-bit adding. 
    STA AUX_MOVE.END+$1
	
;======================================	

	LDA #SHAPE.HOPPER1				;SAVE SHAPE.HOPPER1 AS THE DESTINATION ADDRESS FOR AUX MOVE
	STA AUX_MOVE.DEST
	STA SHAPE						;CONNECTS SHAPE.HOPPER1 TO SHAPE, USED BY DRAW.TILE
	LDA /SHAPE.HOPPER1
	STA AUX_MOVE.DEST+$1
	STA SHAPE+$1			

	CLC								;EXECUTE AUX MEMORY MOVE
	JSR AUX_MOVE
			
	
			
	LDA SCREEN.INDEX.TILE_SBYTE,Y
	STA	TEMP
	STA SCREEN.DRAW.BYTE1
	INC TEMP
	LDA TEMP
	STA SCREEN.DRAW.BYTE2
	
	LDA SCREEN.INDEX.TILE_LINE,Y
	STA TILE.LINE.START
	STA TILE.LINE
	STY SAVED.YREG.LOCAL			;Y-REG IS USED IN .DRAW.LOOP, BUT IT IS ALSO NEEDED BY OUTERLOOP TO TRACK THE CURRENT TILE
	STX SAVED.XREG.LOCAL
	
	
	TAX						;LOAD LINE IN X REGISTER	
	LDA #$00
	STA SHP.TBL.CNTR		;START DRAWING AT BEGINNING OF SHAPE TABLE

	LDA TILE.LINE.START		;THE STARTING LINE OF THE TILES IN THE CURRENT ROW
	CLC						;*OPT* I I THINK ALL CLS CAN BE REMOVED WHEN I'M NOT EXPECTING AN OVERFLOW
	ADC #TILE.DEPTH.STANDARD			;ADD DEPTH OF SHAPE TO STARTING LINE IN HEX (# of lines, not the position of last line....so line positions $0-$F is $10 (!16) total lines)
	STA TILE.LINE.STOP		;SET THE LAST LINE TO DRAW BASED ON THE DEPTH OF THE TILE

@MIDDLE
	
.DRAW.LOOP
	LDA PAGE.BACKGROUND		;SPECIFY PAGE TO GET ADDRESS FOR
;==========INLINE CODE GET.LINE.ADDRESS1==================	
	;TILE.LINE IS IN X-REG
	CMP #$02
	BEQ .LOOKUP.PAGE2
	CMP #$01				;DOES ACC = PAGE1? IF, YES FALL THROUGH TO PAGE 1 LOOKUP
	
.LOOKUP.PAGE1	
	LDA LINE.HO.P1,X		;GET LINE ADDRESS
	STA LINE.BASE.ADDR1+$1
	LDA LINE.LO,X
	STA LINE.BASE.ADDR1
	JMP .GETLINE_COMPLETE

.LOOKUP.PAGE2
	LDA LINE.HO.P2,X		;GET LINE ADDRESS
	STA LINE.BASE.ADDR1+$1
	LDA LINE.LO,X
	STA LINE.BASE.ADDR1
.GETLINE_COMPLETE
;========================================================


;MAIN DRAW CODE
;NOTE: SINCE ONLY TWO SCREEN BYTES ARE NEEDED AS THIS IS A SINGLE TILE DRAW, LOOKING UP BOTH BYTES
	LDY SHP.TBL.CNTR		;LOAD Y WITH SHAPE TABLE COUNTER
	LDA (SHAPE),Y			;LOAD SHAPE BYTE (1st screen byte of the tile)
	LDY SCREEN.DRAW.BYTE1	;SCREEN BYTE INDEX IN Y REGISTER	
	STA (LINE.BASE.ADDR1),Y	;PLOT (1st screen byte)
	
	INC SHP.TBL.CNTR		;NEXT SHAPE BYTE, NEXT TILE LINE
;	INC SCREEN.DRAW.CURRENT_BYTE			;SWITCH TO 2ND SCREEN BYTE IN THE TILE
	
	LDY SHP.TBL.CNTR		;LOAD Y WITH SHAPE TABLE COUNTER
	LDA (SHAPE),Y			;LOAD SHAPE BYTE (2nd screen byte of the tile)
	LDY SCREEN.DRAW.BYTE2	;SCREEN BYTE INDEX IN Y REGISTER	
	STA (LINE.BASE.ADDR1),Y	;PLOT (2st screen byte)
	
	;DEC SCREEN.DRAW.CURRENT_BYTE			;SWITCH BACK TO 1ST SCREEN BYTE IN THE TILE	;**OPT** if the counters are updated after the CMP/branch it might save 1 INC SCREEN.DRAW.CURRENT_BYTE instruction in the main loop because SCREEN.DRAW.CURRENT_BYTE will be in 2nd position when this loop ends. 
	INX						;NEXT TILE LINE
	INC SHP.TBL.CNTR		;NEXT SHAPE BYTE
	
	CPX TILE.LINE.STOP		;IS TILE DONE?							
	BCC .DRAW.LOOP			;IF NO, DRAW NEXT LINE (BCC: is X-REG < CPX value)	

	LDY SAVED.YREG.LOCAL			;RESTORE Y-REG
	LDX SAVED.XREG.LOCAL			;RESTORE X-REG

@END	
EXIT_TEST
@START
	CPY #SCREEN.ARRAY.LAST_ELEMENT	;AT LAST TILE?
	BCS .EXIT						;IF YES, EXIT	
	JMP OUTERLOOP1	


.EXIT
; ;INSERT DELAY, BUT SKIP IF KEYPRESS
	; LDA KB_BUFFER					;LOAD NEXT KEY PRESS FROM BUFFER. WAS KEY PRESSED?
    ; BMI .SKIPALL					;IF YES, SKIP DELAY, AND LEAVE KEY IN BUFFER, RETURN TO GAME LOOP FOR KEYPRESS PROCESSING



	
	
	LDA ANIMATION.SCREEN.TALLY		
	CMP #ANIMATION.DELAY_TRIGGER1	;DETERMINE IF DELAY SHOULD BE SKIPPED BASE ON # OF ANIMATED TILES ON CURRENT VIEW SCREEN
	BCS .SKIP1
	
	LDA #$FF
	JSR WAIT 				;IF NO, INSERT DELAY
.SKIP1
	LDA ANIMATION.SCREEN.TALLY		
	CMP #ANIMATION.DELAY_TRIGGER2	;DETERMINE IF DELAY SHOULD BE SKIPPED BASE ON # OF ANIMATED TILES ON CURRENT VIEW SCREEN
	BCS .DELAY_DONE	

	LDA #$FF
	JSR WAIT 				;IF NO, INSERT DELAY
	

.DELAY_DONE	
.SKIPALL
;INCREMENT CURRENT ANIMATION FRAME	
			LDA ANIMATION.FRAME_STATE
			CMP #ANIMATION.TOTAL_FRAMES
			BNE .NOFLIP
		
			LDA #$00
			STA ANIMATION.FRAME_STATE
			JMP .DONE
.NOFLIP
	INC ANIMATION.FRAME_STATE

.DONE
;INSERT DELAY, BUT SKIP IF KEYPRESS
	; LDA KB_BUFFER					;LOAD NEXT KEY PRESS FROM BUFFER. WAS KEY PRESSED?
    ; BMI .EXIT.ANIMATION_ABORT		;IF YES, SKIP DELAY, AND LEAVE KEY IN BUFFER, RETURN TO GAME LOOP FOR KEYPRESS PROCESSING
	
.EXIT.ANIMATION_COMPLETE
	JSR FLIP.PAGE
	;**OPT** Speed. Insert in-line code

	
;ENABLE.BS_RAM BEFORE EXITING
	LDA $C083				;READ TWICE TO READ/WRITE ENABLE BANK SWITCHED-RAM ($Dxxx BANK 1ST)
	LDA $C083	
		
	RTS

ERROR2
;	ANIMATION.TILE.FRAME_CYLE reports request to draw a tile to a location not on the screen 
;	(i.e. > $BA)

	;DISABLE.BS_RAM
	LDA $C082				;READ ENABLE ROM, DISABLE WRITE ON BSM (NORMAL STATE). MUST DO BEFORE A BRK BECAUSE THE MONITOR IS A ROM ROUTINE. 

	LDA TEXT	
	BRK
@END	
@END
	
DETERMINE.MOB.TILE_TYPE ;============FACTORS IN WHETHER MOB IS MULTI-TILE=====
@START
;PARAMETERS: X-REG (HOLDING THE MO INDEX OF THE CURRENT MOB)
;RETURN: ACC (MOB TILE TYPE)

;=====================SUBROUTINE DOCUMENTATION====================================
;This subroutine is called is a mob map object is detected at the current screen tile location
;being processed. 
;
;This subroutine is responsible for returning the Tile_ID associated with the mob. 
;Doing so is straightforward if the mob is single tile it is just a matter of returning byte 3 from the 
;MAP_OBJECTS.MOB array for the mob's record. 
;
;For multi-tile mobs, the challenge is that the Tile_ID is different 
;for each tile of the mob. However, the mob's record in MAP_OBJECTS.MOB
;only stores the Tile_ID of the upper left corner of the mob, which is also
;the first tile (upper left corner) that will be encoutered by the animation loop because
;the animation loop examines the screen arrays left to right, top to bottom. 
;
;The mob's screen array (SCREEN.MO_MOB.DATA) only stores the index to
;the MOB's record in MAP_OBJECTS.MOB, so this subroutine has to first figure out
;which of the multi-tile mob's tile locations is associated with the currente screen location. 
;
;Once that is known, returning the correct Tile_ID is straightforward because Multi-Tile Mobs 
;Tile_IDs are sequential (i.e the first Tile_ID is for the upper left tile of the mob, the 2nd)
;Tile ID is for the upper right tile of the mob, 3rd is for lower left, 4th is for lower right).
;So the Tile_IDs for a multi-tile mob might be $96,$97,$98,$99. 
;
;This subroutine determines which multi-tile mob tile location is assocaited with the
;current screen location being processed by keeping a tally of the number of times
;this routines has been called for each mob record. This works because
;the direction the screen arrays are iterated (described above) results in
;the loop encountering the multi-tile mob's tile locations sequentially. 
;=================================================================================


	STY SAVED.YREG.LOCAL				;HOLDS OUTERLOOP COUNTER
	
.EXTRACT_FLAGS							;THE FLAGS IN BYTE3 OF THE MOB'S MO RECORD MUST BE EXTRACTED TO DETERMINE IF IT IS A MT MOB
;EXTRACT MOB BOOLEAN FLAGS	
	LDA MAP_OBJECTS.MOB+$3,X
	LDY #$00	
.LOOP	
	LSR
	BCS .CARRY_IS_SET					
.CARRY_IS_CLEAR							;THE CARRY IS NOT KATIE
	STA SAVED.ACC.LOCAL
	LDA #$00
	JMP .WRITE_FLAG_VALUE
.CARRY_IS_SET							;THE CARRY IS KATIE
	STA SAVED.ACC.LOCAL
	LDA #$01

.WRITE_FLAG_VALUE
	STA MAP_OBJECTS.MOB_FLAGS,Y
	CPY #$07
	BEQ .FLAGS_DONE
	INY
	LDA SAVED.ACC.LOCAL
	JMP .LOOP
.FLAGS_DONE

;IS MOB MULTI-TILE?	
	LDA MOB.FLAG3							;MULT-TILE MOB?
	CMP #$01
	BEQ .MT.SEARCH.ENTRANCE					;IF YES, EXTRACT PRELIMINARY TILE TYPE FROM THE MOB'S MO RECORD AND ADJUST BASED ON THE MT TILE# (0-3) OF THE CURRENT SCREEN POSITION. 
	JMP .EXIT2								;IF NO, LOAD THE TILE TYPE FROM THE MOB'S MO RECORD AND EXIT

.MT.SEARCH.ENTRANCE	
@START
;DETERMINE MT TILE_TYPE								
	LDY #$00
.LOOP.MT.SEARCH							
	LDA ANIMATION.MT.TRACKING,Y			;LOAD NEXT MT INDEX
	STA ANIMATION.MT.INDEX				
	CMP #$FF							;#$FF IS THE ARRAY STOP VALUE. IF IT'S BEEN REACHED, THIS IS THE FIRST TILE FOR THIS MOB TO BE PROCESSED.
	BEQ .MT.INDEX.NOT_FOUND

	CPX ANIMATION.MT.INDEX

	BNE	.NEXT_RECORD
	LDA ANIMATION.MT.TRACKING+$1,Y		;LOAD MT TILE # (0-3)
	STA ANIMATION.MT.TILE_NUMBER

;ADJUST IF ON CERTAIN SCREEN EDGES (FOR OTHER EDGES SEE .MT.INDEX.NOT_FOUND)
	;LAST COLUMN
	LDA MAP_OBJECTS.MOB,X				;LOAD X-AXIS
	CMP #MAP_OBJECTS.X.LAST_COLUMN		
	BNE .NEXT_TEST1
	LDA ANIMATION.MT.TILE_NUMBER		;IF X = LAST COLUMN, AND MT TILE = #$01, THEN ADJUST MT TILE# TO #$02
	CMP #$01
	BNE .NEXT_TEST1
	INC ANIMATION.MT.TILE_NUMBER
.NEXT_TEST1

	;FIRST COLUMN (HANDLED WHEN RECORD IS FIRST RECORDED IN .MT.INDEX.NOT_FOUND)
	;LAST ROW (NOT NEEDED BECAUSE THE FIRST TWO TILES APPEARING ONSCREEN ARE MT TILE1, MT TILE2
	;FIRST ROW ((HANDLED WHEN RECORD IS FIRST RECORDED IN .MT.INDEX.NOT_FOUND)

.TESTS_DONE
	STY SAVED.YREG.LOCAL1				;SAVE LOOP COUNTER FOR .LOOP.MT.SEARCH
	LDY MAP_OBJECTS.MOB+$2,X			;LOAD PRELIMINARY TILE TYPE
	STX SAVED.XREG.LOCAL				;SAVE MOB RECORD INDEX
	LDX #$01
.LOOP.MT.CALC.TILE_TYPE		
	INY									;Y-REG WILL HOLD THE FINAL TILE_TYPE WHEN THIS LOOP COMPLETES
	CPX ANIMATION.MT.TILE_NUMBER		;THE MT TILES #S ARE SEQUENTIAL, IN INCREMENTS OF 1, SO USING THE MT TILE NUMBER AS THE STOP VALUE IS PERFECT
	BEQ	.DONE3
	INX									;INCREMENT LOOP COUNTER
	JMP .LOOP.MT.CALC.TILE_TYPE
.DONE3
	STY ANIMATION.MT.FINAL_TILE_TYPE	;STORE VALUE TO FREE UP Y-REG AND ACC
	LDY SAVED.YREG.LOCAL1				;RESTORE LOOP COUNTER FOR .LOOP.MT.SEARCH, WHICH IS INDEX TO THE TRACKING ARRAY

;INCREMENT AND SAVE THE MT TILE NUMBER TO THE TRACKING ARRAY
	INC ANIMATION.MT.TILE_NUMBER				
	LDA ANIMATION.MT.TILE_NUMBER
	STA ANIMATION.MT.TRACKING+$1,Y	
			

	
;RESTORE REGISTERS, LOAD FINAL TILE_TYPE AND EXIT	
	LDX SAVED.XREG.LOCAL				;RESTORE MOB RECORD INDEX	
	LDY SAVED.YREG.LOCAL				;RESTORE OUTERLOOP COUNTER 
	LDA ANIMATION.MT.FINAL_TILE_TYPE	;RETURN FINAL TILE_TYPE IN ACC
	JMP TEST.TILE_TYPE
	
.NEXT_RECORD
	INY									;INCREMENT LOOP COUNTER TWICE
	INY
	CPY #$10							;IF THE MOB'S RECORD INDEX ISN'T FOUND BY THE END OF THE ARRAY'S MEMORY SIZE (#$10), THEN FALL THROUGH TO .MT.INDEX.NOT_FOUND
	BNE .LOOP.MT.SEARCH	
	LDY #$00							;SET Y-REG TO #$00 BECAUSE THIS IS WHERE THE MOB'S RECORD INDEX WILL GET RECORDED
	;***FALLS THROUGH
	
.MT.INDEX.NOT_FOUND
	TXA									;TRANSFER MOB RECORD INDEX TO THE ACC
	STA ANIMATION.MT.TRACKING,Y			;SAVE MOB'S RECORD INDEX TO THE TRACKING ARRAY

;ADJUST FOR CERTAIN SCREEN EDGES (SEE .LOOP.MT.SEARCH FOR OTHER EDGES)
	;FIRST COLUMN, APPROACH
			; LDX MAP_OBJECTS.X_APPROACH+$1
			; LDY MAP_OBJECTS.MOB,X
			; LDA TEXT
			; LDA PAGE1
			; BRK
	LDA MAP_OBJECTS.MOB,X				;LOAD X-AXIS
	CMP MAP_OBJECTS.X_APPROACH+$1		
	BNE .NOT_FIRST_COLUMN_APPROACH


	LDA #$03							;IF FIRST COLUMN, SET MT TILE NUMBER FOR NEXT ITERATION TO #$03. THIS ELIMINATES A NEED FOR AN ADJUSTMENT IN .LOOP.MT.SEARCH 
	STA ANIMATION.MT.TRACKING+$1,Y
	LDY MAP_OBJECTS.MOB+$2,X			;LOAD MOB BASE TILE TYPE
	INY									;IN FIRST COLUMN, MT #$01 SHOULD BE DISPLAYED FIRST
	TYA									;RETURN TILE TYPE IN ACC
	JMP .EXIT.FINAL
.NOT_FIRST_COLUMN_APPROACH
	;FIRST ROW, APPROACH

	LDA MAP_OBJECTS.MOB+$1,X			;LOAD Y-AXIS
	CMP MAP_OBJECTS.Y_APPROACH+$1		;IS MOB IN FIRST ROW -1?
	BNE .NO_EDGE_CASES
	LDA #$03							;IF FIRST COLUMN, SET MT TILE NUMBER FOR NEXT ITERATION TO #$03. THIS ELIMINATES A NEED FOR AN ADJUSTMENT IN .LOOP.MT.SEARCH 
	STA ANIMATION.MT.TRACKING+$1,Y
	LDY MAP_OBJECTS.MOB+$2,X			;LOAD MOB BASE TILE TYPE
	INY
	INY									;IN FIRST COLUMN, MT #$02 SHOULD BE DISPLAYED FIRST
	TYA									;RETURN TILE TYPE IN ACC

	JMP .EXIT.FINAL

.NO_EDGE_CASES
	LDA #$01							;START MT TILE# AT #$01 SINCE TILE#0 WILL BE RETURNED THIS ITERATION
	STA ANIMATION.MT.TRACKING+$1,Y

	;***FALLS THROUGH
@END

.EXIT2	
	LDA MAP_OBJECTS.MOB+$2,X			;LOAD MOB TILE TYPE AND RETURN VIA ACC	
.EXIT.FINAL
	LDY SAVED.YREG.LOCAL				;RESTORE OUTERLOOP COUNTER
	JMP TEST.TILE_TYPE 
@END
	
ANIMATION.SCROLL.PLAYER	;SCROLLS PLAYER ICON TO CREATE SINKING EFFECT
@START
;PARAMTERS: ACC (TILE TYPE)
;ENTRANCE: DESIGNED FOR MAIN ANIMATION ROUTINE
;RETURN: NONE

;=====================SUBROUTINE DOCUMENTATION====================================
;This subroutine is called by TEST.TILE_TYPE (ANIMATION UPDATE) if the 
;Tile_ID being processed is a Tile_ID that requires this feature (i.e. quicksand)
;
;The principle of this routine is essentially the same as the routines in Graphics_Scrolling.ASM.
;The difference is that the scrolling is applies to a single tile instead of the entire tile grid.
;
;The scolling technique as applied to a single tile is as follows:
;	*Line 15 is copied to line 16. Line 14 is copied to line 15, and so on
;		until every line of the tile has been copied to the line below it. 
;
;The result of this is that the 2 screen bytes in the last line of the
;tile (last before scrolling) are overwritten and are no longer displayed
;on the graphics screen. 
;
;These changes are made to the player icon in the player icon buffer.
;Since the DRAW.TILE.PLAYER routine is setup use the data in the player icon buffer
;when drawing the walking player icon, the player's "sunk" appearance will
;persist, even if the player moves, unless the routines in Movement_Manager.ASM
;reset the player icon buffer by calling LOAD.PLAYER.WALKING.ICON, which 
;they do once the player walks onto a non-quicksand tile.  
;=================================================================================

		;*****DO NOT MODIFY CONTENTS OF ACC, IT'S A PARAMETER!!!!!
		


;SAVE REGISTERS
	STX SAVED.XREG.LOCAL
	STY SAVED.YREG.LOCAL			

;CONTINUE SCROLLING PLAYER ICON?
	CMP #TILE_ID.QUICKSAND				;IS PLAYER STANDING IN QUICKSAND
	BNE .OTHER.TERRAIN	
	LDA PLAYER.HEIGHT					;IF YES, HAS HE ALREADY SUNK TO MAX (ABOUT WAIST DEEP)
	CMP #TILE.QUICKSAND.SINK.HEIGHT
	BCS .START							;IF NO, THEN SCROLL 
	JMP .EXIT							;IF YES, THEN EXIT

.OTHER.TERRAIN	
;ERROR: UNEXPECTD TILE_ID WAS ALLOWED TO ENTER THIS ROUTINE
	;DISABLE.BS_RAM
	LDA $C082				;READ ENABLE ROM, DISABLE WRITE ON BSM (NORMAL STATE). MUST DO BEFORE A BRK BECAUSE THE MONITOR IS A ROM ROUTINE. 

	LDA TEXT	
	BRK
	
	
.START	
;INCREMENT GLOBAL COUNTERS
	INC ANIMATION.SCREEN.TALLY
	DEC PLAYER.HEIGHT
	
;SETUP GRAPHICS SCREEN VARIABLES					
	LDA SCREEN.INDEX.TILE_SBYTE,Y
	STA	TEMP
	STA SCREEN.DRAW.BYTE1
	
	LDA SCREEN.INDEX.TILE_LINE,Y
	STA TILE.LINE.FIRST
	STA TILE.LINE.STOP
	DEC TILE.LINE.STOP
	CLC
	ADC #$F			;******NEEDS TO BE 1 LESS THAN TILE.DEPTH.STANDARD
	STA TILE.LINE.COPY_TO
	STA TILE.LINE.COPY_FROM
	DEC TILE.LINE.COPY_FROM

;INIT OTHER VARIABLES
	LDA #$1F
	STA ANIMATION.SCROLL.COUNTER
	
	

.LOOP.SCROLL
;=========SCROLL TILE=============
@START
	LDX	TILE.LINE.COPY_TO		
	LDY SCREEN.DRAW.BYTE1	;THIS IS REALLY TILE SCREEN BYTE0
	INY						;ADVANCE INDEX TO TILE SCREEN BYTE1
	
.GET.LINE.ADDRESS1A.2
	LDA PAGE.BACKGROUND		;SPECIFY PAGE TO GET ADDRESS FOR	
	CMP #$02
	BEQ .ADDR1A.LOOKUP.PAGE2.2
	
.ADDR1A.LOOKUP.PAGE1.2
	LDA LINE.HO.P1,X			;GET LINE ADDRESS
	STA LINE.BASE.ADDR1+$1
	LDA LINE.LO,X
	STA LINE.BASE.ADDR1
	JMP .LOOKUP1A.COMPLETE.2

.ADDR1A.LOOKUP.PAGE2.2
	LDA LINE.HO.P2,X			;GET LINE ADDRESS
	STA LINE.BASE.ADDR1+$1
	LDA LINE.LO,X
	STA LINE.BASE.ADDR1

.LOOKUP1A.COMPLETE.2
	
.GET.LINE.ADDRESS2A.2

	LDX TILE.LINE.COPY_FROM
	
	LDA PAGE.BACKGROUND			;SPECIFY PAGE TO GET ADDRESS FOR
	CMP #$02
	BEQ .ADDR2A.LOOKUP.PAGE2.2
	
.ADDR2A.LOOKUP.PAGE1.2
	LDA LINE.HO.P1,X		;GET LINE ADDRESS
	STA LINE.BASE.ADDR2+$1
	LDA LINE.LO,X
	STA LINE.BASE.ADDR2
	JMP .LOOKUP2A.COMPLETE.2

.ADDR2A.LOOKUP.PAGE2.2
	LDA LINE.HO.P2,X		;GET LINE ADDRESS
	STA LINE.BASE.ADDR2+$1
	LDA LINE.LO,X
	STA LINE.BASE.ADDR2
.LOOKUP2A.COMPLETE.2

@MIDDLE
	
;COPY TILE SCREEN BYTE1
	LDA (LINE.BASE.ADDR2),Y				;TILE DATA: COPY FROM	
	STA (LINE.BASE.ADDR1),Y				;TILE DATA: COPY TO
	
	STY SAVED.YREG.LOCAL1	
	LDY ANIMATION.SCROLL.COUNTER		;TRACKS BYTES READ BY THIS LOOP
	STA PLAYER.ICON.BUFFER,Y	
	DEC ANIMATION.SCROLL.COUNTER		;IT RUNS BACKWARDS BECAUSE THIS LOOP STARTS COPYING BYTES AT THE BOTTOM OF THE TILE
	LDY SAVED.YREG.LOCAL1
	
	DEY									;SWITCH TO SCREEN BYTE0

;COPY TILE SCREEN BYTE0
	LDA (LINE.BASE.ADDR2),Y				;TILE DATA: COPY FROM	
	STA (LINE.BASE.ADDR1),Y				;TILE DATA: COPY TO
	
	STY SAVED.YREG.LOCAL1	
	LDY ANIMATION.SCROLL.COUNTER		;TRACKS BYTES READ BY THIS LOOP
	STA PLAYER.ICON.BUFFER,Y	
	DEC ANIMATION.SCROLL.COUNTER		;IT RUNS BACKWARDS BECAUSE THIS LOOP STARTS COPYING BYTES AT THE BOTTOM OF THE TILE
;		LDY SAVED.YREG.LOCAL1
		
	DEC TILE.LINE.COPY_TO				;NEXT TILE LINE
	DEC TILE.LINE.COPY_FROM
	
	
	;NO NEED TO RESET TO SCREEN BYTE1, THAT IS DONE AT THE START OF THE LOOP
	
	DEX									;X-REG CONTAINS VALUE OF TILE.LINE.COPY_FROM BEFORE THE DEC ABOVE. SO DOING A DEX IS THE FUNCTIONALY THE SAME AS AND LDX TILE.LINE.COPY_FROM EXCEPT IT IS 2 CLOCK CYCLES FASTER. 
	CPX TILE.LINE.STOP					;IS TILE DONE?	
	BNE .LOOP.SCROLL					;IF NO, DRAW NEXT LINE (BCC: is ACC < CMP value)

@END
	
.EXIT
;RESTORE REGISTERS
	LDX SAVED.XREG.LOCAL
	LDY SAVED.YREG.LOCAL			
	RTS

@END

; ANIMATION.SCROLL.WATER
@START
; ;SAVE REGISTERS
	; STX SAVED.XREG.LOCAL
	; STY SAVED.YREG.LOCAL			


;=====================SUBROUTINE DOCUMENTATION====================================
;This subroutine was setup to scroll water tiles as the method of animating
;them instead of flipping frames. It works but it seemed choppier than 
;frame flipping for animating water so I didn't use it. The choppyness
;might be fixable but since frame flipping was working well once I started
;writing animation to the background page, I moved on.
;
;This code may be useful for future purposes. It was the starting point
;for the ANIMATION.SCOLL.PLAYER subroutine which creates the quicksand
;sinking effect. 
;=================================================================================
				
	; INC ANIMATION.SCREEN.TALLY
	
	; LDA SCREEN.INDEX.TILE_SBYTE,Y
	; STA	TEMP
	; STA SCREEN.DRAW.BYTE1
	
	; LDA SCREEN.INDEX.TILE_LINE,Y
	; STA TILE.LINE.FIRST
	; STA TILE.LINE.STOP
	; DEC TILE.LINE.STOP
	; CLC
	; ADC #$F			;******NEEDS TO BE 1 LESS THAN TILE.DEPTH.STANDARD
; ;#TILE.DEPTH.STANDARD			;ADD DEPTH OF SHAPE TO STARTING LINE IN HEX (# of lines, not the position of last line....so line positions $0-$F is $10 (!16) total lines)	
; ;	STA TILE.LINE.START
	; STA TILE.LINE.COPY_TO
	; STA TILE.LINE.COPY_FROM
	; DEC TILE.LINE.COPY_FROM
; ;	STA TILE.LINE.STOP					;SET THE LAST LINE TO DRAW BASED ON THE DEPTH OF THE TILE	
	
	
; ;=======COPY LAST LINE OF TILE TO BUFFER====


			
	; LDX TILE.LINE.COPY_TO
	; LDY SCREEN.DRAW.BYTE1

; ;GET LINE ADDRESS FOR 1ST LINE OF TILE
; .GET.LINE.ADDRESS1A.1
	; LDA PAGE.FOREGROUND		;SPECIFY PAGE TO GET ADDRESS FOR	
	; CMP #$02
	; BEQ .ADDR1A.LOOKUP.PAGE2.1
	
; .ADDR1A.LOOKUP.PAGE1.1	
	; LDA LINE.HO.P1,X		;GET LINE ADDRESS
	; STA LINE.BASE.ADDR1+$1
	; LDA LINE.LO,X
	; STA LINE.BASE.ADDR1
	; JMP .LOOKUP1A.COMPLETE.1

; .ADDR1A.LOOKUP.PAGE2.1
	; LDA LINE.HO.P2,X		;GET LINE ADDRESS
	; STA LINE.BASE.ADDR1+$1
	; LDA LINE.LO,X
	; STA LINE.BASE.ADDR1

; .LOOKUP1A.COMPLETE.1	
; ;COPY TILE SCREEN BYTE0
	; LDA (LINE.BASE.ADDR1),Y				;TILE DATA: COPY FROM	
	; STA ZONE_TOOLS.OUTPUT_BUFFER		;TILE DATA: COPY TO   (borrwing this buffer from the zone manager)

	; INY									;ADVANCE TO NEXT SCREEN BYTE

; ;COPY TILE SCREEN BYTE1
	; LDA (LINE.BASE.ADDR1),Y				;TILE DATA: COPY FROM	
	; STA ZONE_TOOLS.OUTPUT_BUFFER+$1		;TILE DATA: COPY TO (borrwing this buffer from the zone manager)




; ;=========SCROLL REMAINING LINES OF TILE=============

; .LOOP.SCROLL
	
	; LDX	TILE.LINE.COPY_TO		
	; LDY SCREEN.DRAW.BYTE1		
	
; .GET.LINE.ADDRESS1A.2
	; LDA PAGE.FOREGROUND		;SPECIFY PAGE TO GET ADDRESS FOR	
	; CMP #$02
	; BEQ .ADDR1A.LOOKUP.PAGE2.2
	
; .ADDR1A.LOOKUP.PAGE1.2
	; LDA LINE.HO.P1,X		;GET LINE ADDRESS
	; STA LINE.BASE.ADDR1+$1
	; LDA LINE.LO,X
	; STA LINE.BASE.ADDR1
	; JMP .LOOKUP1A.COMPLETE.2

; .ADDR1A.LOOKUP.PAGE2.2
	; LDA LINE.HO.P2,X		;GET LINE ADDRESS
	; STA LINE.BASE.ADDR1+$1
	; LDA LINE.LO,X
	; STA LINE.BASE.ADDR1

; .LOOKUP1A.COMPLETE.2
	
; .GET.LINE.ADDRESS2A.2

	; LDX TILE.LINE.COPY_FROM
	
	; LDA PAGE.FOREGROUND			;SPECIFY PAGE TO GET ADDRESS FOR
	; CMP #$02
	; BEQ .ADDR2A.LOOKUP.PAGE2.2
	
; .ADDR2A.LOOKUP.PAGE1.2
	; LDA LINE.HO.P1,X		;GET LINE ADDRESS
	; STA LINE.BASE.ADDR2+$1
	; LDA LINE.LO,X
	; STA LINE.BASE.ADDR2
	; JMP .LOOKUP2A.COMPLETE.2

; .ADDR2A.LOOKUP.PAGE2.2
	; LDA LINE.HO.P2,X		;GET LINE ADDRESS
	; STA LINE.BASE.ADDR2+$1
	; LDA LINE.LO,X
	; STA LINE.BASE.ADDR2
; .LOOKUP2A.COMPLETE.2

				
; ;COPY TILE SCREEN BYTE0
	; LDA (LINE.BASE.ADDR2),Y				;TILE DATA: COPY FROM	
	; STA (LINE.BASE.ADDR1),Y				;TILE DATA: COPY TO
	
	; INY									;ADVANCE TO NEXT SCREEN BYTE

; ;COPY TILE SCREEN BYTE1
	; LDA (LINE.BASE.ADDR2),Y				;TILE DATA: COPY FROM	
	; STA (LINE.BASE.ADDR1),Y				;TILE DATA: COPY TO
	
			
	; DEC TILE.LINE.COPY_TO				;NEXT TILE LINE
	; DEC TILE.LINE.COPY_FROM
	
	; DEY									;RESET SCREEN BYTE TO 0
	
	; DEX									;X-REG CONTAINS VALUE OF TILE.LINE.COPY_FROM BEFORE THE DEC ABOVE. SO DOING A DEX IS THE FUNCTIONALY THE SAME AS AND LDX TILE.LINE.COPY_FROM EXCEPT IT IS 2 CLOCK CYCLES FASTER. 
	; CPX TILE.LINE.STOP					;IS TILE DONE?	
	; BNE .LOOP.SCROLL					;IF NO, DRAW NEXT LINE (BCC: is ACC < CMP value)


				
		

; ;=======COPY BUFFER TO FIRST LINE====

	; LDX TILE.LINE.FIRST
	; LDY SCREEN.DRAW.BYTE1

; ;GET LINE ADDRESS FOR 1ST LINE OF TILE
; .GET.LINE.ADDRESS1A.3
	; LDA PAGE.FOREGROUND		;SPECIFY PAGE TO GET ADDRESS FOR	
	; CMP #$02
	; BEQ .ADDR1A.LOOKUP.PAGE2.3
	
; .ADDR1A.LOOKUP.PAGE1.3	
	; LDA LINE.HO.P1,X		;GET LINE ADDRESS
	; STA LINE.BASE.ADDR1+$1
	; LDA LINE.LO,X
	; STA LINE.BASE.ADDR1
	; JMP .LOOKUP1A.COMPLETE.3

; .ADDR1A.LOOKUP.PAGE2.3
	; LDA LINE.HO.P2,X		;GET LINE ADDRESS
	; STA LINE.BASE.ADDR1+$1
	; LDA LINE.LO,X
	; STA LINE.BASE.ADDR1
; .LOOKUP1A.COMPLETE.3

				
						
; ;COPY TILE SCREEN BYTE0
	; LDA ZONE_TOOLS.OUTPUT_BUFFER		;TILE DATA: COPY FROM
	; STA (LINE.BASE.ADDR1),Y				;TILE DATA: COPY TO
	
	; INY									;ADVANCE TO NEXT SCREEN BYTE

; ;COPY TILE SCREEN BYTE1
	; LDA ZONE_TOOLS.OUTPUT_BUFFER+$1		;TILE DATA: COPY TO	
	; STA (LINE.BASE.ADDR1),Y				;TILE DATA: COPY FROM	
	
			

; .EXIT
; ;RESTORE REGISTERS
	; LDX SAVED.XREG.LOCAL
	; LDY SAVED.YREG.LOCAL			
	; JMP EXIT_TEST	


@END
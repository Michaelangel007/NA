;************************INCLUDE FILE*****************************
;(do not assemble stand-alone. For a stand-alone version of this routine see examples/rwts2)


;**OPT** Speed. I've considerd ideas like creating a preindex to the starting value in 
;GMAP.TILE.DATA for each row. For movement, this would only help 1 index lookup in
;DRAW.ROW.SINGLE (because there is only 1 index lookup per row), and would only help
;1 index lookup in DRAW.COLUMN.SINGLE because after the first lookup it takes advatange
;of TILE.LOOKUP.SINGLE's ability to remember an index after the first index is calcualted. 
;There would also need to be a lot of 16 bit <> calcualtion to determine the correct
;preindex to use. I'm not sure this really accomplishes much
;
;Another approach I considered was enabling TILE.LOOKUP.INDEX to reuse the same
;index when called a 2nd time. However, this really wouldn't help movement because
;DRAW.ROW.SINGLE only looks up one index. This optimization alone doesn't seem 
;like it would really help. 
;
;The only approach I can think of now that might speed up movement is to setup
;routines that iterate GMAP.TILE.DATA in reverse when moving west or north, in conjunction
;with remembered the last index and tally. The end result seems like it would
;enable the index to essentially pickup where it left off and iterate a very short
;distance to find the next tile_type. It really should never iterrate more than one
;tile pair. It either just adds 1 to the tally or increments 1 tile pair over. 
;However, before doing this it is worth calculating how much memory is saved
;by the in-memory compression techqniue vs. how much code already exists to support it
;unless the savings are substantial it might be better just to do disk only compression.

 




;TESTED STATUS OF THIS VERSION: 16-BIT UPGRADE COMPLETE. 
;COMPLETE (/w 8-bit and 16-bit gmap.lookup value): LOAD ROW0 /w 4 scenario test, LOAD ROW1 with 4 scenario test. 
;
;the 4 scenarios are: 1) no overflow starting position, no overflow ending position, 2) overflow start, no overflow end 3) no overflow start, overflow end 4) overflow start, overflow end


TILE.LOOKUP.SCREEN		;===========LOAD ENTIRE SCREEN OF TILES===========
;PARAMETERS: GMAP
;RETURN: SCREEN.TILE.DATA
;ENTRANCE: DIRECT


.INIT.MAP
	LDA GMAP					;LOAD TILE_ID OF CURRENT MAP POSITION (CENTER/PLAYER TILE)
	STA OP1
	LDA GMAP+$1
	STA OP1+$1
	
	LDA #OFFSET.SCREEN			;CALCULATE TILE_ID OF TILE IN UPPER LEFT CORNER OF SCREEN
	STA OP2
	LDA /OFFSET.SCREEN
	STA OP2+$1
	
	JSR SBC.16					;GMAP(2) - SCREEN.OFFSET.LO/HO (2)
			
	LDA RESULT					;SAVE TILE_ID OF UPPER LEFT SCREEN TILE
	STA SMAP
	STA SMAP.CURRENT
	LDA RESULT+$1
	STA SMAP+$1
	STA SMAP.CURRENT+$1
	
;INIT COUNTERS
	LDX #$00					;ALWAYS INIT X-REG TO $00 BEFORE CALLING TILE.LOOKUP.INDEX
	LDA #$00
	STA SCREEN.TILE.COUNTER		
.LOAD.LOOP	
	LDA SMAP.CURRENT			;LOAD UPPER LEFT SCREEN TILE AS START OF ROW
	STA	GMAP.LOOKUP
	LDA SMAP.CURRENT+$1
	STA GMAP.LOOKUP+$1
	
	JSR TILE.LOOKUP.INDEX		;LOAD NEXT ROW
	JSR TILE.LOOKUP.ROW
			

;INCREMENT COUNTERS
	
	LDA SMAP.CURRENT					
	STA OP1
	LDA SMAP.CURRENT+$1
	STA OP1+$1
	
	LDA #OFFSET.DOWN			;CALCULATE TILE_ID OF TILE IN UPPER LEFT CORNER OF SCREEN
	STA OP2
	LDA #$00
	STA OP2+$1
	
	JSR ADC.16					;GMAP(2) - SCREEN.OFFSET.LO/HO (2)
			
	LDA RESULT					;SAVE TILE_ID OF UPPER LEFT SCREEN TILE
	STA SMAP.CURRENT
	LDA RESULT+$1
	STA SMAP.CURRENT+$1
	
	INC SCREEN.TILE.COUNTER		;COUNTS THE # OF ROWS LOADED
	
	LDA SCREEN.TILE.COUNTER		;# OF TILES IN A COLUMN == # OF ROWS ON THE SCREEN
	CMP #SCREEN.COLUMN.SIZE		;LAST ROW? 
	BNE .LOAD.LOOP				;IF NO, LOAD NEXT ROW
	
	RTS							;IF YES, EXIT
	

TILE.LOOKUP.INDEX		;=============????============
;PARAMETERS: GMAP.LOOKUP(2)
;RETURN: GMAP.INDEX, GMAP.OVERFLOW (these are used by related routines such as TILE.LOOKUP.ROW, TILE.LOOKUP.SINGLE)
;REQUIREMENTS: X-REG MUST BE INIT TO #$00 BEFORE CALL TO TILE.LOOKUP.INDEX	 	
;ENTRANCE: DIRECT

;WARNING: GMAP.LOOKUP is a 16-bit number. If using this routine via a driver with an 8 bit number make sure to init
;GMAP.LOOKUP+$1 to $00.

;TROUBLESHOOTING:
;
;Use TROUBLESHOOTING HOOK 1 (search for this text in this file), which uses
;GMAP.LOOKUP to trigger a BRK. Y-REG can also be a useful secondary trigger. 
;
;Resources mentioned are in the in the Game map development spreadsheet
;Also see data reference c:\mycode\load_reference_tool, I had forgotten 
;about it when originally writing this documentation. 
;
;The tile qty numbers to use as the basis for the GMAP.LOOKUP are in Global Tile # Map.
;remember for tile_qty, use 1 less than the tile # you want to lookup. 
;
;GMAP.INDEX.LO/HO will correspond to the element of the array that 
;TILE.LOOKUP.ROW would have loaded if the BRK wasn't inserted. 
;Use the Test Map Index worksheet to verify the gmap.index.lo/ho value for any given tile_qty, or vice versa.   
;
;X-REG isn't re-initialized unless the calling routine (such as TILE.LOOKUP.SCREEN) does so. 
;Accordingly, X-REG refers to the tile # on the view screen, as documented in Matrix Map worksheet 
;(the array map is on top, scroll down to find the SCREEN.TILE.ARRAY map)
;
;Y-REG is initalized on each call to TILE.LOOKUP.ROW, and is incremented two in each .copy.loop as it tracks the tile_qty/tile_type pairs.
;
;GMAP.ADDRESS.INDEX will point to the memory address that TILE.LOOKUP.ROW is reading from. Y-REG is the index added to this base address that enables
;TILE.LOOKUP.ROW to iterate through the GMAP.TILE.DATA array. 
;
;SCREEN.TILE.ARRAY is mapped to each screen row on the Screen Map chart in the Map Matrix worksheet. 
;Check the definition of SCREEN.TILE.ARRAY to see if it is still in the memory address range described. If not, redefine 
;it to the start of any super page to most easily use the chart. 




;**OPT** SPEED. MAKE TILE.LOOKUP.INDEX AND TILE.LOOKUP.ROW ONE ROUTINE, WITH TWO ENTRY POINTS (I.E. IF TILE.LOOKUP.INDEX)
;IS CALLED, IT AUTOMATICALLY FALLS THROUGH TO TILE.LOOKUP.ROW. THIS WOULD SAVE A SEPERATE JSR TO TILE.LOOKUP.ROW 
;OR MAYBE THE TOP LEVEL ROUTINE SHOULD BE CALLED TILE.LOOKUP.ROW, I'M NOT SURE THERE WOULD EVER BE A POINT
;TO DOING THE ROW LOOKUP WITHOUT THE INDEX LOOKUP FIRST. 



;SAVE REGISTERES
	TYA
	PHA
	
;init variables
	
	LDA #$00
	TAY
	STA GMAP.TALLY
	STA GMAP.TALLY+$1

	STA GMAP.INDEX.HO
	STA GMAP.INDEX.OVERFLOW
	
	LDA #GMAP.TILE.DATA
	STA GMAP.ADDRESS.INDEX
	LDA /GMAP.TILE.DATA
	STA GMAP.ADDRESS.INDEX+$1
	


;Identify the position in the compressed data associated with the uncompressed position lookup	
.LOOP.LOOKUP
	LDA (GMAP.ADDRESS.INDEX),Y				;**OPT** TO OPTIMIZE FOR SPEED, MAY BE ABLE TO SETUP A BRANCH SO THAT THE 16-BIT ADD IS ONLY DONE WHEN A 16-BIT VALUE IS PRESENT IN OP1 OR OP2. 
	STA OP1
	LDA GMAP.TALLY
	STA OP2
	
	LDA GMAP.TALLY+$1
	STA OP2+$1
	LDA #$00
	STA OP1+$1
	
	JSR ADC.16					;GMAP.TILE.DATA,X + GMAP.TALLY(2)

		
.TEMP2
	
	LDA RESULT
	STA GMAP.TALLY
	STA OP1
	LDA RESULT+$1
	STA GMAP.TALLY+$1
	STA OP1+$1
	
	
	LDA GMAP.LOOKUP
	STA OP2
	LDA GMAP.LOOKUP+$1
	STA OP2+$1
	JSR IGRE.16					;GMAP.TALLY(2) IGRE GMAP.LOOKUP(2)		
	

.TEMP
		
	BCS .SAVE.INDEX

.TEMP5

	INY							;ADVANCE TO NEXT TILE PAIR. X-REG IS THE LO BYTE OF GMAP.INDEX FOR THE DURATION OF THIS LOOP
	INY							;EVEN THOUGH IT'S A 2 BYTE INX, IT WILL ADVANCE FROM !254 TO 0, THUS BNE WILL DETECT THE FLIP. 
	BNE .NO.FLIP
	INC GMAP.ADDRESS.INDEX+$1
	INC GMAP.INDEX.HO			;**OPT** (a counter to help troubleshooting, comment out this line at least. If removed, also remove the definition for GMAP.INDEX.HO and GMAP.INDEX.LO. There are 3 lines like this in the program, two for HO and one for LO. 
.NO.FLIP
		 
		
	JMP .LOOP.LOOKUP	
	
.SAVE.INDEX
			;CPX #$11
			;BNE .TEMP6
			;LDA TEXT
			;LDA PAGE1
			;BRK
.TEMP6
	
	JSR SBC.16						;GMAP.TALLY(2) - GMAP.LOOKUP(2)

	
	LDA RESULT	
	CMP #$00						;USING 16-BIT BECAUSE PRIOR SBC.16 CALCULATION SHOULD ALWAYS RESULT IN AN 8-BIT VALUE

	BEQ	.NO.INDEX.OVERFLOW			;OVERFLOW? 
		
		
	LDA RESULT
	STA TEMP						;# OF TILES COMPRESSED AT GMAP.INDEX BEYOND WHAT IS NEEDED FOR GMAP.LOOKUP
	
	LDA (GMAP.ADDRESS.INDEX),Y
	SEC								;**OPT** remove if I'm not going to check for overflow error?
	SBC TEMP
	STA GMAP.INDEX.OVERFLOW			;# OF TILES MORE THAN WHAT SHOULD BE USED IN INDEX POSITION	
			
	JMP .EXIT						;IF INDEX OVERFLOW, EXIT (leave X index as-is so TILE.LOOKUP.ROW can parse out overflow tiles)

.NO.INDEX.OVERFLOW
	
	STA GMAP.INDEX.OVERFLOW			;SET INDEX OVERFLOW TO $00 ($00 SHOULD BE IN ACC ALREADY SINCE BRANCH TO GET HERE WAS BEQ)
	
	INY								;IF NO INDEX OVERFLOW, INCREMENT X INDEX TO NEXT TILE DATA PAIR (tile qty, tile type)
	INY								;ADVANCE TO NEXT TILE PAIR. X-REG IS THE LO BYTE OF GMAP.INDEX FOR THE DURATION OF THIS LOOP. ;EVEN THOUGH IT'S A 2 BYTE INX, IT WILL ADVANCE FROM !254 TO 0, THUS BNE WILL DETECT THE FLIP. 
    BNE .NO.FLIP2
	INC GMAP.ADDRESS.INDEX+$1
	INC GMAP.INDEX.HO			;**OPT** (a counter to help troubleshooting, comment out this line at least. If removed, also remove the definition for GMAP.INDEX.HO and GMAP.INDEX.LO. There are 3 lines like this in the program, two for HO and one for LO. 
.NO.FLIP2
	
	
.EXIT	
	STY GMAP.INDEX.LO					;**OPT** (a counter to help troubleshooting, comment out this line at least. If removed, also remove the definition for GMAP.INDEX.HO and GMAP.INDEX.LO. There are 3 lines like this in the program, two for HO and one for LO. 


	LDA	GMAP.ADDRESS.INDEX	
	STA OP1			
	LDA	GMAP.ADDRESS.INDEX+$1	
	STA OP1+$1							
	
	STY OP2								;Y-REG WAS THE LO BYTE COUNTER OF GMAP.ADDRESS.INDEX. GMAP.ADDRESS.INDEX+$1 (HO) IS INCREMENTED AS Y-REG FLIPS TO $00 DURING THIS ROUTINE. 
	LDA #$00
	STA OP2+$1
	JSR ADC.16							;GMAP.ADDRESS.INDEX (2) + Y-REG (1)
	
	LDA RESULT
	STA GMAP.ADDRESS.INDEX				;THIS WILL BE USED AS THE STARTING POINT FOR ITERATING THROUGH THE GMAP.TILE.DATA ARRAY IN TILES.LOOKUP.ROW FOR COPYING TILES TO THE SCREEN.TILE.DATA ARRAY
	LDA RESULT+$1
	STA GMAP.ADDRESS.INDEX+$1

;RESTORE REGISTERES
	PLA
	TAY
			
	RTS


	
TILE.LOOKUP.ROW 		 ;=============????============
;PARAMETERS
;REQUIREMENTS: MUST BE PRECEDED BY TILE.LOOKUP, BUT THEN CAN BE REPEATED TO 
;				OBTAIN ROWS IN SEQUENCE. 
;			 	X-REG MUST BE INIT TO #$00 BEFORE CALL TO TILE.LOOKUP
;ENTRANCE: DIRECT, WITH IMMEDIATE PREREQUISTE CALL TO TILE.LOOKUP.INDEX

;SAVE REGISTERS
	TYA
	PHA
	
;init counters	
	LDA #$00		
 	STA GMAP.EXPAND.TALLY
	STA TILE.COUNTER
	TAY
	
;get a compressed tile type pair
.GET.PAIR	

	
	LDA (GMAP.ADDRESS.INDEX),Y			;# OF TILES
	STA GMAP.INDEX.QUANTITY
	SEC
	SBC GMAP.INDEX.OVERFLOW			;IF THERE WAS AN INDEX OVERFLOW WHEN CALCULATING THE INDEX, SUBTRACT IT FROM THE TILE QTY.
	STA GMAP.INDEX.QUANTITY
	PHA						;push GMAP.INDEX.QUANTITY to the stack
	LDA #$00				
	STA GMAP.INDEX.OVERFLOW	
	PLA						;pull GMAP.INDEX.QUANTITY from the stack
	JMP .FIRST.ENTRY.ONLY
	
.GET.PAIR.LOOP
	LDA (GMAP.ADDRESS.INDEX),Y			;LOAD # OF TILES
	STA GMAP.INDEX.QUANTITY
.FIRST.ENTRY.ONLY	
	CLC
	ADC GMAP.EXPAND.TALLY			;KEEP A TALLY OF THE NUMBER OF TILES READ IN FROM THE COMPRESSED DATA. WE DON'T WANT TO COPY TOO MANY TO THE SCREEN.TILE.DATA ARRAY
	STA	GMAP.EXPAND.TALLY
	BCS .ERROR						;Exit to .ERROR if result of ADC is > 255
		
	LDA #SCREEN.ROW.SIZE
	CMP GMAP.EXPAND.TALLY 			;DO WE HAVE MORE THAN A FULL ROW OF TILES THIS CYCLE? (I.E. OVERFLOW)
	BCS .COPY						;IF NO, PROCEED TO COPY TILES TO SCREEN.TILE.DATA 	

	LDA GMAP.EXPAND.TALLY			;IF YES, DECREASE GMAP.INDEX.QUANTITY SO WE ONLY GET A FULL ROW OF TILES
	SEC
	SBC #SCREEN.ROW.SIZE
	STA TEMP
	LDA GMAP.INDEX.QUANTITY	
	SEC								;**OPT** ARE THESE SEC'S REALLY NEEDED IF I'M CONFIDENT THERE WILL BE NO SUBTRACTION UNDERFLOW?
	SBC TEMP
	STA GMAP.INDEX.QUANTITY
			
			
.COPY				
			;TROUBLESHOOTING HOOK 1
			;LDA GMAP.LOOKUP
			;CMP #$80
			;BNE .TEMP2
			;CPY #$00
			;BNE .TEMP2
			;LDA TEXT
			;LDA PAGE1
			;BRK
.TEMP2
	INY									;TEMPORARILY INCREMENT Y SO WE CAN ACCESS TILE TYPE
	LDA (GMAP.ADDRESS.INDEX),Y			;TILE TYPE
	DEY									;RETURN Y TO ORIGINAL VALUE FOR THIS ITERATION
.COPY.LOOP
	STA SCREEN.TILE.DATA,X

			
.TEMP

	INX
	INC TILE.COUNTER
		
	DEC GMAP.INDEX.QUANTITY
	BNE .COPY.LOOP

	
	LDA TILE.COUNTER
	CMP #SCREEN.ROW.SIZE			;HAVE A FULL ROW OF TILES BEEN COPIED?
	BCS .EXIT						;IF YES, EXIT (BCS: is Y-reg >= CPY operand)
	

	INY								;IF NO, ADVANCE TO NEXT TILE PAIR AND REPEAT
	INY
	JMP .GET.PAIR.LOOP
	
.EXIT	
	INY								;IF NO, INCREMENT INDEX BY TWO TO GET NEXT TILE PAIR IF THIS ROUTINE IS CALLED AGAIN
	INY
	BNE .NO.FLIP2
	INC GMAP.ADDRESS.INDEX+$1
	INC GMAP.INDEX.HO				;**OPT** (a counter to help troubleshooting, comment out this line at least. If removed, also remove the definition for GMAP.INDEX.HO and GMAP.INDEX.LO. There are 3 lines like this in the program, two for HO and one for LO. 
.NO.FLIP2

;RESTORE REGISTERS
	PLA
	TAY
	
	RTS
	
.ERROR
	;.GET.PAIR had an ADC overflow
	
	BRK


TILE.LOOKUP.COLUMN	;======================LOOKUP TILE_TYPE FOR A COLUMN OF TILES=================
;PARAMETERS: GMAP.LOOKUP(2), X-REG (INDEX TO SCREEN.TILE.ARRAY, VARIES BASED ON COLUMN TO DRAW)
;RETURN: NONE	
;ENTRANCE: DIRECT

;WARNING: THERE COULD BE PROBLEMS CALLING THIS ROUTINE MORE THAN ONCE UNLESS GMAP.LOOKUP VALUE IS
;SET DIRECTLY (I.E. VIA LDA/STA, NOT INCREMENTED) PRIOR TO THE SUBSEQUENT CALLS. OTHERWISE THE 1 TILE ADJUSMENT
;TO GMAP.LOOKUP BEING DONE IN THE NEXT FEW LINES OF CODE WOULD END UP BECOMING CUMMULATIVE. 

;SAVE REGISTERS
	TXA					;THIS ROUTINE NEEDS X-REG SET BY THE CALLING ROUTINE, BUT IT ALSO NEEDS TO RESTORE X TO IT'S ORIGINAL VALUE AT BEFORE EXITING
	PHA	

	INC GMAP.LOOKUP		;THIS IS TO ADJUST FOR A DIFFERENCE IN HOW TILE.LOOKUP.SINGLE TREATS THE GMAP.TALLY.LOOKUP VALUE, VS. HOW THE TILE.LOOKUP.INDEX ROUTINE DOES IT. IT'S POSSIBLE TO GET THE TWO ROUTINE TO CONFORM, BUT THAT WOULD TAKE MANY MORE INSTRUCTIONS THEN JUST THE ONE "INC" ON THIS LINE.  
	BNE .NOFLIP
	INC GMAP.LOOKUP+$1
.NOFLIP
	LDY #$00 
	LDA #$01 			;THIS CAN BE REMOVED IF ACC > $00 BEFORE ENTERING .LOOP. LDA = #$01 SO FIRST ITERATION OF TILE.LOOKUP.SINGLE WILL CALCULATE THE INDEX TO GMAP.TILE.DATA
.LOOP
	;ACC MUST BE > $00 JUST BEFORE START OF THIS LOOP! (OTHERWISE TILE.LOOKUP.SINGLE WON'T CALCUALTE A NEW INDEX ON THE FIRST CALL)
	JSR TILE.LOOKUP.SINGLE	
	LDA SAVED.ACC.LOCAL
	STA SCREEN.TILE.DATA,X	
	STA SCREEN.TILE.HOPPER,Y
	
	LDA SCREEN.DARK.DATA,X			;HOLDS THE DARKNESS FLAG FOR THE TILES LOADED INTO SCREEN.TILE.HOPPER
	STA SCREEN.DARK.HOPPER,Y
	
	LDA #$00						;THE SCROLL ROUTINE FOR THIS ARRAY LEAVES THE COLUMN/ROW ELEMENTS UNTOUCHED, AND THEY NEED TO BE INIT TO $00
	STA SCREEN.DARK.DATA_BEFORE,X	;IT IS EFFICIENT TO DO THIS HEAR BECAUSE WE'RE ALREADY ITERATING THROUGH THE NEW COLUMN 

	INY

	TXA 						;INCREMENT COUNTER FOR WRITING TO SCREEN.TILE.DATA ARRAY
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	TAX
	
	CPX SCREEN.ARRAY.STOP_VALUE
	BEQ .EXIT
		
	LDA GMAP.LOOKUP
	STA OP1
	LDA GMAP.LOOKUP+$1
	STA OP1+$1

	LDA #OFFSET.DOWN
	STA OP2						
	LDA #$00				
	STA OP2+$1					
	
	JSR ADC.16					;GMAP.LOOKUP(2) + OFFSET.DOWN(1)
	
	LDA RESULT					;SAVE RESULT OF ADC.16
	STA GMAP.LOOKUP				
	LDA RESULT+$1
	STA GMAP.LOOKUP+$1
	
	LDA #$00
;!!!!WARNING: THIS LOOP MUST END WITH ACC == #$00 OR TILE.LOOKUP.SINGLE WILL CALCULATE A NEW INDEX ON EACH ITERATION	

	JMP .LOOP	

.EXIT

;RESTORE REGISTERS
	PLA
	TAX

	RTS
	
	
TILE.LOOKUP.SINGLE ; =============LOOKUP SINGLE TILE_TYPE (STAND-ALONE)=======
;PARAMETERS: GMAP.LOOKUP(2), ACC (#$00 use existing index, default calcualte new index)
;RETURN: SAVED.ACC.LOCAL (tile_type)
;ENTRANCE: DIRECT (TILE.LOOKUP.INDEX DOESN'T NEED TO BE CALLED FIRST)

;NOTE: Return Value is different than TILE.LOOKUP.ROW   **CLARITY*** opportunity to clarify code
;
;			the return value from this routine is affected by a differce in how it treats GMAP.LOOKUP vs. how TILE.LOOKUP.INDEX does. 
;	 		TILE.LOOKUP.INDEX has overflow calculations. So, once the tile qty specified in GMAP.LOOKUP is found, if there is no overflow, 
;			the INDEX is set to the tile pair following the tile pair where GMAP.LOOKUP was found. 
;			
;			In this routine, the index is set to the tile pair where GMAP.LOOKUP is found.
;			Said another way, TILE.LOOKUP.INDEX assumes you want it to return tile_type values starting with the
;			the tile after GMAP.LOOKUP and this routine assumes you want the tile_type associated with GMAP.LOOKUP
;
;			The value of the offsets constants were calculated using the TILE.LOOKUP.INDEX assumption.
;			Currently this different is handled with a single INC OP2 in the TILE.LOOKUP.COLUMN routine
;			It may be possible to eliminte this different by adjusting the way the overflow is calcualted
;			in TILE.LOOKUP.INDEX. Maybe if the final overflow value (/aka pickup value) is increased by one
;			and if the initial trigger for determining an overflow was based on GMAP.LOOKUP -1. 
;			The key would be is that when GMAP.TALLY >= GMAP.LOOKUP, 1 tile needs to be treated as a pickup value in 
;			in the TILE.LOOKUP.ROW routine. The easiest way to do that is probably to check for GMAP.TALLY >= GMAP.LOOKUP-1


;WARNING: GMAP.LOOKUP is a 16-bit number. If using this routine via a driver with an 8 bit number make sure to init
;GMAP.LOOKUP+$1 to $00.


;save registeres
	STA SAVED.ACC.LOCAL
	TYA
	PHA

;init variables
	
	LDA SAVED.ACC.LOCAL
	CMP #$00						;use existing index?
	BEQ	.START						

	LDA #$00
	STA GMAP.TALLY
	STA GMAP.TALLY+$1
	STA GMAP.INDEX.HO
	
	LDA #GMAP.TILE.DATA				;START INDEX AT FIRST ELEMENT OF GMAP.TILE.DATA
	STA GMAP.ADDRESS.INDEX
	LDA /GMAP.TILE.DATA
	STA GMAP.ADDRESS.INDEX+$1
	
	LDY #$00
		
	JMP .START2		

.START								;USE EXISTING INDEX (PICKUP WHERE THIS ROUTINE LEFT OFF INTERATING THROUGH THE GMAP.TILE.DATA ARRAY
	LDY GMAP.INDEX.LO
	
;init variables

;NONE: If #$00 is passed via X-REG, then the routine will use the preexisting GMAP.TALLY, GMAP.ADDRESS.INDEX and 
;Y-REG values to pickup up where it left off. 

;Identify the position in the compressed data associated with the uncompressed position lookup	

.START2



.LOOP.LOOKUP
;ADD TILE_QTY VALUE IN CURRENT TILE PAIR TO THE TALLY
	LDA (GMAP.ADDRESS.INDEX),Y				;**OPT** TO OPTIMIZE FOR SPEED, MAY BE ABLE TO SETUP A BRANCH SO THAT THE 16-BIT ADD IS ONLY DONE WHEN A 16-BIT VALUE IS PRESENT IN OP1 OR OP2. 
	STA OP1
	LDA GMAP.TALLY
	STA OP2
	
	LDA GMAP.TALLY+$1
	STA OP2+$1
	LDA #$00
	STA OP1+$1
	
	JSR ADC.16					;GMAP.TILE.DATA,X + GMAP.TALLY(2)
	
	LDA RESULT
	STA GMAP.TALLY
	STA OP1
	LDA RESULT+$1
	STA GMAP.TALLY+$1
	STA OP1+$1

;IS TALLY >= LOOKUP VALUE?	
	LDA GMAP.LOOKUP
	STA OP2
	LDA GMAP.LOOKUP+$1
	STA OP2+$1
	JSR IGRE.16					;GMAP.TALLY(2) IGRE GMAP.LOOKUP(2)		
	
	BCS .TILE.FOUND

;INCREMENT COUNTERS	
	INY							;ADVANCE TO NEXT TILE PAIR. Y-REG IS THE LO BYTE OF GMAP.INDEX FOR THE DURATION OF THIS LOOP
	INY							;EVEN THOUGH IT'S A 2 BYTE INY, IT WILL ADVANCE FROM !254 TO 0, THUS BNE WILL DETECT THE FLIP. 

;.TEMP

	BNE .NO.FLIP
	INC GMAP.ADDRESS.INDEX+$1
	INC GMAP.INDEX.HO			;**OPT** (a counter to help troubleshooting, comment out this line at least. If removed, also remove the definition for GMAP.INDEX.HO and GMAP.INDEX.LO. There are 3 lines like this in the program, two for HO and one for LO. 
.NO.FLIP
		 
	JMP .LOOP.LOOKUP	
	
.TILE.FOUND	
	
	INY							;ADVANCE ONE ELEMENT BECAUSE TILE_TYPE COMES IMMEDIATELY AFTER TILE_QUANTITY
	LDA (GMAP.ADDRESS.INDEX),Y	;LOAD TILE_TYPE
	DEY							;RETURN Y TO PREVIOUS VALUE SO THAT Y IS ALIGNED WITH TILE_QTY IN NEXT ITERATION 
	
			;TROUBLESHOOTING HOOK 2
			;Y-REG and GMAP.INDEX.HO correspond to the LO/HO value of the GMAP.TILE.DATA array element that was loaded. 
			;GMAP.ADDRESS.INDEX, offset by Y-REG, corresponds to the memory address loaded from GMAP.TILE.DATA.

					
			;LDA GMAP.LOOKUP
			;CMP #$86
			;BNE .TEMP3
			;LDA TEXT
			;LDA PAGE1
			;BRK
;.TEMP3	

	INY		;**OPT** Speed Memory the DEY above and one of these INYs could be consolidated
	INY
	BNE .NO.FLIP2
	INC GMAP.ADDRESS.INDEX+$1
	INC GMAP.INDEX.HO			;**OPT** (a counter to help troubleshooting, comment out this line at least. If removed, also remove the definition for GMAP.INDEX.HO and GMAP.INDEX.LO. There are 3 lines like this in the program, two for HO and one for LO. 
.NO.FLIP2
	
	STY GMAP.INDEX.LO			;If this routine is called again, Y-REG needs to be set to the index that the current iteration ended at
	STA SAVED.ACC.LOCAL

;restore registers
	PLA	
	TAY
	
	RTS


;======INCLUDE FILES======

;NONE
	

				
;==========================DEFINE VARIABLES======================

;this array was modified to convert the $0A values to $09 for compatability with the spreadsheet analysis tool. Thus, it's not precicesly a 64x64 array. that could be tweaked in the speadsheet and copied back to the source code if useful to have the production array also match the spreadsheet analysis tool.
;lookup value			       10  	 x	    	 	        +17 (overfllow 2)                 ??+17 (extra 1)
;tile qty				 q	   q	 q     q     q     q     q    q     q      q     q     q     q     q  																																																																																																																																																																												?									         
;GMAP.TILE.DATA 		.HS	05.00.05.01.01.08.05.00.05.00.05.00.01.08.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.03.03.09.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.03.00
;array elements			00.01.02.03.04.05.06.07.08.09.0A.0B.0C.0D.0E.0F.10.11.12.13.14.15.16.17.18.19.1A.1B.1C.1D.1E.1F.20.21.22.23.24.25.26.27.28.29.2A.2B.2C.2D.2E.2F.30.31.32.33.34.35.36.37.38.39.3A.3B.3C.3D.3E.3F.40.41.42.43.44.45.46.47.48.49.4A.4B.4C.4D.4E.4F.50.51.52.53.54.55.56.57.58.59.5A.5B.5C.5D.5E.5F.60.61.62.63.64.65.66.67.68.69.6A.6B.6C.6D.6E.6F.70.71.72.73.74.75.76.77.78.79.7A.7B.7C.7D.7E.7F.80.81.82.83.84.85.86.87.88.89.8A.8B.8C.8D.8E.8F.90.91.92.93.94.95.96.97.98.99.9A.9B.9C.9D.9E.9F.A0.A1.A2.A3.A4.A5.A6.A7.A8.A9.AA.AB.AC.AD.AE.AF.B0.B1.B2.B3.B4.B5.B6.B7.B8.B9.BA.BB.BC.BD.BE.BF.C0.C1.C2.C3.C4.C5.C6.C7.C8.C9.CA.CB.CC.CD.CE.CF.D0.D1.D2.D3.D4.D5.D6.D7.D8.D9.DA.DB.DC.DD.DE.DF.E0.E1.E2.E3.E4.E5.E6.E7.E8.E9.EA.EB.EC.ED.EE.EF.F0.F1.F2.F3.F4.F5.F6.F7.F8.F9.FA.FB.FC.FD.FE.FF.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01
;																																																																																																																																																																																																						00.01.02.03.04.05.06.07.08.09.0A.0B.0C.0D.0E.0F.10.11.12.13.14.15.16.17.18.19.1A.1B.1C.1D.1E.1F.20.21.22.23.24.25.26.27.28.29.2A.2B.2C.   								

;use for testing movement, this is 64x64 tiles. But, before using, use replace to convert the 0A values to 09 so it's compatible with the analyis spreadsheet
;GMAP.TILE.DATA 		.HS	05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.00
;


;************************INCLUDE FILE*****************************
;(do not assemble stand-alone. For a stand-alone version of this routine see examples/rwts2)


LOAD.NEW.LOCATION	; ==========LOADS NEW SHAPE TABLES FROM DISK INTO AUX=====
;PARAMETERS: PLAYER.MAP.LOCATION_CODE, PLAYER.MAP.LOCATION_TYPE
;RETURN: updated shape tables and map data
;ENTRANCE: DIRECT

	;JMP LOAD.NEW.MAP
LOAD.NEW.SHAPES
@START
	LDA PLAYER.MAP.LOCATION_TYPE
	CMP #LOCATION.TYPE.SURFACE
	BEQ .LOCATION_TYPE.SURFACE	
	CMP #LOCATION.TYPE.BUILDING
	BEQ .LOCATION_TYPE.BUILDING	
	CMP #LOCATION.TYPE.UNDERMAP
	BEQ .LOCATION_TYPE.BUILDING ;**TEMPORARILY DUNGEONS USE THE BUILDING TILE SET. 
	
	
.ERROR
;UNEXPECTED LOCATION TYPE DETECTED IN LOAD.NEW.SHAPES
	LDA TEXT
	LDA $C082
	BRK

	
.LOCATION_TYPE.SURFACE
@START

;INITIAL VARIABLES & COUNTERS
	LDA #DATA.SHAPES.SURFACE2.TOTAL.SECTORS
	STA TOTAL.SECTORS
	
;SETUP MY.RWTS VARIABLES
	LDA #$02
    STA DRIVE
		
    LDA #DATA.SHAPES.SURFACE2.START.TRACK
    STA TRK.SRT   
	STA TRK.SRT.COUNTER
	
    LDA #DATA.SHAPES.SURFACE2.START.SECTOR
    STA SEC.SRT
	STA SEC.SRT.COUNTER
	
	LDA #DATA.SHAPES.SURFACE2.START.TRACK
	STA TRK.END
	STA TRK.END.COUNTER
    LDA #DATA.SHAPES.SURFACE2.START.SECTOR
	STA SEC.END
    STA SEC.END.COUNTER
	
;SETUP AUX MEMORY DESTINATION ADDRESS
	LDA #SHP.TBL.START.ADDRESS			;SET DESTINATION ADDRESS/LO BYTE
	STA AUX.WRITE_ADDRESS.START			
	STA AUX_MOVE.DEST
	
	LDA /SHP.TBL.START.ADDRESS			;SET DESTINATION ADDRESS/HO BYTE
	STA AUX.WRITE_ADDRESS.START+$1
	STA AUX_MOVE.DEST+$1

	LDA #NEW.SHAPES
	STA DISK.IO.BUFFER

	LDA /NEW.SHAPES
	STA DISK.IO.BUFFER+$1
			
	JMP .CALL.LOADER
@END
	
.LOCATION_TYPE.BUILDING
@START
;INITIAL VARIABLES & COUNTERS
	LDA #DATA.SHAPES.BUILDING.TOTAL.SECTORS
	STA TOTAL.SECTORS

;SETUP MY.RWTS VARIABLES
	LDA #$02
    STA DRIVE
		
    LDA #DATA.SHAPES.BUILDING.START.TRACK
    STA TRK.SRT   
	STA TRK.SRT.COUNTER
	
    LDA #DATA.SHAPES.BUILDING.START.SECTOR
    STA SEC.SRT
	STA SEC.SRT.COUNTER
	
	LDA #DATA.SHAPES.BUILDING.START.TRACK
	STA TRK.END
	STA TRK.END.COUNTER
    LDA #DATA.SHAPES.BUILDING.START.SECTOR
	STA SEC.END
    STA SEC.END.COUNTER
	
;SETUP AUX MEMORY DESTINATION ADDRESS
	LDA #SHP.TBL.START.ADDRESS			;SET DESTINATION ADDRESS/LO BYTE
	STA AUX.WRITE_ADDRESS.START			
	STA AUX_MOVE.DEST
	LDA /SHP.TBL.START.ADDRESS			;SET DESTINATION ADDRESS/HO BYTE
	STA AUX.WRITE_ADDRESS.START+$1
	STA AUX_MOVE.DEST+$1

	LDA #NEW.SHAPES
	STA DISK.IO.BUFFER

	LDA /NEW.SHAPES
	STA DISK.IO.BUFFER+$1
	
	JMP .CALL.LOADER
@END


.LOCATION_TYPE.DUNGEON


;LOCATION_TYPE.02
;LOCATION_TYPE.03
;ETC	
	
.CALL.LOADER
		
			LDA #$01		;skipping $01 header sector because the data to be read from disk was written to disk by Apple Commander which adds a header. 
		JSR DISK.READ.AUX
@END

LOAD.NEW.MAP
@START
	LDA PLAYER.MAP.LOCATION
	CMP #$00
	BEQ LOCATION_CODE.00
	CMP #$01
	BEQ LOCATION_CODE.01
	CMP #$02
	BEQ .LOCATION_CODE.02_STEP
	
.ERROR
;UNEXPECTED LOCATION TYPE DETECTED IN LOAD.NEW.SHAPES
	LDA TEXT
	LDA $C082
	BRK

.LOCATION_CODE.02_STEP
	JMP LOCATION_CODE.02
	
LOCATION_CODE.00
;INITIAL VARIABLES & COUNTERS
	LDA #DATA.MAP.SURFACE.TOTAL.SECTORS
	STA TOTAL.SECTORS

;SETUP MY.RWTS VARIABLES
		;SETUP MY.RWTS VARIABLES
		;
		LDA #$02
		STA DRIVE
		;	
		LDA #DATA.MAP.SURFACE.START.TRACK
		STA TRK.SRT   
		STA TRK.SRT.COUNTER
		STA TRK.END
		STA TRK.END.COUNTER
		;
		LDA #DATA.MAP.SURFACE.START.SECTOR
		STA SEC.SRT
		STA SEC.SRT.COUNTER
		STA SEC.END
		STA SEC.END.COUNTER	
		;
		;SETUP AUX MEMORY DESTINATION ADDRESS
		LDA #WORLD.COMPRESS.AUX_MEMORY.START_LO	;SET DESTINATION ADDRESS/LO BYTE
		STA AUX.WRITE_ADDRESS.START			
		STA AUX_MOVE.DEST
		LDA #WORLD.COMPRESS.AUX_MEMORY.START_HO	;SET DESTINATION ADDRESS/HO BYTE
		STA AUX.WRITE_ADDRESS.START+$1
		STA AUX_MOVE.DEST+$1
		;
		LDA #NEW.MAP
		STA DISK.IO.BUFFER
		;
		LDA /NEW.MAP
		STA DISK.IO.BUFFER+$1

		LDA #$01		;skipping $01 header sector because the data to be read from disk was written to disk by Apple Commander which adds a header. 
	JSR DISK.READ.AUX	

	DEC TOTAL.SECTORS ;decrement to exclue header sector, because that wasn't loaded into aux memory)				
	JSR ZONE_TOOLS.BUILD.WZONE_HEADERS
	
	JSR REGION.UNCOMPRESS.ALL				;Load surface map, it is stored in auxiliary memory.
	RTS
	
	
LOCATION_CODE.01
@START

;INITIAL VARIABLES & COUNTERS
	LDA #DATA.MAP.L1.TOTAL.SECTORS
	STA TOTAL.SECTORS
	
;SETUP MY.RWTS VARIABLES
	LDA #$01
    STA CMD.CODE
	LDA #$02
    STA DRIVE
		
    LDA #DATA.MAP.L1.START.TRACK	
    STA TRK.SRT   
	STA TRK.SRT.COUNTER
	
    LDA #DATA.MAP.L1.START.SECTOR	
    STA SEC.SRT
	STA SEC.SRT.COUNTER
	
	LDA #DATA.MAP.L1.START.TRACK	
	STA TRK.END
	STA TRK.END.COUNTER
    LDA #DATA.MAP.L1.START.SECTOR	
	STA SEC.END
    STA SEC.END.COUNTER


	JMP LOOP.LOAD.ENTRANCE
@END

		; LDA #$01		;skipping $01 sector because the data to be read from disk was written to disk by Apple Commander which adds a header. 
		; JSR DISK.READ.AUX
LOCATION_CODE.02
@START

;<INSERT CODE TO THAT WILL RESULT IN NEW COMPRESSED
;MAP DATA BEING LOADED INTO AUX MEMORY>

; 					.EQ $19	;#CONSTANT
; DATA.MAP.UNDERMAP_LV1.SECTOR				.EQ $0C	;#CONSTANT
; 			.EQ $20 ;#CONSTANT

;INITIAL VARIABLES & COUNTERS
	LDA #DATA.MAP.UNDERMAP_LV1.TOTAL.SECTORS
	STA TOTAL.SECTORS

;SETUP MY.RWTS VARIABLES
		;SETUP MY.RWTS VARIABLES
		;
		LDA #$02
		STA DRIVE
		;	
		LDA #DATA.MAP.UNDERMAP_LV1.TRACK
		STA TRK.SRT   
		STA TRK.SRT.COUNTER
		STA TRK.END
		STA TRK.END.COUNTER
		;
		LDA #DATA.MAP.UNDERMAP_LV1.SECTOR
		STA SEC.SRT
		STA SEC.SRT.COUNTER
		STA SEC.END
		STA SEC.END.COUNTER	
		;
		;SETUP AUX MEMORY DESTINATION ADDRESS
		LDA #WORLD.COMPRESS.AUX_MEMORY.START_LO	;SET DESTINATION ADDRESS/LO BYTE
		STA AUX.WRITE_ADDRESS.START			
		STA AUX_MOVE.DEST
		LDA #WORLD.COMPRESS.AUX_MEMORY.START_HO	;SET DESTINATION ADDRESS/HO BYTE
		STA AUX.WRITE_ADDRESS.START+$1
		STA AUX_MOVE.DEST+$1
		;
		LDA #NEW.MAP
		STA DISK.IO.BUFFER
		;
		LDA /NEW.MAP
		STA DISK.IO.BUFFER+$1

		LDA #$01		;skipping $01 header sector because the data to be read from disk was written to disk by Apple Commander which adds a header. 
	JSR DISK.READ.AUX	

	DEC TOTAL.SECTORS ;decrement to exclue header sector, because that wasn't loaded into aux memory)				
	JSR ZONE_TOOLS.BUILD.WZONE_HEADERS
	
	JSR REGION.UNCOMPRESS.ALL				;Load surface map, it is stored in auxiliary memory.
	RTS	
@END


;LOCATION_CODE.02	
;LOCATION_CODE.03
;ETC


	
LOOP.LOAD.ENTRANCE
@START
	LDA TROUBLESHOOTING.HOOK
	CMP #$01
	BNE .TEMP
	LDA TEXT
	LDA $C082
	BRK
.TEMP

;INIT VARIABLES
	LDX #$01						;COUNTER:  TOTAL SECTORS READ. START AT $01 BECAUSE 1ST SECTOR IS GARBAGE DATA)

	LDA #RZONE.ARRAY			;INIT BASE ADDRESS FOR RZONE ARRAY HO BYTE INDEX			
	STA RZONE.ARRAY.INDEX_ROW
				 
	LDA /RZONE.ARRAY						
	STA RZONE.ARRAY.INDEX_ROW+$1

	LDA #$00					;SET STARTING REGIONAL ZONE
	STA RZONE.UNCOMPRESS.CURRENT
	
	
.LOOP.LOAD		
;INCREMENT MY.RWTS COUNTERS	 (DONE AT FRONT END BECAUSE 1ST SECTOR IS GARBAGE DATA)
	INC SEC.SRT.COUNTER
	LDA SEC.SRT.COUNTER
	CMP #$10
	BCC .NO_FLIP1.1
	INC TRK.SRT.COUNTER
	LDA TRK.SRT.COUNTER
	STA TRK.SRT
	LDA #$00
	STA SEC.SRT.COUNTER	
.NO_FLIP1.1
	STA SEC.SRT
	INC SEC.END.COUNTER
	LDA SEC.END.COUNTER
	CMP #$10
	BCC .NO_FLIP2.1
	INC TRK.END.COUNTER
	LDA TRK.END.COUNTER
	STA TRK.END	
	LDA #$00
	STA SEC.END.COUNTER	
.NO_FLIP2.1
	STA SEC.END
	
.SKIP.INCREMENT.COUNTERS
	;my.rwts increments dest.addr so it must be set before each call
    LDA #NEW.MAP
    STA DEST.ADDR					;LO
												
    LDA /NEW.MAP
    STA DEST.ADDR+$1               	;HO


;SKIP DOS RESERVED TRACKS/SECTORS
;Note: Applecommander skips track !17 ($11) and track !18, seconds 14 & 15 ($T12,$E & $D)
;I'm almost postive this is becasue AppleCommander is writing data to the disk assuming a DOS format.
;I'm almost postive these tracks/sectors are reserved by DOS. I recall reading somethig about it in Beneath DOS
;and specifically recall the reserve space being near the middle of the disk. It was for catalog information or something. 

;DOS TRACK/SECTOR CHECKS	
	LDA TRK.SRT
	CMP #$11
	BEQ .LOOP.LOAD
	CMP #$12
	BNE .CONTINUE
	LDA SEC.SRT
	CMP #$0E
	BEQ .LOOP.LOAD
	CMP #$0F
	BEQ .LOOP.LOAD
.CONTINUE
	
;READ NEXT SECTOR FROM DISK & WRITE TO REGIONAL MAP
	LDA #$00						;TURN OFF DOS TRACK/SECTOR OVERRIDE
	JSR MY.RWTS

	JSR ZONE_TOOLS.RCOPY					;COPY DATA FROM OUTPUT BUFFER INTO REGIONAL ZONE ARRAY, INTO THE ARRAY ELEMENTS FOR THE CURRENT ZONE

;INCREMENT RZONE INDEX & COUNTER
	INC RZONE.ARRAY.INDEX_ROW+$1	;INCREMENT RZONE HO BYTE INDEX
	INC RZONE.UNCOMPRESS.CURRENT	;INCREMENT ZONE COUNTER

			; CPX #$02
			; BNE .TEMP
			; LDA TEXT
			; LDA $C082
			; ;LDA (DEST.ADDR),Y
			; LDX RZONE.ARRAY.INDEX_ROW
			; LDY RZONE.ARRAY.INDEX_ROW+$1
			; BRK
; .TEMP	
		
	INX 							;INCREMENT TOTAL SECTORS READ	
	CPX TOTAL.SECTORS
	BEQ .EXIT
	JMP .LOOP.LOAD

.EXIT
	
				; LDA TEXT
				; ; LDX #SHP.TBL.ADDRESS.COUNTER
				; ; LDY /SHP.TBL.ADDRESS.COUNTER
				; LDA $C082
				; BRK
		
	RTS		
@END
@END	


MAP.CALCULATE.SS_FLAGS ;CALCUALTE SS MAP REGIONAL FLAGS BASED ON RMAP.X/Y 
@START
;PARAMETERS: RMAP.X, RMAP.Y
;RETURN: MAP_OBJECTS.SS.X_FLAG.UPPER, MAP_OBJECTS.SS.Y_FLAG.UPPER, MAP_OBJECTS.SS.X_FLAG.LOWER, MAP_OBJECTS.SS.Y_FLAG.LOWER
;ENTRANCE: DIRECT

;Note: the principle in play is that flags to detect when a mob x,y value (relative to the player) is off the 
;regional map needs to float depending on the player position withing the region. 
	
	LDA RMAP.X												;PLAYER'S REGIONAL MAP X-AXIS POSITION
	CMP #RZONE.LOAD.X.START									;X-AXIS VALUE WHEN PLAYER IS CENTERED IN REGI0NAL MAP
	BCC .XLESS
	
	LDA RMAP.X		
	SEC
	SBC #RZONE.LOAD.X.START
	STA MAP_OBJECTS.X_ADJ
	
	LDA #MAP_OBJECTS.SS.X_FLAG.LOWER.START					;LEFT EDGE OF REGION WHEN PLAYER IS CENTERED IN REGIONAL MAP
	SEC
	SBC MAP_OBJECTS.X_ADJ
	STA MAP_OBJECTS.SS.X_FLAG.LOWER

	LDA #MAP_OBJECTS.SS.X_FLAG.UPPER.START					;RIGHT EDGE OF REGION WHEN PLAYER IS CENTERED IN REGIONAL MAP
	SEC
	SBC MAP_OBJECTS.X_ADJ
	STA MAP_OBJECTS.SS.X_FLAG.UPPER
	
	
	JMP .YTEST
	
.XLESS	
	LDA #RZONE.LOAD.X.START									;X-AXIS VALUE WHEN PLAYER IS CENTERED IN REGI0NAL MAP
	SEC
	SBC RMAP.X	
	STA MAP_OBJECTS.X_ADJ
	
	LDA #MAP_OBJECTS.SS.X_FLAG.LOWER.START					;LEFT EDGE OF REGION WHEN PLAYER IS CENTERED IN REGIONAL MAP
	CLC
	ADC MAP_OBJECTS.X_ADJ
	STA MAP_OBJECTS.SS.X_FLAG.LOWER
	
	LDA #MAP_OBJECTS.SS.X_FLAG.UPPER.START					;RIGHT EDGE OF REGION WHEN PLAYER IS CENTERED IN REGIONAL MAP
	CLC
	ADC MAP_OBJECTS.X_ADJ
	STA MAP_OBJECTS.SS.X_FLAG.UPPER						
	;**FALLS THROUGH**
	
.YTEST
	LDA RMAP.Y												;PLAYER'S REGIONAL MAP X-AXIS POSITION
	CMP #RZONE.LOAD.Y.START									;X-AXIS VALUE WHEN PLAYER IS CENTERED IN REGI0NAL MAP
	BCC .YLESS
	
	LDA RMAP.Y		
	SEC
	SBC #RZONE.LOAD.Y.START
	STA MAP_OBJECTS.Y_ADJ
	
	LDA #MAP_OBJECTS.SS.Y_FLAG.LOWER.START					;BOTTOM EDGE OF REGION WHEN PLAYER IS CENTERED IN REGIONAL MAP
	SEC
	SBC MAP_OBJECTS.Y_ADJ
	STA MAP_OBJECTS.SS.Y_FLAG.LOWER

	LDA #MAP_OBJECTS.SS.Y_FLAG.UPPER.START					;TOP EDGE OF REGION WHEN PLAYER IS CENTERED IN REGIONAL MAP
	SEC
	SBC MAP_OBJECTS.Y_ADJ
	STA MAP_OBJECTS.SS.Y_FLAG.UPPER
	
	
	JMP .DONE1
	
.YLESS	
	LDA #RZONE.LOAD.Y.START									;Y-AXIS VALUE WHEN PLAYER IS CENTERED IN REGI0NAL MAP
	SEC
	SBC RMAP.Y	
	STA MAP_OBJECTS.Y_ADJ
	
	LDA #MAP_OBJECTS.SS.Y_FLAG.LOWER.START					;BOTTOM EDGE OF REGION WHEN PLAYER IS CENTERED IN REGIONAL MAP
	CLC
	ADC MAP_OBJECTS.Y_ADJ
	STA MAP_OBJECTS.SS.Y_FLAG.LOWER
	
	LDA #MAP_OBJECTS.SS.Y_FLAG.UPPER.START					;TOP EDGE OF REGION WHEN PLAYER IS CENTERED IN REGIONAL MAP
	CLC
	ADC MAP_OBJECTS.Y_ADJ
	STA MAP_OBJECTS.SS.Y_FLAG.UPPER	
.DONE1
	RTS
@END


;CALCULATE DISTANCE BETWEEN X,Y COORDINATES
;see .CALCULATE.DISTANCE (NPC.PATHFINDER)
;(designed for RMAP/GMAP but may work for player relative X,Y too)


CONVERT.GMAP_XY.RMAP_XY ;CONVERTS A PLAYER START GMAP.XY VALUE INTO AN RMAP.XY 
@START
;PARAMETERS: PARM.GMAP.X, PARM.GMAP.Y
;RETURN: RETURN.RMAP.X, RETURN.RMAP.Y
;ENTRANCE: DIRECT

;FORUMLA: RMAP.XY = $10 + REMAINDER(GMAP.XY/#WZONE.SIZE)
;Note: $10 is the starting x/y value in the upper left corner of the center RZONE.
;The player will start in the center RZONE once arriving at the destination location so we can make this assumption. 
	
	LDA PARM.GMAP.X
	STA DIVIDEND

	LDA #$00
	STA DIVIDEND+$1
	LDA	#WZONE.SIZE
	STA DIVISOR
	LDA #$00
	STA DIVISOR+$1
	STA DIVIDEND32
	STA DIVIDEND32+$1
		
	JSR DIV.16						;**OPT** Speed. Replace with in-line code
	
	LDA RESULT+$2					;REMAINDER
	STA TEMPX							
	
	LDA TEMPX
	CLC
	ADC #WZONE.SIZE
	STA RETURN.RMAP.X
	
	
	LDA PARM.GMAP.Y
	STA DIVIDEND
	LDA #$00
	STA DIVIDEND+$1
	LDA	#WZONE.SIZE
	STA DIVISOR
	LDA #$00
	STA DIVISOR+$1
	
	JSR DIV.16						;**OPT** Speed. Replace with in-line code
	
	LDA RESULT+$2					;REMAINDER 
	STA TEMPY						;**OPT** Speed. Memory. TEMPY isn't really needed just use RESULT for next calculation	
	
	LDA TEMPY	
	CLC
	ADC #WZONE.SIZE
	STA RETURN.RMAP.Y

	RTS
@END
	

CONVERT.RMAP_XY.RMAP
@START
;PARAMETERS: PARM.RMAP.X, PARM.RMAP.Y
;RETURN: RETURN.RMAP(2)
;ENTRANCE: DIRECT

	LDY PARM.RMAP.Y
	LDA RMAP.MULTIPLY_TABLE.HO,Y
	STA RETURN.RMAP+$1
	LDA RMAP.MULTIPLY_TABLE.LO,Y
	STA RETURN.RMAP

;16-BIT ADD
	CLC
	ADC PARM.RMAP.X
	STA RETURN.RMAP					
	LDA RETURN.RMAP+$1
	ADC #$00
	STA RETURN.RMAP+$1
	
	RTS
	
@END

CONVERT.GMAP_XY.WZONE
@START
;PARAMETERS: PARM.GMAP.X, PARM.GMAP.Y
;RETURN: RETURN.WZONE
;ENTRANCE: DIRECT

;FORMULA: WZONE = (GMAP.Y/#WZONE.SIZE * #WZONE OFFSET)+(GMAP.X/#WZONE.SIZE)
;	Remainder form division is discarded, only use quotient. 


	LDA PARM.GMAP.Y
	STA DIVIDEND
	LDA #$00
	STA DIVIDEND+$1
	LDA	#WZONE.SIZE
	STA DIVISOR
	LDA #$00
	STA DIVISOR+$1
	
	JSR DIV.16						;**OPT** Speed. Replace with in-line code
	
	LDA RESULT						;QUOTIENT
	ASL	;X2
	ASL ;X4
	ASL ;X8
	STA TEMPY
	
	LDA PARM.GMAP.X
	STA DIVIDEND

	LDA #$00
	STA DIVIDEND+$1
	LDA	#WZONE.SIZE
	STA DIVISOR
	LDA #$00
	STA DIVISOR+$1
	STA DIVIDEND32
	STA DIVIDEND32+$1
		
	JSR DIV.16						;**OPT** Speed. Replace with in-line code
	
	LDA RESULT						;QUOTIENT
	CLC
	ADC TEMPY
	STA RETURN.WZONE
	
	RTS
	

@END

;.CONVERT.GMAP.TO.PLAYER_RELATIVE.XY
; see .CONVERT.GMAP.TO.PLAYER_RELATIVE.XY (MAP_OBJECTS.MANAGEMENT>)


;CONVERT COLUMN,ROW TO SCREEN ARRAY INDEX 
;(I think this is already done via a lookup table, no subroutine needed)

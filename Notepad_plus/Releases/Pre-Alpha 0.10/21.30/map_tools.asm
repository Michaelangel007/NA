;************************INCLUDE FILE*****************************
;(do not assemble stand-alone. For a stand-alone version of this routine see examples/rwts2)


LOAD.NEW.LOCATION	; ==========LOADS NEW SHAPE TABLES FROM DISK INTO AUX=====
;PARAMETERS: PLAYER.MAP.LOCATION_CODE, PLAYER.MAP.LOCATION_TYPE
;RETURN: updated shape tables and map data
;ENTRANCE: DIRECT

LOAD.NEW.SHAPES
@START
	LDA PLAYER.MAP.LOCATION_TYPE
	CMP #LOCATION.TYPE.SURFACE
	BEQ .LOCATION_TYPE.SURFACE	
	CMP #LOCATION.TYPE.BUILDING
	BEQ .LOCATION_TYPE.BUILDING	
	CMP #LOCATION.TYPE.UNDERMAP
	BEQ .LOCATION_TYPE.BUILDING ;**TEMPORARILY DUNGEONS USE THE BUILDING TILE SET. 
	
	
.ERROR
;UNEXPECTED LOCATION TYPE DETECTED IN LOAD.NEW.SHAPES
	LDA TEXT
	LDA $C082
	BRK

	
.LOCATION_TYPE.SURFACE
@START

;INITIAL VARIABLES & COUNTERS
	LDA #DATA.SHAPES.SURFACE2.TOTAL.SECTORS
	STA TOTAL.SECTORS
	
;SETUP MY.RWTS VARIABLES
	LDA #$02
    STA DRIVE
		
    LDA #DATA.SHAPES.SURFACE2.START.TRACK
    STA TRK.SRT   
	STA TRK.SRT.COUNTER
	
    LDA #DATA.SHAPES.SURFACE2.START.SECTOR
    STA SEC.SRT
	STA SEC.SRT.COUNTER
	
	LDA #DATA.SHAPES.SURFACE2.START.TRACK
	STA TRK.END
	STA TRK.END.COUNTER
    LDA #DATA.SHAPES.SURFACE2.START.SECTOR
	STA SEC.END
    STA SEC.END.COUNTER
	
;SETUP AUX MEMORY DESTINATION ADDRESS
	LDA #SHP.TBL.START.ADDRESS			;SET DESTINATION ADDRESS/LO BYTE
	STA AUX.WRITE_ADDRESS.START			
	STA AUX_MOVE.DEST
	
	LDA /SHP.TBL.START.ADDRESS			;SET DESTINATION ADDRESS/HO BYTE
	STA AUX.WRITE_ADDRESS.START+$1
	STA AUX_MOVE.DEST+$1

	LDA #NEW.SHAPES
	STA DISK.IO.BUFFER

	LDA /NEW.SHAPES
	STA DISK.IO.BUFFER+$1
			
	JMP .CALL.LOADER
@END
	
.LOCATION_TYPE.BUILDING
@START
;INITIAL VARIABLES & COUNTERS
	LDA #DATA.SHAPES.BUILDING.TOTAL.SECTORS
	STA TOTAL.SECTORS

;SETUP MY.RWTS VARIABLES
	LDA #$02
    STA DRIVE
		
    LDA #DATA.SHAPES.BUILDING.START.TRACK
    STA TRK.SRT   
	STA TRK.SRT.COUNTER
	
    LDA #DATA.SHAPES.BUILDING.START.SECTOR
    STA SEC.SRT
	STA SEC.SRT.COUNTER
	
	LDA #DATA.SHAPES.BUILDING.START.TRACK
	STA TRK.END
	STA TRK.END.COUNTER
    LDA #DATA.SHAPES.BUILDING.START.SECTOR
	STA SEC.END
    STA SEC.END.COUNTER
	
;SETUP AUX MEMORY DESTINATION ADDRESS
	LDA #SHP.TBL.START.ADDRESS			;SET DESTINATION ADDRESS/LO BYTE
	STA AUX.WRITE_ADDRESS.START			
	STA AUX_MOVE.DEST
	LDA /SHP.TBL.START.ADDRESS			;SET DESTINATION ADDRESS/HO BYTE
	STA AUX.WRITE_ADDRESS.START+$1
	STA AUX_MOVE.DEST+$1

	LDA #NEW.SHAPES
	STA DISK.IO.BUFFER

	LDA /NEW.SHAPES
	STA DISK.IO.BUFFER+$1
	
	JMP .CALL.LOADER
@END


.LOCATION_TYPE.DUNGEON


;LOCATION_TYPE.02
;LOCATION_TYPE.03
;ETC	
	
.CALL.LOADER
		
			LDA #$01		;skipping $01 header sector because the data to be read from disk was written to disk by Apple Commander which adds a header. 
		JSR DISK.READ.AUX
@END

LOAD.NEW.MAP
@START
	LDA PLAYER.MAP.LOCATION
	CMP #$00
	BEQ LOCATION_CODE.00
	CMP #$01
	BEQ LOCATION_CODE.01
	CMP #$02
	BEQ LOCATION_CODE.02
	
.ERROR
;UNEXPECTED LOCATION TYPE DETECTED IN LOAD.NEW.SHAPES
	LDA TEXT
	LDA $C082
	BRK


LOCATION_CODE.00
	JSR REGION.UNCOMPRESS.ALL				;Load surface map, it is stored in auxiliary memory.
	RTS
	
	
LOCATION_CODE.01
@START

;INITIAL VARIABLES & COUNTERS
	LDA #DATA.MAP.L1.TOTAL.SECTORS
	STA TOTAL.SECTORS
	
;SETUP MY.RWTS VARIABLES
	LDA #$01
    STA CMD.CODE
	LDA #$02
    STA DRIVE
		
    LDA #DATA.MAP.L1.START.TRACK	
    STA TRK.SRT   
	STA TRK.SRT.COUNTER
	
    LDA #DATA.MAP.L1.START.SECTOR	
    STA SEC.SRT
	STA SEC.SRT.COUNTER
	
	LDA #DATA.MAP.L1.START.TRACK	
	STA TRK.END
	STA TRK.END.COUNTER
    LDA #DATA.MAP.L1.START.SECTOR	
	STA SEC.END
    STA SEC.END.COUNTER


	JMP LOOP.LOAD.ENTRANCE
@END

		; LDA #$01		;skipping $01 sector because the data to be read from disk was written to disk by Apple Commander which adds a header. 
		; JSR DISK.READ.AUX
LOCATION_CODE.02
@START

;<INSERT CODE TO THAT WILL RESULT IN NEW COMPRESSED
;MAP DATA BEING LOADED INTO AUX MEMORY>


;LOCATION_CODE.02	
;LOCATION_CODE.03
;ETC	
@END
	
LOOP.LOAD.ENTRANCE
@START

;INIT VARIABLES
	LDX #$01						;COUNTER:  TOTAL SECTORS READ. START AT $01 BECAUSE 1ST SECTOR IS GARBAGE DATA)

	LDA #RZONE.ARRAY			;INIT BASE ADDRESS FOR RZONE ARRAY HO BYTE INDEX			
	STA RZONE.ARRAY.INDEX_ROW
				 
	LDA /RZONE.ARRAY						
	STA RZONE.ARRAY.INDEX_ROW+$1

	LDA #$00					;SET STARTING REGIONAL ZONE
	STA RZONE.UNCOMPRESS.CURRENT
	
	
.LOOP.LOAD		
;INCREMENT MY.RWTS COUNTERS	 (DONE AT FRONT END BECAUSE 1ST SECTOR IS GARBAGE DATA)
	INC SEC.SRT.COUNTER
	LDA SEC.SRT.COUNTER
	CMP #$10
	BCC .NO_FLIP1.1
	INC TRK.SRT.COUNTER
	LDA TRK.SRT.COUNTER
	STA TRK.SRT
	LDA #$00
	STA SEC.SRT.COUNTER	
.NO_FLIP1.1
	STA SEC.SRT
	INC SEC.END.COUNTER
	LDA SEC.END.COUNTER
	CMP #$10
	BCC .NO_FLIP2.1
	INC TRK.END.COUNTER
	LDA TRK.END.COUNTER
	STA TRK.END	
	LDA #$00
	STA SEC.END.COUNTER	
.NO_FLIP2.1
	STA SEC.END
	
.SKIP.INCREMENT.COUNTERS
	;my.rwts increments dest.addr so it must be set before each call
    LDA #NEW.MAP
    STA DEST.ADDR					;LO
												
    LDA /NEW.MAP
    STA DEST.ADDR+$1               	;HO


;SKIP DOS RESERVED TRACKS/SECTORS
;Note: Applecommander skips track !17 ($11) and track !18, seconds 14 & 15 ($T12,$E & $D)
;I'm almost postive this is becasue AppleCommander is writing data to the disk assuming a DOS format.
;I'm almost postive these tracks/sectors are reserved by DOS. I recall reading somethig about it in Beneath DOS
;and specifically recall the reserve space being near the middle of the disk. It was for catalog information or something. 

;DOS TRACK/SECTOR CHECKS	
	LDA TRK.SRT
	CMP #$11
	BEQ .LOOP.LOAD
	CMP #$12
	BNE .CONTINUE
	LDA SEC.SRT
	CMP #$0E
	BEQ .LOOP.LOAD
	CMP #$0F
	BEQ .LOOP.LOAD
.CONTINUE
	
;READ NEXT SECTOR FROM DISK & WRITE TO REGIONAL MAP
	LDA #$00						;TURN OFF DOS TRACK/SECTOR OVERRIDE
	JSR MY.RWTS

	JSR ZONE_TOOLS.RCOPY					;COPY DATA FROM OUTPUT BUFFER INTO REGIONAL ZONE ARRAY, INTO THE ARRAY ELEMENTS FOR THE CURRENT ZONE

;INCREMENT RZONE INDEX & COUNTER
	INC RZONE.ARRAY.INDEX_ROW+$1	;INCREMENT RZONE HO BYTE INDEX
	INC RZONE.UNCOMPRESS.CURRENT	;INCREMENT ZONE COUNTER

			; CPX #$02
			; BNE .TEMP
			; LDA TEXT
			; LDA $C082
			; ;LDA (DEST.ADDR),Y
			; LDX RZONE.ARRAY.INDEX_ROW
			; LDY RZONE.ARRAY.INDEX_ROW+$1
			; BRK
; .TEMP	
		
	INX 							;INCREMENT TOTAL SECTORS READ	
	CPX TOTAL.SECTORS
	BEQ .EXIT
	JMP .LOOP.LOAD

.EXIT
	
				; LDA TEXT
				; ; LDX #SHP.TBL.ADDRESS.COUNTER
				; ; LDY /SHP.TBL.ADDRESS.COUNTER
				; LDA $C082
				; BRK
		
	RTS		
@END
@END	


MAP.CALCULATE.SS_FLAGS ;CALCUALTE SS MAP REGIONAL FLAGS BASED ON RMAP.X/Y 
@START
;PARAMETERS: RMAP.X, RMAP.Y
;RETURN: MAP_OBJECTS.SS.X_FLAG.UPPER, MAP_OBJECTS.SS.Y_FLAG.UPPER, MAP_OBJECTS.SS.X_FLAG.LOWER, MAP_OBJECTS.SS.Y_FLAG.LOWER
;ENTRANCE: DIRECT

;Note: the principle in play is that flags to detect when a mob x,y value (relative to the player) is off the 
;regional map needs to float depending on the player position withing the region. 
	
	LDA RMAP.X												;PLAYER'S REGIONAL MAP X-AXIS POSITION
	CMP #RZONE.LOAD.X.START									;X-AXIS VALUE WHEN PLAYER IS CENTERED IN REGI0NAL MAP
	BCC .XLESS
	
	LDA RMAP.X		
	SEC
	SBC #RZONE.LOAD.X.START
	STA MAP_OBJECTS.X_ADJ
	
	LDA #MAP_OBJECTS.SS.X_FLAG.LOWER.START					;LEFT EDGE OF REGION WHEN PLAYER IS CENTERED IN REGIONAL MAP
	SEC
	SBC MAP_OBJECTS.X_ADJ
	STA MAP_OBJECTS.SS.X_FLAG.LOWER

	LDA #MAP_OBJECTS.SS.X_FLAG.UPPER.START					;RIGHT EDGE OF REGION WHEN PLAYER IS CENTERED IN REGIONAL MAP
	SEC
	SBC MAP_OBJECTS.X_ADJ
	STA MAP_OBJECTS.SS.X_FLAG.UPPER
	
	
	JMP .YTEST
	
.XLESS	
	LDA #RZONE.LOAD.X.START									;X-AXIS VALUE WHEN PLAYER IS CENTERED IN REGI0NAL MAP
	SEC
	SBC RMAP.X	
	STA MAP_OBJECTS.X_ADJ
	
	LDA #MAP_OBJECTS.SS.X_FLAG.LOWER.START					;LEFT EDGE OF REGION WHEN PLAYER IS CENTERED IN REGIONAL MAP
	CLC
	ADC MAP_OBJECTS.X_ADJ
	STA MAP_OBJECTS.SS.X_FLAG.LOWER
	
	LDA #MAP_OBJECTS.SS.X_FLAG.UPPER.START					;RIGHT EDGE OF REGION WHEN PLAYER IS CENTERED IN REGIONAL MAP
	CLC
	ADC MAP_OBJECTS.X_ADJ
	STA MAP_OBJECTS.SS.X_FLAG.UPPER						
	;**FALLS THROUGH**
	
.YTEST
	LDA RMAP.Y												;PLAYER'S REGIONAL MAP X-AXIS POSITION
	CMP #RZONE.LOAD.Y.START									;X-AXIS VALUE WHEN PLAYER IS CENTERED IN REGI0NAL MAP
	BCC .YLESS
	
	LDA RMAP.Y		
	SEC
	SBC #RZONE.LOAD.Y.START
	STA MAP_OBJECTS.Y_ADJ
	
	LDA #MAP_OBJECTS.SS.Y_FLAG.LOWER.START					;BOTTOM EDGE OF REGION WHEN PLAYER IS CENTERED IN REGIONAL MAP
	SEC
	SBC MAP_OBJECTS.Y_ADJ
	STA MAP_OBJECTS.SS.Y_FLAG.LOWER

	LDA #MAP_OBJECTS.SS.Y_FLAG.UPPER.START					;TOP EDGE OF REGION WHEN PLAYER IS CENTERED IN REGIONAL MAP
	SEC
	SBC MAP_OBJECTS.Y_ADJ
	STA MAP_OBJECTS.SS.Y_FLAG.UPPER
	
	
	JMP .DONE1
	
.YLESS	
	LDA #RZONE.LOAD.Y.START									;Y-AXIS VALUE WHEN PLAYER IS CENTERED IN REGI0NAL MAP
	SEC
	SBC RMAP.Y	
	STA MAP_OBJECTS.Y_ADJ
	
	LDA #MAP_OBJECTS.SS.Y_FLAG.LOWER.START					;BOTTOM EDGE OF REGION WHEN PLAYER IS CENTERED IN REGIONAL MAP
	CLC
	ADC MAP_OBJECTS.Y_ADJ
	STA MAP_OBJECTS.SS.Y_FLAG.LOWER
	
	LDA #MAP_OBJECTS.SS.Y_FLAG.UPPER.START					;TOP EDGE OF REGION WHEN PLAYER IS CENTERED IN REGIONAL MAP
	CLC
	ADC MAP_OBJECTS.Y_ADJ
	STA MAP_OBJECTS.SS.Y_FLAG.UPPER	
.DONE1
	RTS
@END

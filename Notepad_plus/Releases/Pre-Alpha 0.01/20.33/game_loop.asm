                .CR     6502            Use 6502 overlay
				.EF		errors
				;.LI 	OFF				Switches the assembler machine code conversion listing off so errors are easier to see				
				.LF		C:\MY_CODE\LIST
				.EB		OFF				;turn off error bell
				;				***For include files, look at end of program, before variable definitions. 


				
;===============GAME.BIN (game_loop.ASM)======================	
@START			
				.OR		$6004			**Always put before .TF directive and never use again in program
				.TF     GAME.BIN,BIN
;=====================SUBROUTINE DOCUMENTATION====================================
;
;For a description of the game launch process see:
;		Chart 0.1 (GAME LAUNCH) (/my_code/documentation)
;
;=================================================================================
				

;====================MAIN PROGRAM============



GAME.LOADER2				
@START							
;=====================SUBROUTINE DOCUMENTATION====================================
;
;This subroutine is part of the game boot process. For more information on the boot process
;see Chart 0.0 (GAME BOOT), in /my_code/documentation
;
;=================================================================================



	
.COPY.ZONE.TABLE
@START

;=====================CODE-SECTION DOCUMENTATION====================================
;	
;This code section copies the loader zone lookup table (containing the 
;starting memory address in auxiliary memory of each world zone)
;from it's temporary memory location (ZONE.LOOKUP.HO2/LO2) used after 
;its creation to its permenant memory location (ZONE.LOOKUP.HO/LO)
;
;The temporary memory location is overritten by the .LOAD.VARIABLES code section
;Note: the table data was generated when the WOLRD.COMPRESS routine was run in LOADER.BIN. It had to be copied
;to temp memory so it wouldn't get clobbered when GAME.BIN was loaded. It's in the
;memory that will be occupied by VARIABLES.BIN after it is loaded by the next code
;section, so we need to move it out now.
;
;=================================================================================

	
	LDA #$00
	STA COPY.FROM_START
	LDA #$12
	STA COPY.FROM_START+$1
	
	LDA #$40
	STA COPY.FROM_END
	LDA #$12
	STA COPY.FROM_END+$1
		
	LDA #ZONE.LOOKUP.LO
	STA COPY.TO
	LDA /ZONE.LOOKUP.LO
	STA COPY.TO+$1

	JSR MEMORY.COPY

	
	LDA #WZONE.TOTAL.PLUSONE	
	STA COPY.FROM_START
	LDA #$12
	STA COPY.FROM_START+$1
	
	LDA #WZONE.TOTAL.EXTENDED
	STA COPY.FROM_END
	LDA #$12
	STA COPY.FROM_END+$1
		
	LDA #ZONE.LOOKUP.HO
	STA COPY.TO
	LDA /ZONE.LOOKUP.HO
	STA COPY.TO+$1

	JSR MEMORY.COPY
			

			
			; ;LDX #RZONE.LOOKUP.ARRAY_STOP.LO
			; ;LDY /RZONE.LOOKUP.ARRAY_STOP.HO
			; LDX #ZONE.LOOKUP.LO
			; LDY /ZONE.LOOKUP.LO
			; LDA TEXT
			; LDA $C082
			; BRK		
		;**OPT** Memory. THIS MEMORY COPY CAN BE CONSOLIDATED, USING $127F as the copy end address. 
		;I had to split it into to copies because ZONE.LOOKUP.HO/LO are temporarily not adjacent due to the .NO between them
	

	
@END
	

.LOAD.VARIABLES
@START

;=====================CODE-SECTION DOCUMENTATION====================================
;
;LOAD FILE "VARIABLES.IN (offload_variables.ASM)" (THIS FILES HOLD THE MOST OF THE VARIABLES FOR THE MAIN GAME PROGRAM)
;Note that offload_variables2.ASM is incorporated to GAME.BIN via an include file.
;
;=================================================================================


	LDA #$01
    STA CMD.CODE
	LDA #$01
    STA DRIVE
		
    LDA #$06
    STA TRK.SRT    
    LDA #$04
    STA SEC.SRT

	LDA #$07
	STA TRK.END
    LDA #$01
    STA SEC.END

    LDA #$00
    STA DEST.ADDR					;LO
												
    LDA #$12
    STA DEST.ADDR+$1             	;HO
	
	LDA #$00						;TURN OFF DOS TRACK/SECTOR OVERRIDE	
	JSR MY.RWTS

		
@END
@END

	;JMP DISK_READ.SURFACE_MAP.DATA
	;JMP DRIVER
	
; DISK_WRITE.COMPRESSED.DATA	
; @START
		; ;SET DISK.WRITE.AUX PARAMTERES
		; LDA #$15
		; STA TOTAL.SECTORS
		;
		; LDA #$01
		; STA DRIVE
		;
		; LDA #$0D
		; STA TRK.SRT   
		;
		; LDA #$01
		; STA SEC.SRT
		;
		; LDA #$00
		; STA AUX.READ_ADDRESS.START				
		; LDA #$02
		; STA AUX.READ_ADDRESS.START+$1
		;
		; LDA #ZONE_TOOLS.OUTPUT_BUFFER		;START ADDRESS OF ANY AVAILABLE MEMORY BLOCK 1 PAGE IN SIZE
		; STA DISK.IO.BUFFER
		; LDA /ZONE_TOOLS.OUTPUT_BUFFER
		; STA DISK.IO.BUFFER+$1
		;
	; JSR DISK.WRITE.AUX
; @END

	;JMP DRIVER

DISK_READ.SURFACE_MAP.DATA
@START
;LOAD MAP DATA FROM DISK TO AUX MEMORY

		;SETUP MY.RWTS VARIABLES
		LDA #$0B
		STA TOTAL.SECTORS
		;
		LDA #$02
		STA DRIVE
		;	
		LDA #$17
		STA TRK.SRT   
		STA TRK.SRT.COUNTER
		STA TRK.END
		STA TRK.END.COUNTER
		;
		LDA #$0B		
		STA SEC.SRT
		STA SEC.SRT.COUNTER
		STA SEC.END
		STA SEC.END.COUNTER	
		;
		;SETUP AUX MEMORY DESTINATION ADDRESS
		LDA #WORLD.COMPRESS.AUX_MEMORY.START_LO	;SET DESTINATION ADDRESS/LO BYTE
		STA AUX.WRITE_ADDRESS.START			
		STA AUX_MOVE.DEST
		LDA #WORLD.COMPRESS.AUX_MEMORY.START_HO	;SET DESTINATION ADDRESS/HO BYTE
		STA AUX.WRITE_ADDRESS.START+$1
		STA AUX_MOVE.DEST+$1
		;
		LDA #NEW.MAP
		STA DISK.IO.BUFFER
		;
		LDA /NEW.MAP
		STA DISK.IO.BUFFER+$1
		;
;		LDA #$00		;don't skip any header sectors because the data to be read from disk was written to disk by My.RWTS
		LDA #$01		;skip 1 header sector because data was written to disk by AppleCommander
	JSR DISK.READ.AUX
		;
		;
		LDA #$0A 		;TOTAL.SECTORS-1 (doesn't include header sector, because that wasn't loaded into aux memory)
		STA TOTAL.SECTORS	
	JSR ZONE_TOOLS.BUILD.WZONE_HEADERS
@END
	
	; LDA TEXT
	; LDA $C082
	; LDX ZONE.LOOKUP.HO+$2B
	; LDY ZONE.LOOKUP.LO+$2B
	; BRK
	
DRIVER
@START

;=====================CODE-SECTION DOCUMENTATION====================================
;
;Setup variables that would normally be retreived from a saved game or 
;new game file. For example, the player's world map position (RMAP) and 
;the zone the player is locationed in (WZONE)
;
;see Chart 0.1 (GAME LAUNCH), in /my_code/documentation
;
;=================================================================================

;**OPT** Memory. Once testing is largely complete the init of vars/arrays should
;be able to be removed because .BS (block skip) automatically inits the arrays to $00 or
;whatever value is specified (so just modify the .BS to init the MO arrays to $FF for example)
;during testing I'm contiuing to do inits because if I change a var/array to a .EQ definition
;so i can monitor it's contents, then an init is needed.
@MIDDLE

	JSR RANDOM.8.INIT			;LOAD SEED AND SETS DEFAULT RETURN RESULT RANDOM # RANGE. 		

	
;============

;**TEMPORARY** (UNTIL SAVE/LOAD GAME FEATURE IS ADDED)
	
;SETUP STARTING POSITION ON THE MAP
	;$01 50 is the position I'm troubleshooting. move 1 west and there is grass where there couldn't be at bottom of new column (left side of screen)
	LDA #$49				;$49 is upper left corner. $2B is one row up, 5 rows left of the lower right corner. 
	STA GMAP				;$08,0D IS ANOTHER GOOD LOCATION
	LDA #$01				;$01 is upper left corner. $0D is one row up, 5 rows left of the lower right corner. 
	STA GMAP+$1

	;MAIN ISLAND: GMAP.X=$18, GMAP.Y=$37, ZONE $09: GMAP.X=$18, GMAP.Y=$17
	LDA #$18
	STA GMAP.X
	LDA #$37
	STA GMAP.Y
	;NOTE: WHEN INCORPORATING THESE VARIABLES,TAKE INTO CONSIDERATION THAT MOB.GENERATE USES AND CALCULATES A MAP X,Y FOR PLAYER AND MAYBE THE CALCULATION CAN BE ELIMINATED. THAT RAISES THE QUESTION OF WHETHER GMAP.X AND GMAP.Y ARE FOR TRAKCING A REGIONAL X,Y WITHIN THE LOADER ZONES IN MEMORY OR TRULY THE GLOBAL MAP. I THINK THEY SHOULD BE FOR TRACKING THE GLOBAL MAP X,Y, WHICH WORKS WELL WITH THE MOBS BECAUSE THEY NEED TO TRACK THEIR RELARTIVE X,Y TO THE PLAYER EVEN IF THE MOBS ARE NOT LOCATED IN THE LOADER ZONES IN MEMORY. NEW MOBS WOULD ONLY BE CREATED IN THE LOADER ZONES IN MEMORY SO THAT SHOULD BE FINE. THE CURRENT GMAP SHOULD REALLY BE RMAP (REGIONAL). AND GMAP.X/Y STAYS GMAP.X/Y. 

	;$0468 (default), $03AB (tall grass demo), 
	;GAMEPLAY VIDEO: RMAP $037C, ZONE $11, RMAP.X $1C, RMAP.Y $12
	LDA #$68
	STA RMAP							;SET PLAYER LOCATION ON REGIONAL MAP. MUST ALIGN WITH RMAP.X/Y
	LDA #$04
	STA RMAP+$1
	
	;DEFAULT X=$18, Y=$17
	LDA #$18
	STA RMAP.X							;SET PLAYER X,Y ON REGIONAL MAP. MUST ALIGN WITH RMAP. 
	LDA #$17
	STA RMAP.Y
	
	;$09 is upper left corner, $19 is main island, $36 is lower right corner
	LDA #$19							;SET START WORLD ZONE ( SET WZONE )
	STA PLAYER.WMAP.ZONE				;
	
	LDA #$00							;SET PLAYER LOCATION TO SURFACE
	STA PLAYER.MAP.LOCATION
	STA PLAYER.MAP.LOCATION_TYPE		;SET LOCATION TYPE TO SURFACE MAP


				; ;TROUBLESHOOTING HOOK
				; ;
				; LDA #$00							;START ADDRESS OF CURRENT ZONE
				; STA AUX_MOVE.START
				; LDA #$BF	
				; STA AUX_MOVE.START+$1
				; ;
				; LDA #$FF							;END ADDRESS OF AUX MOVE WILL BE START ADDRESS OF NEXT ZONE
				; STA AUX_MOVE.END
				; LDA #$BF					
				; STA AUX_MOVE.END+$1		
				; ;
				; LDA #$00							;SET DESTINATION ADDRESS
				; STA AUX_MOVE.DEST
				; LDA #$90
				; STA AUX_MOVE.DEST+$1
				; ;
				; CLC								;CLEAR CARRY FLAG DESGINATD MOVE FROM AUX -> MAIN MEMORY
				; JSR AUX_MOVE						
				; ;
				; LDA TEXT
				; LDX #ZONE_TOOLS.OUTPUT_BUFFER
				; LDY /ZONE_TOOLS.OUTPUT_BUFFER
				; ; LDX #ZONE.LOOKUP.HO
				; ; LDY /ZONE.LOOKUP.HO
				; LDA TEXT
				; LDA $C082
				; BRK

			
;INIT SS MAP REGIONAL FLAGS (KEEP EVEN AFTER LOAD/SAVE GAME IS IMPLEMENTED)
	JSR MAP.CALCULATE.SS_FLAGS

@MIDDLE
;SET TRANSPORT MODE
	LDA #$FF
	STA PLAYER.TRANSPORT.ACTIVE			;BY DEFAULT SET PLAYER TO WALKING MODE

;SETUP PLAYER ICON
	LDA #$8D							;SPEAR TWIRLER
;	LDA #$99							;HALF SUNK	
;	LDA #$9A							;FULL SUNK	

	STA PLAYER.WALKING.TILE
	STA PLAYER.WALKING.TILE.DEFAULT
	
	LDA PLAYER.HEIGHT.DEFAULT			;SET TO FULL HEIGHT
	STA PLAYER.HEIGHT					;USED TO CONTROL SPECIAL EFFETS LIKE SINKING IN SHALLOW WATER

	JSR LOAD.PLAYER.WALKING.ICON		;COPY PLAYER ICON FROM AUX MEMORY SHAPE TABLE TO MAIN MEMORY BUFFER FOR USE BY DRAW.TILE AN OTHER ROUTINES
	
;SET WORLD
	;PLAYER.WMAP.ZONE ALREADY SET

	LDA #01								;SET SUN = DAYTIME
	STA TIME.SUN_STATUS

			; ;TROUBLESHOOTING HOOK
				; ;
				; LDA #$A1							;START ADDRESS OF CURRENT ZONE
				; STA AUX_MOVE.START
				; LDA #$0C	
				; STA AUX_MOVE.START+$1
				; ;
				; LDA #$B1							;END ADDRESS OF AUX MOVE WILL BE START ADDRESS OF NEXT ZONE
				; STA AUX_MOVE.END
				; LDA #$0C					
				; STA AUX_MOVE.END+$1		
				; ;
				; LDA #ZONE_TOOLS.OUTPUT_BUFFER		;SET DESTINATION ADDRESS
				; STA AUX_MOVE.DEST
				; LDA /ZONE_TOOLS.OUTPUT_BUFFER
				; STA AUX_MOVE.DEST+$1
				; ;
				; CLC									;CLEAR CARRY FLAG DESGINATD MOVE FROM AUX -> MAIN MEMORY
				; JSR AUX_MOVE						
				; ;
				; LDA TEXT
				; LDX #ZONE_TOOLS.OUTPUT_BUFFER
				; LDY /ZONE_TOOLS.OUTPUT_BUFFER

				; ; LDA ZONE.LOOKUP.LO,X
				; ; STA $B000
				; ; LDY ZONE.LOOKUP.HO,X
				; ; STA $B001
				; ; INX
				; ; LDA ZONE.LOOKUP.LO,X
				; ; STA $B002
				; ; LDY ZONE.LOOKUP.HO,X
				; ; STA $B003
	
				; ; LDX #ZONE.LOOKUP.LO
				; ; LDY /ZONE.LOOKUP.LO
				
				; LDA $C082
				
				; ; LDY #$2B
				; ; LDA ZONE.LOOKUP.LO,Y
				; ; LDX ZONE.LOOKUP.HO,Y				
				; BRK

				
	JSR REGION.UNCOMPRESS.ALL			;COPY COMPRESSED WORLD ZONE DATA INTO MAIN MEMORY AND UNCOMPRESS INTO REGIONAL MAP

		; ;TROUBLESHOOTING HOOK
		; LDA TEXT
		; LDA $C082
		; LDX #RZONE.ARRAY	
		; LDY /RZONE.ARRAY	
		; BRK
		
;INIT VARIABLES
			LDA #$00 ;**OPT** Memory. Can be removed once this variable is back to a .BS definition instead of .EQ
			STA MOB.GEN.QUEUE

			LDA #$FC
			STA MOB.GEN.ARRAY_FULL_COUNTER
			
			LDA #$00 ;**OPT** Memory. Can be removed once this variable is back to a .BS definition instead of .EQ	
			STA PLAYER.TRANSPORT.SPEED
			
			LDA #$00; PROBABLY NOT NEEDED, .BS SETS TO $00 ON LAUNCH
			STA ANIMATION.FORCED
			STA ANIMATION.DEEP_WATER.TALLY
			
			; STA $9150	;COUNTER FOR RECODING RANDOM NUMBERS IN MOB.GENERATION
;init miscellanous

	LDA #$00
	STA PLAYER.COLLISSION_OVERRIDE		;$00 = OFF, $01 = ON
	STA MOB.COLLISION_OVERRIDE			;$00 = OFF, $01 = ON


	LDA #$01							;SET TURN TO MOB
	STA GAME.MOB_GEN.CONTROL			
	STA GAME.TURN.CONTROL				;THIS IS WIERD BUT CORRECT. THE MOVEMENT ROUTINE DOESN'T CALL MO.DRAW UNTIL AFTER THE PLAYER MOVE IS PROCESSED, AND THE DRAW.SCREEN CALL TO MO.DRAW DOESN'T PROCESS MOB MOVES,
										;SO, MOBs DON'T GET TO MOVE UNTIL AFTER THE PLAYER HAS MOVED. PERIOD. ALL SETTING THE TURN TO MOB AT LAUNCH DOES IS LET MO.DRAW KNOW THAT IT'S THE MOB'S TURN, ONCE IT IS CALLED AFTER THE PLAYER MOVE. THIS SETUP IS SO THAT THE TURN CAN BE SET TO PLAYER BEFORE CALLING THE PLAYER MOVEMENT ROUTINE (MOVE.N/S/E/W) SO THAT MO.DRAW WON'T PROCESS A MOB MOVE IN SITUATIONS LIKE FAST TRANSPORT IS ENABLED. 
	LDA #$1A
	STA MOB.GEN.PROBABILITY				;SET DEFAULT PROBABILITY OF MOB GENERATION
	
	LDA #TILE.DEPTH.STANDARD			;ANY ROUTINE THAT CHANGES THIS VALUE IS RESPONSIBLE FOR RESETTING IT
	STA TILE.DEPTH
	
;============
@MIDDLE				
@END
				
GAME.RENTRY	;=======USED FOR GAME RENTRY VIA THE MONITOR AFTER A BRK VIA QUIT COMMAND
@START

;=====================CODE-SECTION DOCUMENTATION====================================
;
;These comments apply to GAME.RENTRY and GAME.LAUNCH, the next code section.
;Turn on Hi-Res Graphics and setup screen arrays which track things like
;which tiles are hidden from view (darkness).
;
;Setup initial graphics screen. 
;
;see Chart 0.1 (GAME LAUNCH), in /my_code/documentation
;
;=================================================================================



	LDA #$00			;SPECIFY BOTH PAGES FOR CLEAR SCREEN
	JSR SCLEAR			;CLEAR SCREEN BEFORE TURNING ON GRAPHICS (AVOIDS UNSIGHTLY FLASH OF RANDOM DOTS) 

;	JMP SKIP.GRAPHICS		;don't turn graphics mode on, so register output is visible from monitor prompt on BRK (testing)	

	LDA GRAPHICS	;TURN ON GRAPHICS MODE
	LDA HIRES		;SELECT HI-RES MODE
	LDA	PAGE1		;SELECT PAGE 1
	LDA MIXOFF		;SELECT FULL SCREEN GRAPHICS (PAGE 1)
	
SKIP.GRAPHICS	
;NOT SURE WHERE THIS SHOULD GO, PROBABLY AT VERY START OF GAME LAUNCH, PROBABLY FROM THERE IT IS ALL CALLS TO FLIP.PAGE
	LDA #$01						;
	STA PAGE.FOREGROUND		;DRAW.TILE WILL DRAW THE OPPOSITE PAGE FROM THAT SPECIFED BY THIS VARIABLE
	LDA #$02
	STA PAGE.BACKGROUND	
	LDA	PAGE1

GAME.LAUNCH ;=====JMP HERE TO REDRAW SCREEN AT CURRENT GMAP POSITION
	
;USED BY
; ZAP KEY (3)
; WYVERN FLIGHT (AFTER (Y)ELL, GAME.LAUNCH IS CALLED TO REMOVE ANY DARKNESS THROUGH A FRESH DRAW.SCREEN)

;init arrays
	LDY #$00
.LOOP
	LDA #$00
	STA SCREEN.DARK.DATA, Y
	STA SCREEN.DARK.DATA_BEFORE, Y	
	
	LDA #$FF
	STA SCREEN.MO_TRANSPORT.DATA,Y
	STA SCREEN.MO_MOB.DATA,Y
	
	CPY #$BA
	BEQ .DONE
	INY
	JMP .LOOP
.DONE


;INITIAL SCREEN	DRAW
	JSR DRAW.SCREEN	
	JSR DRAW.TILE.PLAYER
	JSR FLIP.PAGE
	
			
	JSR COPY.SCREEN				;COPY FOREGROUND PAGE TO BACKGROUND PAGE; PREP FOR ANIMATION.
	
	
		; ;ENABLE.BS_RAM
		; LDA $C083				;READ TWICE TO READ/WRITE ENABLE BANK SWITCHED-RAM ($Dxxx BANK 1ST)
		; LDA $C083	

		;JSR COPY.SCREEN				;COPY FOREGROUND PAGE TO BACKGROUND PAGE; PREP FOR ANIMATION.
		
		; LDA $C082				;READ ENABLE ROM, DISABLE WRITE ON BSM (NORMAL STATE)
		; ;DISABLE.BS_RAM	

		
;FALLS DIRECTLY INTO GAME.LOOP
@END

GAME.PRIMARY_LOOP ;=======MANAGES GAME STATE, PROCESSES PLAYER KEYPRESS====== 
@START
;=====================SUBROUTINE DOCUMENTATION====================================
;
;This loop continously scans for a keypress and until a keypress is 
;deteted it continously executed several automatic subroutines which 
;update the game state. 
;
;Once a key is pressed, a subroutine associated with that key is executed
;
;======Special Requirements for Non-Movement Commands====
;
;The following code must be included
;
;1) Include at the very start of the routine
;IF JUMP IS ENABLED, DISABLE IT.  
;(this is to address a scenario where the player pressed (J)ump and then presses a non-movement key)
;	LDA PLAYER.MOVE.JUMP			
;	BEQ .CONTINUE					
;	LDA #$00
;	STA PLAYER.MOVE.JUMP
;.CONTINUE 	
;
;2) Include at the very end of the routine; this is the exit command
;	JMP GAME.LAUNCH							
;
;Reason: GAME.LAUNCH redraws the whole screen, whereas a JMP TO GAME.PRIMARY_LOOP
;does not. This is important because if a key press aborts occurs during movement, the
;JSR to COPY.SCREEN is skipped at the end of the MOVE.NORTH/SOUTH/EAST/WEST routines. That is
;fine if a movement key was pressed but if a non-movement key is pressed and the 
;non-movement subtroutines exits back to GAME.PRIMARY_LOOP then the result will be
;that the animation routine is run without the foreground and background being in sync
;because the JSR to COPY.SCREEN was skipped as previously noted. 
;=================================================================================

;======CONTINOUS ROUTINES UNTIL KEY PRESS====
	
	JSR MOB.GENERATION
	JSR ANIMATION.UPDATE
		
;======CONDITIONAL LOGIC====	
@START
GAME.PRIMARY_LOOP.ALTERNATE.ENTRANCE		;SKIPS ALL INBETWEEN MOVE ACTIVITES SUCH AS ANIMATION AND MOB GENERATION
@MIDDLE
		
	LDA $C000
    BPL GAME.PRIMARY_LOOP 
    STA $C010               ;CLR LAST KEY
		
	CMP #$8B			;UP ARROW
	BEQ .NORTH_STEP
	CMP #$8A			;DOWN ARROW
	BEQ .SOUTH_STEP
	CMP #$95			;RIGHT ARROW
	BEQ .EAST_STEP
	CMP #$88			;LEFT ARROW
	BEQ	.WEST_STEP
	CMP #$C2			;(B) BOARD
	BEQ	.BOARD_STEP
	CMP #$E2			;(b) BOARD
	BEQ	.BOARD_STEP
	; CMP #$C5			;(E) ENTER
	; BEQ	.ENTER_STEP
	; CMP #$E5			;(e) ENTER
	; BEQ	.ENTER_STEP	
	CMP #$CA			;(J) JUMP
	BEQ	.JUMP_STEP
	CMP #$EA			;(j) JUMP
	BEQ	.JUMP_STEP
	CMP #$D1			;(Q) QUIT
	BEQ	.QUIT_STEP
	CMP #$F1			;(q) QUIT
	BEQ	.QUIT_STEP
	CMP #$D8			;(X) X-IT
	BEQ	.XIT_STEP
	CMP #$F8			;(x) X-IT
	BEQ	.XIT_STEP
	CMP #$D9			;(Y) YELL
	BEQ	.YELL_STEP
	CMP #$F9			;(Y) YELL
	BEQ	.YELL_STEP	

	CMP #$A0			;SPACE BAR
	BEQ	PASS
;TROUBLESHOOTING KEYS
	; CMP #$B0			;0	(SET HOOK)
	; BEQ	.KEY0_STEP
	CMP #$B1			;1	(TOGGLE PLAYER COLLISION CONTROLS)
	BEQ	.KEY1_STEP
	CMP #$B2			;2	(TOGGLE MOB COLLISION CONTROLS)
	BEQ	.KEY2_STEP
	CMP #$B3			;3	(ZAP MOB)
	BEQ	.KEY3_STEP	
	CMP #$B4			;4	(INCREASE MOB GEN PROB BY !1/255)
	BEQ	.KEY4_STEP	
	CMP #$B5			;5	(DECREASE MOB GEN PROB BY !1/255)
	BEQ	.KEY5_STEP
	; CMP #$B6			;6	(TOGGLE ANIMATION KEYPRESS ABORT)
	; BEQ	.KEY6_STEP	
	; CMP #$B7			;7	(TOGGLE TOD: DAYTIME/SUNRISE/SUNSET/NIGHT)
	; BEQ	.KEY7_STEP	
	; CMP #$B8			;8	(TOGGLE PLS)
	; BEQ	.KEY8_STEP	
	;**FALLS THROUGH**

;INVALID KEY PRESS
	JSR PLAY.SOUND.DUMB_ASS
	JSR PASS
	JMP GAME.PRIMARY_LOOP


@MIDDLE
	
.NORTH_STEP
	JMP NORTH

.SOUTH_STEP
	JMP SOUTH

.EAST_STEP

	JMP EAST
	
.WEST_STEP
	JMP WEST

.BOARD_STEP
	JMP BOARD

; .ENTER_STEP
	; JMP ENTER
	
.JUMP_STEP
	JMP JUMP
	
.QUIT_STEP
	JMP QUIT
	
.XIT_STEP
	JMP XIT
	
.YELL_STEP
	JMP YELL
	
.KEY0_STEP
	JMP KEY0
	
.KEY1_STEP
	JMP KEY1
	
.KEY2_STEP
	JMP KEY2
	
.KEY3_STEP
	JMP KEY3
	
.KEY4_STEP
	JMP KEY4

.KEY5_STEP
	JMP KEY5
	
.KEY6_STEP
	JMP KEY6

.KEY7_STEP	
	JMP KEY7

.KEY8_STEP	
	JMP KEY8	
@END

;=====KEY PRESS ROUTINES====
@START	
PASS
@START
	LDA #$01 						;SET TURN TO MOB & MOB GENERATION
	STA	GAME.MOB_GEN.CONTROL
	STA GAME.TURN.CONTROL
	JSR MOVE.PASS

	
.EXIT2
	LDA ANIMATION.FORCED
	CMP #$01						;IS ANIMATION FORCED FLAG SET?
	BEQ .EXIT.SKIP.KEYCHECK			;IF YES, DON'T ALLOW AN ABORT DUE TO KEY PRESS		
	
	LDA KB_BUFFER					;LOAD NEXT KEY PRESS FROM BUFFER. WAS KEY PRESSED?
    BMI .EXIT.ALTERNATE				;IF YES, RETURN TO GAME LOOP VIA ALTERNATE ENTRANCE TO SKIP ANIMATION

.EXIT.SKIP.KEYCHECK
	LDA #$00
	STA ANIMATION.FORCED			;RESET TO OFF. IT'S ONLY TURNED ON IF PLAYER IS STANDING ON CERTAIN TERRAIN TYPE	
	JMP GAME.PRIMARY_LOOP 

.EXIT.ALTERNATE
	JMP GAME.PRIMARY_LOOP.ALTERNATE.ENTRANCE

@END
	
NORTH
;=====================SUBROUTINE DOCUMENTATION====================================
;
;The NORTH/SOUTH/EAST/WEST subroutines are the entrance points to the 
;movement subroutines MOVE.NORTH/SOUTH/EAST/WEST
;
;They all have a simular structure. The purpose of .loop is to support
;commands like JUMP, and YELL (enable fast transport for horse, wyvern etc),
;Since the desired effect of those commands is for multiple player moves to
;occur, .loop is setup to call multiple player moves based on the value
;of PLAYER.TRANSPORT.SPEED
;
;PLAYER.TRANSPORT.SPEED was really designed with fast transport in mind, but
;JUMP uses it as a shoe horn to force two player moves to occur via .loop.
;
;In .EXIT there is a cleanup section that applies if this subroutine was 
;called by JUMP. In that event, PLAYER.TRANSPORT.SPEED needs to be returned
;to walking speed ($00), unless fast transport was enabled when the JUMP command
;was issue (i.e. a horse that is running (fast transport mode) should be able to jump
;at keep running)
;
;.EXIT2 has some logic which relates to the movement subroutines MOVE.NORTH/SOUTH/EAST/WEST
;When each of those routines ends, a keypress check is usually done so that animation can be
;skipped if the player is holding down the movement key. .EXIT2 make a 
;branch based on whether a key press has occured so that if a keypress has
;occured it returns to the game loop via the alternate entrace, which results in
;animation and mob generation being skipped. 
;
;Also note that the above is skipped entirely if ANIMATION.FORCED is set. This is
;because there are circumstances where animation is forced, no matter what.
;For example, if the screen is filled with all deep water, animation is forced
;because a statis screen doesn't look good under those circumstances. 
;
;=================================================================================

@START
	LDA #$00
	STA PLAYER.MOVE.COUNTER			;INIT LOOP & MOVE COUNTER

.LOOP
;MULTIPLE MOVES	
	JSR MOVE.NORTH
	LDA #$00						;SET TURN TO PLAYER. THIS WAY MOBS ONLY GET TO MOVE ONCE, WHICH OCCURS AFTER THE PLAYERS 1ST MOVE AND BEFORE THE PLAYERS 2ND MOVE
	STA GAME.TURN.CONTROL
	INC PLAYER.MOVE.COUNTER			;INCREMENT LOOP & MOVE COUNTER
	LDA PLAYER.MOVE.COUNTER
	CMP PLAYER.TRANSPORT.SPEED
	BCS .EXIT
	JMP .LOOP

.EXIT
	
	LDA #$01 						;SET TURN TO MOB & MOB GENERATION
	STA	GAME.MOB_GEN.CONTROL
	STA GAME.TURN.CONTROL
	
	LDA #$8B						;SET TO UP ARROW (NORTH)
	STA PLAYER.COMMAND.LAST

;CLEAN UP (IF JUMP MOVE)	
	LDA PLAYER.MOVE.JUMP
	BEQ .EXIT2
	LDA #$00
	STA PLAYER.MOVE.JUMP
	
	LDX PLAYER.TRANSPORT.STATUS		;CHECK PLAYER TRANSPORT STATUS
	CPX #$01						;IS FAST TRANSPORT ENABLED?
	BCS .EXIT2						;IF YES, THEN EXIT
	STA PLAYER.TRANSPORT.SPEED		;IF NO, THEN TURN RETURN TRANSPORT SPEED TO $00 (1:1)

	
.EXIT2
	LDA ANIMATION.FORCED
	CMP #$01						;IS ANIMATION FORCED FLAG SET?
	BEQ .EXIT.SKIP.KEYCHECK			;IF YES, DON'T ALLOW AN ABORT DUE TO KEY PRESS		
	
	LDA KB_BUFFER					;LOAD NEXT KEY PRESS FROM BUFFER. WAS KEY PRESSED?
    BMI .EXIT.ALTERNATE				;IF YES, RETURN TO GAME LOOP VIA ALTERNATE ENTRANCE TO SKIP ANIMATION

.EXIT.SKIP.KEYCHECK
	LDA #$00
	STA ANIMATION.FORCED			;RESET TO OFF. IT'S ONLY TURNED ON IF PLAYER IS STANDING ON CERTAIN TERRAIN TYPE	
	JMP GAME.PRIMARY_LOOP 

.EXIT.ALTERNATE
	JMP GAME.PRIMARY_LOOP.ALTERNATE.ENTRANCE
	
@END
	
SOUTH
@START
;=====================SUBROUTINE DOCUMENTATION====================================
;
;See documentation above in subtroutine NORTH
;
;=================================================================================

	LDA #$00
	STA PLAYER.MOVE.COUNTER			;INIT LOOP & MOVE COUNTER

.LOOP
;MULTIPLE MOVES	
	JSR MOVE.SOUTH
	LDA #$00						;SET TURN TO PLAYER. THIS WAY MOBS ONLY GET TO MOVE ONCE, WHICH OCCURS AFTER THE PLAYERS 1ST MOVE AND BEFORE THE PLAYERS 2ND MOVE
	STA GAME.TURN.CONTROL
	INC PLAYER.MOVE.COUNTER			;INCREMENT LOOP & MOVE COUNTER
	LDA PLAYER.MOVE.COUNTER
	CMP PLAYER.TRANSPORT.SPEED
	BCS .EXIT
	JMP .LOOP
	
.EXIT	
	LDA #$01 						;SET TURN TO MOB & MOB GENERATION
	STA	GAME.MOB_GEN.CONTROL
	STA GAME.TURN.CONTROL	

	LDA #$8A						;SET TO DOWN ARROW (SOUTH)
	STA PLAYER.COMMAND.LAST
	
	LDA PLAYER.MOVE.JUMP
	BEQ .EXIT2
	LDA #$00
	STA PLAYER.MOVE.JUMP
	
	LDX PLAYER.TRANSPORT.STATUS		;CHECK PLAYER TRANSPORT STATUS
	CPX #$01						;IS FAST TRANSPORT ENABLED?
	BCS .EXIT2						;IF YES, THEN EXIT
	STA PLAYER.TRANSPORT.SPEED		;IF NO, THEN TURN RETURN TRANSPORT SPEED TO $00 (1:1)

	
.EXIT2
	LDA ANIMATION.FORCED
	CMP #$01						;IS ANIMATION FORCED FLAG SET?
	BEQ .EXIT.SKIP.KEYCHECK			;IF YES, DON'T ALLOW AN ABORT DUE TO KEY PRESS		
	
	LDA KB_BUFFER					;LOAD NEXT KEY PRESS FROM BUFFER. WAS KEY PRESSED?
    BMI .EXIT.ALTERNATE				;IF YES, RETURN TO GAME LOOP VIA ALTERNATE ENTRANCE TO SKIP ANIMATION

.EXIT.SKIP.KEYCHECK
	LDA #$00
	STA ANIMATION.FORCED			;RESET TO OFF. IT'S ONLY TURNED ON IF PLAYER IS STANDING ON CERTAIN TERRAIN TYPE	
	JMP GAME.PRIMARY_LOOP 

.EXIT.ALTERNATE
	JMP GAME.PRIMARY_LOOP.ALTERNATE.ENTRANCE

@END
	
EAST
@START
;=====================SUBROUTINE DOCUMENTATION====================================
;
;See documentation above in subtroutine NORTH
;
;=================================================================================

	LDA #$00
	STA PLAYER.MOVE.COUNTER			;INIT LOOP & MOVE COUNTER

.LOOP
;MULTIPLE MOVES	
	JSR MOVE.EAST
	LDA #$00						;SET TURN TO PLAYER. THIS WAY MOBS ONLY GET TO MOVE ONCE, WHICH OCCURS AFTER THE PLAYERS 1ST MOVE AND BEFORE THE PLAYERS 2ND MOVE
	STA GAME.TURN.CONTROL
	INC PLAYER.MOVE.COUNTER			;INCREMENT LOOP & MOVE COUNTER
	LDA PLAYER.MOVE.COUNTER
	CMP PLAYER.TRANSPORT.SPEED
	BCS .EXIT
	JMP .LOOP

.EXIT	
	LDA #$01 						;SET TURN TO MOB & MOB GENERATION
	STA	GAME.MOB_GEN.CONTROL
	STA GAME.TURN.CONTROL
	
	LDA #$95						;SET TO RIGHT ARROW (EAST)
	STA PLAYER.COMMAND.LAST
	
	LDA PLAYER.MOVE.JUMP
	BEQ .EXIT2
	LDA #$00
	STA PLAYER.MOVE.JUMP
	
	LDX PLAYER.TRANSPORT.STATUS		;CHECK PLAYER TRANSPORT STATUS
	CPX #$01						;IS FAST TRANSPORT ENABLED?
	BCS .EXIT2						;IF YES, THEN EXIT
	STA PLAYER.TRANSPORT.SPEED		;IF NO, THEN TURN RETURN TRANSPORT SPEED TO $00 (1:1)

	
.EXIT2
	LDA ANIMATION.FORCED
	CMP #$01						;IS ANIMATION FORCED FLAG SET?
	BEQ .EXIT.SKIP.KEYCHECK			;IF YES, DON'T ALLOW AN ABORT DUE TO KEY PRESS		
	
	LDA KB_BUFFER					;LOAD NEXT KEY PRESS FROM BUFFER. WAS KEY PRESSED?
    BMI .EXIT.ALTERNATE				;IF YES, RETURN TO GAME LOOP VIA ALTERNATE ENTRANCE TO SKIP ANIMATION

.EXIT.SKIP.KEYCHECK
	LDA #$00
	STA ANIMATION.FORCED			;RESET TO OFF. IT'S ONLY TURNED ON IF PLAYER IS STANDING ON CERTAIN TERRAIN TYPE	
	JMP GAME.PRIMARY_LOOP 

.EXIT.ALTERNATE
	JMP GAME.PRIMARY_LOOP.ALTERNATE.ENTRANCE

@END
WEST 
@START	
;=====================SUBROUTINE DOCUMENTATION====================================
;
;See documentation above in subtroutine NORTH
;
;=================================================================================
	
	LDA #$00
	STA PLAYER.MOVE.COUNTER			;INIT LOOP & MOVE COUNTER

.LOOP
;MULTIPLE MOVES	
	JSR MOVE.WEST
	LDA #$00						;SET TURN TO PLAYER. THIS WAY MOBS ONLY GET TO MOVE ONCE, WHICH OCCURS AFTER THE PLAYERS 1ST MOVE AND BEFORE THE PLAYERS 2ND MOVE
	STA GAME.TURN.CONTROL
	INC PLAYER.MOVE.COUNTER			;INCREMENT LOOP & MOVE COUNTER
	LDA PLAYER.MOVE.COUNTER
	CMP PLAYER.TRANSPORT.SPEED
	BCS .EXIT
	JMP .LOOP
	
.EXIT		
	LDA #$01 						;SET TURN TO MOB & MOB GENERATION
	STA	GAME.MOB_GEN.CONTROL
	STA GAME.TURN.CONTROL
	
	LDA #$8B						;SET TO UP ARROW (NORTH)
	STA PLAYER.COMMAND.LAST
	
	LDA PLAYER.MOVE.JUMP
	BEQ .EXIT2
	LDA #$00
	STA PLAYER.MOVE.JUMP
	
	LDX PLAYER.TRANSPORT.STATUS		;CHECK PLAYER TRANSPORT STATUS
	CPX #$01						;IS FAST TRANSPORT ENABLED?
	BCS .EXIT2						;IF YES, THEN EXIT
	STA PLAYER.TRANSPORT.SPEED		;IF NO, THEN TURN RETURN TRANSPORT SPEED TO $00 (1:1)

	
.EXIT2
	LDA ANIMATION.FORCED
	CMP #$01						;IS ANIMATION FORCED FLAG SET?
	BEQ .EXIT.SKIP.KEYCHECK			;IF YES, DON'T ALLOW AN ABORT DUE TO KEY PRESS		
	
	LDA KB_BUFFER					;LOAD NEXT KEY PRESS FROM BUFFER. WAS KEY PRESSED?
    BMI .EXIT.ALTERNATE				;IF YES, RETURN TO GAME LOOP VIA ALTERNATE ENTRANCE TO SKIP ANIMATION

.EXIT.SKIP.KEYCHECK
	LDA #$00
	STA ANIMATION.FORCED			;RESET TO OFF. IT'S ONLY TURNED ON IF PLAYER IS STANDING ON CERTAIN TERRAIN TYPE	
	JMP GAME.PRIMARY_LOOP 

.EXIT.ALTERNATE
	JMP GAME.PRIMARY_LOOP.ALTERNATE.ENTRANCE

@END

BOARD
@START
;IF JUMP IS ENABLED, DISABLE IT.  **include at start of all non-movement command subroutines**
;(this occurs if the player pressed (J)ump and then presses a non-movement key)
	LDA PLAYER.MOVE.JUMP			
	BEQ .CONTINUE					
	LDA #$00
	STA PLAYER.MOVE.JUMP

.CONTINUE 	
	JSR MO.BOARD
	JMP GAME.LAUNCH							;ALL NON-MOVEMENT COMMANDS MUST EXIT VIA JMP TO GAME.LAUNCH TO AVOID PROBLEMS WITH KEY PRESS ABORTS. SEE SUBROUTINE DOCUMENTATION FOR GAME.PRIMARY_LOOP FOR DETAILS.

@END

JUMP
@START

;VERIFY PLAYER IS ON A HORSE
	LDA PLAYER.TILE.ACTIVE
	CMP #TILE_ID.HORSE_C						;BRANCH BASED ON THE TYPE OF TRASNPORT MO AT THE PLAYER LOCATION
	BNE .NOT_ON_HORSE
	
.ALLOW.JUMP	
;ENABLE JUMP	
	LDA #$01								;LET THE COLLISSION CONTROLS (IN MOVEMENT_MANAGER.ASM) KNOW THAT HORSE IS JUMPING
	STA PLAYER.MOVE.JUMP
	
	LDA #$02								;SET SPEED TO 2:1
	STA PLAYER.TRANSPORT.SPEED	

	LDA #$CA								;SET LAST COMMAND TO 'J'
	STA PLAYER.COMMAND.LAST
	
;CHOOSE DIRECTION OF JUMP	
	;THIS IS DONE BY THE NEXT KEY PRESS FROM THE GAME LOOP. THE MOVEMENT COMMANDS WILL READ THE PLAYER.MOVE.JUMP VARIABLE TO DETECT THAT IT'S A JUMP MOVE. 
	JMP .EXIT
	
.NOT_ON_HORSE
	JSR PLAY.SOUND.DUMB_ASS
	
.EXIT
	JMP GAME.LAUNCH							;ALL NON-MOVEMENT COMMANDS MUST EXIT VIA JMP TO GAME.LAUNCH TO AVOID PROBLEMS WITH KEY PRESS ABORTS. SEE SUBROUTINE DOCUMENTATION FOR GAME.PRIMARY_LOOP FOR DETAILS.

	
@END
		
QUIT
@START
;=====================SUBROUTINE DOCUMENTATION====================================
;
;Exit to Apple machine language monitor. 
;
;=================================================================================

				; LDA #$AF							;START ADDRESS OF CURRENT ZONE
				; STA AUX_MOVE.START
				; LDA #$04	
				; STA AUX_MOVE.START+$1
				
				; LDA #$B1							;END ADDRESS OF AUX MOVE WILL BE START ADDRESS OF NEXT ZONE
				; STA AUX_MOVE.END
				; LDA #$04					
				; STA AUX_MOVE.END+$1		
				
				; LDA #ZONE_TOOLS.INPUT_BUFFER						;SET DESTINATION ADDRESS
				; STA AUX_MOVE.DEST
				; LDA /ZONE_TOOLS.INPUT_BUFFER	
				; STA AUX_MOVE.DEST+$1
				; CLC		;AUX -> MAIN
				; JSR AUX_MOVE
				
	
	LDA TEXT

;DISABLE.BS_RAM
	LDA $C082				;READ ENABLE ROM, DISABLE WRITE ON BSM (NORMAL STATE).
							;REQUIRED FOR BEFORE BRK BECAUSE APPLE MONITOR IS A ROM ROUTINE


	;LDA PLAYER.HEIGHT
	; LDX #PLAYER.ICON.BUFFER
	; LDY /PLAYER.ICON.BUFFER
	;LDA ANIMATION.DEEP_WATER.TALLY
	; LDA PLAYER.MAP.LOCATION	
	; LDX PLAYER.MAP.LOCATION_TYPE
	
	
	LDA TIME.SUN_STATUS
	LDX TIME.SUN.COUNTER
	BRK
	
;ENABLE.BS_RAM BEFORE REENTRY
	LDA $C083				;READ TWICE TO READ/WRITE ENABLE BANK SWITCHED-RAM ($Dxxx BANK 1ST)
	LDA $C083	
	JMP GAME.RENTRY



			 ; LDX #ZONE.LOOKUP.LO
			 ; LDY /ZONE.LOOKUP.LO
			; BRK
			
			
@END	

	
	
YELL ;ENABLED FAST TRANSPORT MODE, IF AVAILABLE
@START
;IF JUMP IS ENABLED, DISABLE IT.  **include at start of all non-movement command subroutines**
;(this occurs if the player pressed (J)ump and then presses a non-movement key)
	LDA PLAYER.MOVE.JUMP			
	BEQ .CONTINUE					
	LDA #$00
	STA PLAYER.MOVE.JUMP

.CONTINUE 
	LDA PLAYER.TILE.ACTIVE
	CMP #TILE_ID.HORSE_C
	BEQ .HORSE
	CMP #TILE_ID.WYVERN
	BEQ .WYVERN
	JMP .YELL_AT_WHAT


.HORSE	
	LDA PLAYER.TRANSPORT.SPEED
	BEQ .CURRENT_SPEED0.0
.CURRENT_SPEED1.0						;1 PLAYER MOVE PER 1 MOB MOVE
	LDA #$00
	STA PLAYER.TRANSPORT.SPEED
	STA PLAYER.TRANSPORT.STATUS	
	JMP .EXIT
	
.CURRENT_SPEED0.0						;2 PLAYER MOVE PER 1 MOB MOVE
	LDA #$02
	STA PLAYER.TRANSPORT.SPEED
	STA PLAYER.TRANSPORT.STATUS	
	JMP .EXIT

.WYVERN
	LDA PLAYER.TRANSPORT.SPEED
	BEQ .CURRENT_SPEED0.1
.CURRENT_SPEED1.1						;1 PLAYER MOVE PER 1 MOB MOVE
	LDA #$00
	STA PLAYER.TRANSPORT.SPEED
	STA PLAYER.TRANSPORT.STATUS	
	STA PLAYER.DARKNESS_OVERRIDE

	JMP GAME.LAUNCH						;DO A FRESH SCREEN DRAW TO CREATE ANY DARK TILES
	
.CURRENT_SPEED0.1						;4 PLAYER MOVE PER 1 MOB MOVE
	LDA #$04
	STA PLAYER.TRANSPORT.SPEED
	STA PLAYER.TRANSPORT.STATUS	
	STA PLAYER.DARKNESS_OVERRIDE
	JMP GAME.LAUNCH						;DO A FRESH SCREEN DRAW TO DRAW ANY DARK TILES. 
	
.YELL_AT_WHAT
	JSR PLAY.SOUND.DUMB_ASS				;FUTURE ON SCREEN TEXT "YELL AT WHAT? HORSE"

.EXIT
	JMP GAME.LAUNCH							;ALL NON-MOVEMENT COMMANDS MUST EXIT VIA JMP TO GAME.LAUNCH TO AVOID PROBLEMS WITH KEY PRESS ABORTS. SEE SUBROUTINE DOCUMENTATION FOR GAME.PRIMARY_LOOP FOR DETAILS.

@END
	
XIT
@START
;IF JUMP IS ENABLED, DISABLE IT.  **include at start of all non-movement command subroutines**
;(this occurs if the player pressed (J)ump and then presses a non-movement key)
	LDA PLAYER.MOVE.JUMP			
	BEQ .CONTINUE					
	LDA #$00
	STA PLAYER.MOVE.JUMP

.CONTINUE 
	JSR MO.XIT
	JMP GAME.LAUNCH							;ALL NON-MOVEMENT COMMANDS MUST EXIT VIA JMP TO GAME.LAUNCH TO AVOID PROBLEMS WITH KEY PRESS ABORTS. SEE SUBROUTINE DOCUMENTATION FOR GAME.PRIMARY_LOOP FOR DETAILS.


@END


;==========PLAY TEST KEYS=
@START
KEY0 ;=====SET HOOK=======
@START
;CODE CAN BE INSERTED IN OTHER ROUTINES TO BREAK IF THE HOOK IS SET.
	LDA #$01				;$01 = HOOK SET
	STA TROUBLESHOOTING.HOOK
	JMP GAME.PRIMARY_LOOP
	
@END

KEY1 ;=====PLAYER COLLISSION OVERRIDE TOGGLE=======
@START
;IF OVERRIDE IS SET, PLAYER CAN TRAVERSE ANY TILE, INCLUDING MAP OBJECTS
	LDA PLAYER.COLLISSION_OVERRIDE
	CMP #$01
	BNE .NOT1
	LDA #$00
	STA PLAYER.COLLISSION_OVERRIDE
	JMP GAME.PRIMARY_LOOP
.NOT1
	LDA #$01
	STA PLAYER.COLLISSION_OVERRIDE
	JMP GAME.PRIMARY_LOOP

@END
	
KEY2 ;=====MOB COLLISSION OVERRIDE TOGGLE=======
@START
;IF OVERRIDE IS SET, MOB CAN TRAVERSE ANY TILE, INCLUDING MAP OBJECTS (NOT SURE WHAT EFFECT WOULD RESULT FROM THE LATTER)
	LDA MOB.COLLISION_OVERRIDE
	CMP #$01
	BNE .NOT1
	LDA #$00
	STA MOB.COLLISION_OVERRIDE
	JMP GAME.PRIMARY_LOOP
.NOT1
	LDA #$01
	STA MOB.COLLISION_OVERRIDE
	JMP GAME.PRIMARY_LOOP

@END

KEY3 ;=====ZAP MOB========
@START
	JSR KEYIN
	CMP #$8B			;UP ARROW
	BEQ .ZAP_NORTH
	CMP #$8A			;DOWN ARROW
	BEQ .ZAP_SOUTH
	CMP #$95			;RIGHT ARROW
	BEQ .ZAP_EAST
	CMP #$88			;LEFT ARROW
	BEQ	.ZAP_WEST

.ZAP_NORTH
	LDY #$4C
	JMP .SEARCH.ADJACENT_MOB
	
.ZAP_SOUTH	
	LDY #$6E
	JMP .SEARCH.ADJACENT_MOB
	
.ZAP_EAST
	LDY #$5E
	JMP .SEARCH.ADJACENT_MOB
 
.ZAP_WEST
	LDY #$5C
;****FALLS THROUGH

.SEARCH.ADJACENT_MOB
	
	LDA SCREEN.MO_MOB.DATA,Y					;IS A MOB LOCATED AT TARGET TILE?
	CMP #$FF
	BEQ .NO_MOB
	TAX
	LDA #$00
	STA MAP_OBJECTS.MOB,X						;ERASE MOB'S MAP OBJECT RECORD
	STA MAP_OBJECTS.MOB+$1,X
	STA MAP_OBJECTS.MOB+$2,X
	STA MAP_OBJECTS.MOB+$3,X
	LDA #$FF
	STA SCREEN.MO_MOB.DATA,Y					;ERASE MOB FROM SCREEN ARRAY
	JMP GAME.LAUNCH								;REDRAW SCREEN AT CURRENT GMAP POSITION. MOB'S GAME TURN IS SKIPPED 
	
.NO_MOB	
	JMP GAME.PRIMARY_LOOP

@END
	
KEY4 ;====INCREASE MOB GEN PROBABILITY BY $01=== 
@START
	INC MOB.GEN.PROBABILITY
	BNE .EXIT
	DEC MOB.GEN.PROBABILITY 
.EXIT
	JMP GAME.PRIMARY_LOOP

KEY5 ;====DECREASE MOB GEN PROBABILITY BY $01=== 
@START
	DEC MOB.GEN.PROBABILITY
	LDA MOB.GEN.PROBABILITY
	CMP #$FF
	BNE .EXIT
	INC MOB.GEN.PROBABILITY 
.EXIT
	JMP GAME.PRIMARY_LOOP
@END

@END
	
KEY6 ;=====TOGGLE ANIMATION KEYPRESS ABORT=======
@START
;IF OVERRIDE IS SET, PLAYER CAN TRAVERSE ANY TILE, INCLUDING MAP OBJECTS
	LDA ANIMATION.FORCED
	CMP #$01
	BNE .NOT1
	LDA #$00
	STA ANIMATION.FORCED
	JMP GAME.PRIMARY_LOOP
.NOT1
	LDA #$01
	STA ANIMATION.FORCED
	JMP GAME.PRIMARY_LOOP	
	
@END

KEY7 ;=====TOGGLE DAY/SUNRISE/SUNSET/NIGHT=======
@START
	INC TIME.SUN_STATUS		;$00 = SUN RISING, $01 = DAY, $02 = SUN SETTING, $03 = NIGHT
	LDA TIME.SUN_STATUS
	CMP #$04
	BCC .NO_FLIP
	LDA #$00
	STA TIME.SUN_STATUS
.NO_FLIP

	CMP #$00
	BEQ .SUN_RISING
	CMP #$02
	BEQ .SUN_SETTING
	JMP .EXIT
	
.SUN_RISING	
	LDA #$00
	STA TIME.SUN.COUNTER
	STA TIME.SUN.SUB_COUNTER
	JMP .EXIT
	
.SUN_SETTING
	LDA #$04
	STA TIME.SUN.COUNTER
	LDA #$00
	STA TIME.SUN.SUB_COUNTER
	;**FALLS THROUGH**
	
.EXIT
	JMP GAME.PRIMARY_LOOP	
	
@END


KEY8 ;=====PLS TOGGLE=======
@START
;TOGGLE PLAYER LIGHT SOURCE (PLS)
	LDA PLAYER.PLS_STATUS
	CMP #$01
	BNE .NOT1
	LDA #$00
	STA PLAYER.PLS_STATUS
	JMP GAME.PRIMARY_LOOP
.NOT1
	LDA #$01
	STA PLAYER.PLS_STATUS
	JMP GAME.PRIMARY_LOOP

@END
	
	
@END
@END
@END
	
;======INCLUDE FILES;
@START
;======(SAME TARGET FILE)======
				.IN 	C:\MY_CODE\INCLUDES_LIBS\routines_graphics				
				.IN 	C:\MY_CODE\INCLUDES_LIBS\routines_text
				.IN 	C:\MY_CODE\INCLUDES_LIBS\routines_math
				.IN 	C:\MY_CODE\INCLUDES_LIBS\routines_general
				.IN 	C:\MY_CODE\INCLUDES_LIBS\routines_disk.ASM

				.IN 	C:\MY_CODE\INCLUDES_LIBS\graphics_engine								
				.IN 	C:\MY_CODE\INCLUDES_LIBS\animation_manager
				.IN 	C:\MY_CODE\INCLUDES_LIBS\movement_manager
				.IN 	C:\MY_CODE\INCLUDES_LIBS\sound_manager	
				.IN 	C:\MY_CODE\INCLUDES_LIBS\map_tools
				.IN 	C:\MY_CODE\INCLUDES_LIBS\offloaded_variables2

;TEMPORARY FOR TROUBLESHOOTING				
	.IN 	C:\MY_CODE\INCLUDES_LIBS\zone_functions
	;.IN 	C:\MY_CODE\INCLUDES_LIBS\darkness_manager



					
@END						

	.NO $B700,$AA	;FILLER TO THE UPPER LIMIT OF MAIN MEMORY. (RWTS OCCUPIES $B700 - $BFFF)
					;This enables SBASM to generate an error if/when the code overshoots this memory address.
					;It also kees this target file at a fixed size so the track/sector stays the same on the disk image, which is needed to load the file via MY.RWTS
					
;======INCLUDE FILES (SEPERATE TARGET FILE)======


;BOOT PROCESS AND DATA FILES
				.IN 	C:\MY_CODE\INCLUDES_LIBS\Loader
				.IN 	C:\MY_CODE\INCLUDES_LIBS\Custom_Boot2
				.IN 	C:\MY_CODE\INCLUDES_LIBS\DATA.SHAPES.BUILDING
				.IN 	C:\MY_CODE\INCLUDES_LIBS\DATA.MAP.UNDERMAP_LV1.ASM
				.IN 	C:\MY_CODE\INCLUDES_LIBS\DATA.MAP.L1.ASM
;				.IN 	C:\MY_CODE\INCLUDES_LIBS\TEST.MAP.ASM

;MAIN GAME FILES				
				.IN 	C:\MY_CODE\INCLUDES_LIBS\offloaded_variables
				.IN 	C:\MY_CODE\INCLUDES_LIBS\BS_routines

@END
@END



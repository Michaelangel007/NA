;************************INCLUDE FILE*****************************
;(do not assemble stand-alone. For a stand-alone version of this routine see examples/rwts2)


;=====================DARKNESS_MANAGER.ASM DOCUMENTATION====================================
;
;***ADDING an obscuring tile: add another CMP/BEQ pair to INNERLOOP.REENTRY1
;
;==OVERVIEW==
;
;DARKNESS.REVIEW is the entrance to all subroutines in this file. 
;
;The subroutines in this file are responsible for determining which tiles on the 
;view screen are visible to the player and which ones are hidden. Hidden tiles are 
;black (all bits set to $00). 
;
;The approach taken to do this is to set each tile in SCREEN.DARK.DATA will a value of $00 (visible/light) or $01 (hidden/dark)
;SCREEN.DARK.DATA mirrors SCREEN.TILE.DATA in it's format and thus uses the same index (screen tile #). 
;
;There are currently 3 stages to darkess calculations, performed in this order:
;			*TOD (Time of Day: sunrise, daytime, sunset,night)
;			*ELS (External light source: street lamps, wall torches, etc.)
;			*PLS (Player light source: hand held torch)
;			*OBS (Obscuring Tiles: mountains, walls, etc.)
;
;Each of the above has it's own subroutine, which makes updates
;to SCREEN.TILE.DATA in order to mock up the final dark/ligh patter on the screen.
;
;More specifically, at the start of DARNKESS.REVIEW, SCREEN.DARK.DATA has 
;all tiles set to $00 (visible/light). TOD sets tiles dark using stencils.
;if appropriate for the time of day.
;
;ELS & PLS then turn certain tiles light, if ELS or PLS are dected.  
;
;After ELS & PLS, DARKNESS.SCREEN.UDPATE is called to erase
;any tiles on the graphics screen which are marked as hidden in SCREEN.DARK.DATA
;but marked as visible in SCREEN.DARK.BEFORE. SCREEN.DARK.BEFORE contains the dark/light status
;of each tile as of the last player move.
;
;Then lastly, OBS marks certain tiles as dark based on the position relative to the player of mountains, walls, etc. 
;OBS erases and draws tiles as necessary, using SCREEN.DARK.BEFORE comparisons, so that when OBS completes
;the graphics screen reflects the flags in SCREEN.DARK.DATA.
;
;=================================================================================


;TROUBLESHOOTING
;
;USING DRIVER.DARKNESS
;	COMMENT THE ARRAY DEFINITION FOR SCREEN.TILE.DATA (IN TILE_FUNCTIONS.ASM) AND 
;	REPLACE WITH A TEMPORARY VERSION DEFINED IN THIS FUNCTION, WHICH CONTROLS WHICH 
;	TILES ON SCREEN ARE OBSCURING TILES. 
;
;	ONCE ERASE.TILE AND DRAWTILE ARE INTEGRATED WITH THE REST OF THE GAME CODE
;	THE PROCEDURE FOR USING THE DRIVER TO TEST A FULL SCREEN MAY CHANGE (TESTING A SINGLE POSTION VIA TROUBLSHOOTING HOOK #3 WILL PROBABLY BE THE SAME)	
;	I'D GUESS THAT IT MAY BE NECESSARY FOR THE ERASE.TILE AND DRAWTILE FUNCTIONS TO SKIP THE GUTS OF THEIR CODE 
;	AND RETURN TO THE LOOP. OR MAYBE IT WON'T MATTER IF THEY DO THEIR THING SINCE WE'D JUST BE INTERESTED IN THE DARKNESS FLAGGED IN SCREEN.DARK.DATA ANYWAY
;
;USING THE TROUBLESHOOTING HOOKS
;	UNCOMMENT THE CODE IN DRIVER.DARKNESS AND UNDER EACH HOOK
;	USE DRIVER.DARKNESS AS THE ENTRY. SO CALL DRIVER.DARKNESSS FROM WHERE EVER THE GAME CURRENT 
;	LAUNCHES FROM...(GRAPHICS_ENGINE.ASM AT THE TIME OF THIS WRITING). AND 
;	HAVE IT BRK AFTER THE CALL. 
;
;NORMAL REGISTER VALUES AT BRK USING DRIVER.DARKNESS.
;		X=$85 (THE NUMBER OF LOOKUP VALUES IN SCREEN.DARK.SEARCH_INDEX)
;		Y=$A8 (THE LAST VALUE IN SCREEN.DARK.SEARCH_INDEX, WHICH CORRESPONDS TO THE ELEMENTS OF SCREEN.TILE.DATA)
;
;TROUBLESHOOTING HOOK #1
;	TEST SKIPPING ERASE IF THE CURRENT TILE WAS DARK LAST MOVE (NET OF SCROLLING)
;	THIS HOOK IS LOCATED IN THE ERASE.TILE SUBROUTINE IN GRAPHICS_ENGINE.ASM
;
;TROUBLESHOOTING HOOK #2
;	TEST SKIPPING OBSCURING TILE EVALUATION FOR TILES ALREADY FLAGGED AS DARK
;	USE THIS TO SEE WHICH Y VALUES (SCREEN.TILE.DATA ELEMENTS) FOR WHICH DARKNESS IS CALCUALTED FOR. 
;	DARKNESS SHOULD NOT BE CALCULATED FOR TILES THAT WERE FLAGGED AS DARK (WITH $01) IN SCREEN.DARK.DATA IN AN EARLIER ITERATION.
;
;TROUBLESHOOTING HOOK #3
;	TEST A SINGLE SCREEN POSITION (Y-REG VALUE) AND OBSERVE THE DARKNESS CALCULATED IN SCREEN.DARK.DATA
;	THERE IS ONE HOOK IN DRIVER.DARKNESS, DARKNESS.OBS AND 2 IN OUTERLOOP (ONE AT THE TOP AND ONE THAT SETS UP THE "TESTENTRY" LABEL AT THE BOTTOM)


DRIVER.DARKNESS
@START

;INIT ARRAYS TO $00
	LDY #$00
.LOOP
	LDA #$00
	STA SCREEN.DARK.DATA, Y
	STA SCREEN.DARK.DATA_BEFORE, Y	
	CPY #$BA
	BEQ .DONE
	INY
	JMP .LOOP
.DONE	


;SET TEST POSITION	 (HOOK #3)	
	;LDY #$5E			;SCREEN POSITION (SCREEN.TILE.DATA ELEMENT)

;TEST ERASE SKIP (HOOK #1)
;	LDA	#$01						
;	STA SCREEN.DARK.DATA_BEFORE+$9D	;CHANGE THE OFFSET TO THE SCREEN POSITION YOU WANT TO TEST
	
;DISPLYS MMM AT LAUNCH TO MARK WHEN THE PROGRAM STARTS, IN CASE OF AN ENDLESS LOOP (THE LOAD TIME IS PRETTY LONG SO THIS HELPS MAKE IT OBVIOUS WHEN AN ENDLESS LOOP IS OCCURING)
;	LDA #$CD
;	JSR $FDED
;	LDA #$CD
;	JSR $FDED
;	LDA #$CD
;	JSR $FDED
	
;	JSR DARKNESS.OBS
;DISABLE.BS_RAM
	LDA $C082				;READ ENABLE ROM, DISABLE WRITE ON BSM (NORMAL STATE).
							;REQUIRED FOR BEFORE BRK BECAUSE APPLE MONITOR IS A ROM ROUTINE

	LDA TEXT
	BRK

@END


DARKNESS.REVIEW ;=============REWORK DARNKESS FOR ENTIRE SCREEN=======
@START
;PARAMETERS: NONE
;RETURN VALUE: NONE
;ENTRANCE: DIRECT

	JSR DARKNESS.TOD
	JSR DARKNESS.PLS
	JSR DARKNESS.ELS
	JSR DARKNESS.SCREEN.UPDATE	;ERASE ANY TILES, NET OF SUN AND LIGHT SOURCES, THAT ARE DARK NOW BUT WEREN'T DARK BEFOE
	JSR DARKNESS.OBS
	
		; LDA TIME.SUN_STATUS
		; CMP #$03
		; BNE .TEMP
		; LDA TEXT
		; LDA $C082
		; BRK
; .TEMP

	RTS
	
@END

DARKNESS.TOD ;=====DARKNESS WHICH IS BASED ON TIME OF DAY=====
@START
;PARAMETERS: NONE
;RETURN: UPDATED SCREEN.DARK.DATA
;ENTRANCE: DARKNESS.REVIEW

;=====================SUBROUTINE DOCUMENTATION====================================
;
;See spreadsheet my_code/rpg project/maps/darkness/"TOD, ELS, PLS Charts".xls
;
;This subroutine implements sunrise and sunset via the stencils in the TOD section of this spreadsheet.
;The stencils are stored in auxiliary memory (loaded by LOADER.ASM with data stoed in data.other.sunrise_sunset.ASM)
;and the stencil that is needed for the current iteration is copied into main memory. 
;
;If it is day, this subroutines aborts to exit. 
;
;If it is night, this subroutine uses the stencil for night. 
;
;
;=================================================================================


;SAVE REGISTERS (ENTRY VALUES)
	TXA
	PHA
	TYA
	PHA
	
	LDA TIME.SUN_STATUS		;$00 = SUN RISING, $01 = DAY, $02 = SUN SETTING, $03 = NIGHT
	CMP #$01	;IS DAY?
	BEQ .EXIT_STEP
	CMP #$03	;IS NIGHT?
	BEQ .NIGHT
	CMP #$02	;IS SUNSET?
	BEQ .SUN_SET
	CMP #$00	;IS SUNRISE?
	BEQ .SUN_RISE
.ERROR
;UNEXPECTED VALUE IN TIME.SUN_STATUS (DARKNESS.TOD)
	LDA TEXT
	LDA $C082
	BRK

.EXIT_STEP
	JMP .EXIT
	
.NIGHT
	LDX #$00				;USED AS INDEX BY .LOAD.STENCIL, CAUSING STENCIL $00 (ALL DARK) TO BE LOADED
	JMP .LOAD.STENCIL
	
.SUN_SET
	LDX TIME.SUN.COUNTER	;LOAD CURRENT SUNSET PHASE
	BEQ .SET.NIGHT

	LDA TIME.SUN.SUB_COUNTER
	CMP #TIME.SUN.SUB_COUNTER.STOP
	BCC .LOAD.STENCIL

	LDA #$00
	STA TIME.SUN.SUB_COUNTER	;RESET COUNTER. COUNTS THE MOVES BETWEEN INCREMENTS TO INC TIME.SUN.COUNTER, WHICH CONTROLS THE PHASE OF THE SUNSET/SUNRISE
	DEC TIME.SUN.COUNTER	;NEXT SUNSET PHASE
	JMP .LOAD.STENCIL	
.SET.NIGHT
	LDA #$03
	STA TIME.SUN_STATUS
	JMP .LOAD.STENCIL
	
	
.SUN_RISE
	LDX TIME.SUN.COUNTER	;LOAD CURRENT SUNSET PHASE
	CPX #$04
	BEQ .SET.DAY

	LDA TIME.SUN.SUB_COUNTER
	CMP #TIME.SUN.SUB_COUNTER.STOP
	BCC .LOAD.STENCIL

	LDA #$00
	STA TIME.SUN.SUB_COUNTER	;RESET COUNTER. COUNTS THE MOVES BETWEEN INCREMENTS TO INC TIME.SUN.COUNTER, WHICH CONTROLS THE PHASE OF THE SUNSET/SUNRISE	
	INC TIME.SUN.COUNTER	;NEXT SUNSET PHASE
	
		; LDA TEXT
		; LDA $C082
		; LDA TIME.SUN.COUNTER
		; BRK
		
	JMP .LOAD.STENCIL
.SET.DAY
	LDA #$01
	STA TIME.SUN_STATUS
	;**FALLS THROUGH**
	
	
.LOAD.STENCIL		
	INC TIME.SUN.SUB_COUNTER						;COUNTS THE MOVES BETWEEN INCREMENTS TO INC TIME.SUN.COUNTER, WHICH CONTROLS THE PHASE OF THE SUNSET/SUNRISE

;LOAD STENCIL FOR CURRENT SUNSET/SUNRISE PHASE
	LDA DATA.OTHER.SUNRISE_SUNSET.AUX.LO,X 			;SET START ADDRESS
	STA AUX_MOVE.START
	LDA DATA.OTHER.SUNRISE_SUNSET.AUX.HO,X
	STA AUX_MOVE.START+$1
	
;16-BIT SUBTRACT
	LDA DATA.OTHER.SUNRISE_SUNSET.AUX.LO+$1,X		;SET END ADDRESS
	SEC
	SBC #$01
	STA AUX_MOVE.END
	LDA DATA.OTHER.SUNRISE_SUNSET.AUX.HO+$1,X
	SBC #$00
	STA AUX_MOVE.END+$1
	
	LDA #SCREEN.DARK.DATA							;SET DESTINATION ADDRESS
	STA AUX_MOVE.DEST
	LDA /SCREEN.DARK.DATA	
	STA AUX_MOVE.DEST+$1
	
			; LDA TEXT
			; ; LDX #SCREEN.DARK.DATA
			; ; LDY /SCREEN.DARK.DATA 
			; LDA $C082
			; LDX AUX_MOVE.START
			; LDY AUX_MOVE.START+$1
			; BRK

;COPY STENCIL INTO SCREEN.DARK.DATA	
	CLC                		;CLEAR CARRY FLAG DESGINATD MOVE FROM AUX -> MAIN MEMORY 
	JSR AUX_MOVE

	;**FALLS THROUGH**

			
.EXIT	
;RESTORE REGISTERS (ENTRY VALUES)

	PLA
	TAY
	PLA
	TAX
	
	RTS
@END


DARKNESS.PLS ;=====DARKNESS OFFSET BY PLAYER LIGHT SOURCE=======
@START
;PARAMETERS: NONE
;RETURN: UPDATED SCREEN.DARK.DATA
;ENTRANCE: DARKNESS.REVIEW

;=====================SUBROUTINE DOCUMENTATION====================================
;
;See spreadsheet my_code/rpg project/maps/darkness/"TOD, ELS, PLS Charts".xls
;
;This subroutine sets the tiles to $00 (light/visible) shown in the PLS ection of this spreadsheet.
;Since the player is always in the same screen location, hard coded screen tile location numbers can be used. 
;
;If it is day, this subroutines aborts to exit. 
;
;=================================================================================


;SAVE REGISTERS (ENTRY VALUES)
	TXA
	PHA
	TYA
	PHA

;IF DAY THEN EXIT
	LDA TIME.SUN_STATUS		;$00 = SUN RISING, $01 = DAY, $02 = SUN SETTING, $03 = NIGHT
	CMP #$01	;IS DAY?
	BNE .CHECK.PLS_STATUS
	JMP EXIT_PLS

.CHECK.PLS_STATUS
	LDA PLAYER.PLS_STATUS
	BEQ EXIT_PLS
	CMP #SCREEN.DARK.PLS.TORCH
	BEQ PLS.TORCH
	JMP EXIT_PLS

PLS.TORCH
	;THE CODE BELOW IMPLEMENTS THE LIGHTING PATTERN FROM TOP TO BOTTOM, LEFT TO RIGHT. 
	LDA #$00
	
	STA SCREEN.DARK.DATA+$29
	STA SCREEN.DARK.DATA+$2A
	STA SCREEN.DARK.DATA+$2B

	STA SCREEN.DARK.DATA+$39
	STA SCREEN.DARK.DATA+$3A
	STA SCREEN.DARK.DATA+$3B
	STA SCREEN.DARK.DATA+$3C
	STA SCREEN.DARK.DATA+$3D

	STA SCREEN.DARK.DATA+$49
	STA SCREEN.DARK.DATA+$4A
	STA SCREEN.DARK.DATA+$4B
	STA SCREEN.DARK.DATA+$4C
	STA SCREEN.DARK.DATA+$4D
	STA SCREEN.DARK.DATA+$4E
	STA SCREEN.DARK.DATA+$4F	

	STA SCREEN.DARK.DATA+$5A
	STA SCREEN.DARK.DATA+$5B
	STA SCREEN.DARK.DATA+$5C
	STA SCREEN.DARK.DATA+$5D
	STA SCREEN.DARK.DATA+$5E
	STA SCREEN.DARK.DATA+$5F
	STA SCREEN.DARK.DATA+$60

	STA SCREEN.DARK.DATA+$6B
	STA SCREEN.DARK.DATA+$6C
	STA SCREEN.DARK.DATA+$6D
	STA SCREEN.DARK.DATA+$6E
	STA SCREEN.DARK.DATA+$6F
	STA SCREEN.DARK.DATA+$70
	STA SCREEN.DARK.DATA+$71
	
	STA SCREEN.DARK.DATA+$7D
	STA SCREEN.DARK.DATA+$7E
	STA SCREEN.DARK.DATA+$7F
	STA SCREEN.DARK.DATA+$80
	STA SCREEN.DARK.DATA+$81	

	STA SCREEN.DARK.DATA+$8F
	STA SCREEN.DARK.DATA+$90
	STA SCREEN.DARK.DATA+$91
	
	;**FALLS THROUGH**
	
EXIT_PLS	
;RESTORE REGISTERS (ENTRY VALUES)

	PLA
	TAY
	PLA
	TAX
	
	RTS
	
@END


DARKNESS.ELS ;=====DARKNESS OFFSET BY EXTERNAL LIGHT SOURCE=====
@START
;PARAMETERS: NONE
;RETURN: UPDATED SCREEN.DARK.DATA
;ENTRANCE: DARKNESS.REVIEW

;=====================SUBROUTINE DOCUMENTATION====================================
;
;See spreadsheet my_code/rpg project/maps/darkness/"TOD, ELS, PLS Charts".xls
;
;This subroutine sets the tiles to $00 (light/visible) shown in the ELS section of this spreadsheet.
;Since the ELS could be in any screen location, or even off screen, this routine involves
;a search through SCREEN.TILE.DATA, and the first 3 offscreen rows and column beyond each screen edge. 
;Additionally, all screen tile location references (for setting tiles to light/dark) must be relative to the
;location of the ELS found. 
;
;If it is day, this subroutines aborts to exit. 
;
;Technical Notes:
;		*This subroutine is a big fat pig (3/4 super page). It is for the most part an unrolled loop.
;			the reason is because most array iterating that it does are for short segments 1-3 elements.
;
;		*For implimenting the pattern of light tiles, the onscreen and offscreen top/bottom routines take;	
; 		an approach of starting in the column the ELS is located in, turning on the tiles to the left and right, then
;		moving down 1 row and doing the same. Repeating for the appropriate number of rows. 
;		
;		The reason for this start center then iterate left/right method is because the routine must check for 
;		the left/right screen edge. Onscreen routines also have to check for the top/bottom screen edge.  
;		The offscreen left/right routines don't have to worry about that becuase by definition the ELS is offscreen left (or right) so the code
;		knows where it is relative to the left/right screen edge, they just have to check for the top/bottom screen edge. 
;
;
;There is a notable bug/skipped feature:
;		Screen corner issues. For example, If an ELS is above the top screen edge and to the right of the right screen edge, but no more so than by 3 rows in both criteria, there should be some light shown in the upper right corner, but there isn't. This is because DARKNESS.ELS loads tile data for offscreen rows and columns equal
;				to the size of an onscreen row and column, which causes the corners sections to be missed. 
;
;=================================================================================

;**OPT** Memory. This subroutine is a big fat pig (3/4 super page). It is for the most part an unrolled loop.
		;the reason is because most array iterating that it does are for short segments 1-3 elements. 
		;There is one obvious opportunity I see to decrease memory. Both the onscreen routine and the offscreen routine for top/bottom may
		;be able to share the same code for the section that sets the tiles to light. 
		;For example .CALCULATE.ELS.LIGHT_OFFSCREEN.TOP.R1-3 (and the bottom routines)
		;could be setup as subroutines that were JSR by CALCULATE.ELS.LIGHT_ONSCREEN. 
		;CALCULATE.ELS.LIGHT_ONSCREEN may need to retain a little code, but I think 75-90% of it is redundant. 

;SAVE REGISTERS (ENTRY VALUES)
	TXA
	PHA
	TYA
	PHA

	
;IF DAY THEN EXIT
	LDA TIME.SUN_STATUS		;$00 = SUN RISING, $01 = DAY, $02 = SUN SETTING, $03 = NIGHT
	CMP #$01	;IS DAY?
	BNE SEARCH.ONSCREEN
	JMP EXIT_ELS

SEARCH.ONSCREEN
@START
;INIT VARIABLES
	LDY #$00

LOOP.SEARCH.ONSCREEN
	LDA SCREEN.TILE.DATA,Y
	STA TEMP				;SAVE TILE_TYPE
	
	LDA PLAYER.MAP.LOCATION_TYPE
	CMP #LOCATION.TYPE.BUILDING
	BEQ .LOCATION_TYPE.BUILDING.TILES
	JMP	NEXT_TILE
	
.LOCATION_TYPE.BUILDING.TILES
	LDA TEMP				;RESTORE TILE_TYPE
	CMP #DARK_FLAGS.ELS.EQ1
	BEQ CALCULATE.ELS.LIGHT_ONSCREEN
	JMP	NEXT_TILE

CALCULATE.ELS.LIGHT_ONSCREEN

;CALCUALTE LIGHTING EFFECT OF CURRENT ONSCREEN ELS OBJECT
@MIDDLE
	
.R0.LEFT	
;ROW = ELS, COLUMN = LEFT OF ELS
	STY SCREEN.DARK.ELS.TILE	;SAVE ELS TILE LOCATION

	LDA #$00					;LIGHT UP ELS TILE
	STA SCREEN.DARK.DATA,Y

	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #$00					;IN FIRST COLUMN?
	BEQ .R0.RIGHT				;IF YES, NEXT SECTION	
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE

	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #$00					;IN FIRST COLUMN?
	BEQ .R0.RIGHT				;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE

	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #$00					;IN FIRST COLUMN?
	BEQ .R0.RIGHT				;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**
	
.R0.RIGHT
;ROW = ELS, COLUMN = RIGHT OF ELS	
	LDY SCREEN.DARK.ELS.TILE	;LOAD ELS TILE LOCATION

	;ELS TILE ALREADY LIGHT, START WITH NEXT TILE TO THE RIGHT

	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #SCREEN.COLUMN.LAST		;IN LAST COLUMN?
	BEQ .R1UP.LEFT				;IF YES, NEXT SECTION	
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE

	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #SCREEN.COLUMN.LAST		;IN FIRST COLUMN?
	BEQ .R1UP.LEFT				;IF YES, NEXT SECTION	
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE

	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #SCREEN.COLUMN.LAST		;IN FIRST COLUMN?
	BEQ .R1UP.LEFT				;IF YES, NEXT SECTION
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**
	
.R1UP.LEFT
;ROW = ELS + 1UP, COLUMN = LEFT OF ELS	
	LDY SCREEN.DARK.ELS.TILE	;LOAD ELS TILE LOCATION
	
	LDA SCREEN.INDEX.ROW,Y		;LOOKUP ROW OF CURRENT TILE		
	CMP #$00					;IN FIRST ROW?
	BNE .R1UP.LEFT.CONTINUE		;IF NO, CONTINUE
	JMP .R1DOWN.LEFT			;IF YES, SKIP ALL ROWS UP FROM THE ELS, NEXT SECTION

.R1UP.LEFT.CONTINUE	
	TYA							;MOVE 1 ROW UP
	SEC
	SBC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS ELS
	STA SCREEN.DARK.DATA,Y
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #$00					;IN FIRST COLUMN?
	BEQ .R1UP.RIGHT				;IF YES, NEXT SECTION	
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE

	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #$00					;IN FIRST COLUMN?
	BEQ .R1UP.RIGHT				;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE

	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP	#$00					;IN FIRST COLUMN?
	BEQ .R1UP.RIGHT				;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**
	
.R1UP.RIGHT
;ROW = ELS +1UP, COLUMN = RIGHT OF ELS	
	LDY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #SCREEN.COLUMN.LAST		;IN LAST COLUMN?
	BEQ .R2UP.LEFT				;IF YES, NEXT SECTION	
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #SCREEN.COLUMN.LAST		;IN FIRST COLUMN?
	BEQ .R2UP.LEFT				;IF YES, NEXT SECTION	
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE

	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #SCREEN.COLUMN.LAST		;IN FIRST COLUMN?
	BEQ .R2UP.LEFT				;IF YES, NEXT SECTION
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**
	
.R2UP.LEFT
;ROW = ELS + 2UP, COLUMN = LEFT OF ELS	
	LDY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.
	
	LDA SCREEN.INDEX.ROW,Y		;LOOKUP ROW OF CURRENT TILE		
	CMP #$00					;IN FIRST ROW?
	BEQ .R1DOWN.LEFT			;IF YES, SKIP ALL ROWS UP FROM THE ELS, NEXT SECTION

	TYA							;MOVE 1 ROW UP
	SEC
	SBC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS ELS
	STA SCREEN.DARK.DATA,Y
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #$00					;IN FIRST COLUMN?
	BEQ .R2UP.RIGHT				;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE

	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP	#$00					;IN FIRST COLUMN?
	BEQ .R2UP.RIGHT				;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**

.R2UP.RIGHT	
;ROW = ELS +2UP, COLUMN = RIGHT OF ELS	
	LDY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #SCREEN.COLUMN.LAST		;IN LAST COLUMN?
	BEQ .R3UP.LEFT				;IF YES, NEXT SECTION	
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE

	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #SCREEN.COLUMN.LAST		;IN FIRST COLUMN?
	BEQ .R3UP.LEFT				;IF YES, NEXT SECTION	
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**

.R3UP.LEFT
;ROW = ELS + 3UP, COLUMN = LEFT OF ELS	
	LDY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.
	
	LDA SCREEN.INDEX.ROW,Y		;LOOKUP ROW OF CURRENT TILE		
	CMP #$00					;IN FIRST ROW?
	BEQ .R1DOWN.LEFT			;IF YES, SKIP ALL ROWS UP FROM THE ELS, NEXT SECTION

	TYA							;MOVE 1 ROW UP
	SEC
	SBC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS ELS
	STA SCREEN.DARK.DATA,Y
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #$00					;IN FIRST COLUMN?
	BEQ .R3UP.RIGHT				;IF YES, NEXT SECTION	
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**

.R3UP.RIGHT
;ROW = ELS +3UP, COLUMN = RIGHT OF ELS	
	LDY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #SCREEN.COLUMN.LAST		;IN LAST COLUMN?
	BEQ .R1DOWN.LEFT			;IF YES, NEXT SECTION
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**

@MIDDLE
	
.R1DOWN.LEFT
;ROW = ELS + 1DOWN, COLUMN = LEFT OF ELS	
	LDY SCREEN.DARK.ELS.TILE	;LOAD ELS TILE LOCATION
	
	LDA SCREEN.INDEX.ROW,Y		;LOOKUP ROW OF CURRENT TILE		
	CMP #SCREEN.ROW.LAST		;IN LAST ROW?
	BNE .R1DOWN.LEFT.CONTINUE	;IF NO, CONTINUE
	JMP NEXT_TILE				;IF YES, EXIT

.R1DOWN.LEFT.CONTINUE	
	TYA							;MOVE 1 ROW DOWN
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS ELS
	STA SCREEN.DARK.DATA,Y
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #$00					;IN FIRST COLUMN?
	BEQ .R1DOWN.RIGHT			;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #$00					;IN FIRST COLUMN?
	BEQ .R1DOWN.RIGHT			;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #$00					;IN FIRST COLUMN?
	BEQ .R1DOWN.RIGHT			;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALL THROUGH**

.R1DOWN.RIGHT
;ROW = ELS +1DOWN, COLUMN = RIGHT OF ELS	
	LDY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #SCREEN.COLUMN.LAST		;IN LAST COLUMN?
	BEQ .R2DOWN.LEFT			;IF YES, NEXT SECTION
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #SCREEN.COLUMN.LAST		;IN FIRST COLUMN?
	BEQ .R2DOWN.LEFT			;IF YES, NEXT SECTION
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #SCREEN.COLUMN.LAST		;IN FIRST COLUMN?
	BEQ .R2DOWN.LEFT			;IF YES, NEXT SECTION
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**

.R2DOWN.LEFT
;ROW = ELS + 2DOWN, COLUMN = LEFT OF ELS	
	LDY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA SCREEN.INDEX.ROW,Y		;LOOKUP ROW OF CURRENT TILE		
	CMP #SCREEN.ROW.LAST		;IN LAST ROW?
	BNE .R2DOWN.LEFT.CONTINUE	;IF NO, CONTINUE
	JMP NEXT_TILE				;IF YES, EXIT
	
.R2DOWN.LEFT.CONTINUE	
	TYA							;MOVE 1 ROW DOWN
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS ELS
	STA SCREEN.DARK.DATA,Y
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP	#$00					;IN FIRST COLUMN?
	BEQ .R2DOWN.RIGHT			;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #$00					;IN FIRST COLUMN?
	BEQ .R2DOWN.RIGHT			;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**

	
.R2DOWN.RIGHT	
;ROW = ELS +2DOWN, COLUMN = RIGHT OF ELS	
	LDY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #SCREEN.COLUMN.LAST		;IN LAST COLUMN?
	BEQ .R3DOWN.LEFT			;IF YES, NEXT SECTION	
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #SCREEN.COLUMN.LAST		;IN FIRST COLUMN?
	BEQ .R3DOWN.LEFT			;IF YES, NEXT SECTION
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**

.R3DOWN.LEFT
;ROW = ELS + 3DOWN, COLUMN = LEFT OF ELS	
	LDY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA SCREEN.INDEX.ROW,Y		;LOOKUP ROW OF CURRENT TILE		
	CMP #SCREEN.ROW.LAST		;IN LAST ROW?
	BNE .R3DOWN.LEFT.CONTINUE	;IF NO, CONTINUE
	JMP NEXT_TILE				;IF YES, EXIT
	
.R3DOWN.LEFT.CONTINUE	
	TYA							;MOVE 1 ROW DOWN
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS ELS
	STA SCREEN.DARK.DATA,Y
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #$00					;IN FIRST COLUMN?
	BEQ .R3DOWN.RIGHT			;IF YES, NEXT SECTION	
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**

.R3DOWN.RIGHT
;ROW = ELS +3DOWN, COLUMN = RIGHT OF ELS	
	LDY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #SCREEN.COLUMN.LAST		;IN LAST COLUMN?
	BNE .R3DOWN.RIGHT.CONTINUE	;IF NO, CONTINUE
	JMP NEXT_TILE				;IF YES, EXIT
	
.R3DOWN.RIGHT.CONTINUE	
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	JMP NEXT_TILE

NEXT_TILE
	INY										;INCREMENT SCREEN ARRAY INDEX
	CPY #SCREEN.ARRAY.LAST_ELEMENT2			;HAS LOOP EXAMINED ALL TILES IN SCREEN ARRAY?
	BEQ SEARCH.OFFSCREEN					;IF YES, NEXT ROUTINE
	JMP LOOP.SEARCH.ONSCREEN

@END
	

SEARCH.OFFSCREEN

SEARCH.OFFSCREEN.LEFT.ENTRANCE
@START

;INIT VARIABLES
	LDY #$01						;COLUMN COUNTER
	STY SAVED.YREG.LOCAL1			;TRANSFER COLUMN COUNTER TO A VARIABLE SINCE Y-REG IS NEEDED FOR MULTIPLE TASKS. 
	
	LDA SMAP						;INIT ROW COUNTER
	STA SMAP.CURRENT
	
	LDA SMAP+$1
	STA SMAP.CURRENT+$1
	
LOOP.SEARCH.OFFSCREEN.LEFT
;SEARCH THE 1ST COLUMN OFF THE LEFT SIDE OF SCREEN
;MOVE 1 COLUMN OFF LEFT SIDE OF SCREEN

	;16-BIT SUBTRACT
	LDA SMAP.CURRENT
	SEC
	SBC #RZONE.ARRAY.OFFSET.HORIZONTAL					
	STA SMAP.CURRENT
	
	LDA SMAP.CURRENT+$1
	SBC #$00
	STA SMAP.CURRENT+$1

	JSR TILE.LOOKUP.OFFSCREEN.COLUMN

;INIT VARIABLES
	LDX #$00						;SCREEN.TILE.HOPPER INDEX
	
.LOOP.SEARCH.COLUMN

	LDA SCREEN.TILE.HOPPER,X
	STA TEMP				;SAVE TILE_TYPE
	
	LDA PLAYER.MAP.LOCATION_TYPE
	CMP #LOCATION.TYPE.BUILDING
	BEQ .LOCATION_TYPE.BUILDING.TILES
	JMP	.NEXT_TILE
	
.LOCATION_TYPE.BUILDING.TILES
	LDA TEMP				;RESTORE TILE_TYPE
	CMP #DARK_FLAGS.ELS.EQ1
	BEQ .ELS.FOUND
	JMP	.NEXT_TILE
	
.ELS.FOUND	
	CPY #$01
	BEQ .CALCULATE.ELS.LIGHT_OFFSCREEN.LEFT.C1	;C1 REFERS TO THE NUMBER OF COLUMNS OFFSCREEN FROM THE LEFT EDGE THE ELS IS
	CPY #$02
	BEQ .CALCULATE.ELS.LIGHT_OFFSCREEN.LEFT.C2_STEP	;C2 REFERS TO THE NUMBER OF COLUMNS OFFSCREEN FROM THE LEFT EDGE THE ELS IS
	CPY #$03
	BEQ .CALCULATE.ELS.LIGHT_OFFSCREEN.LEFT.C3_STEP	;C3 REFERS TO THE NUMBER OF COLUMNS OFFSCREEN FROM THE LEFT EDGE THE ELS IS
	
.ERROR
;UNEXPECTED VALUE IN Y-REG (OFFSCREEN COLUMN COUNTER)
	LDA TEXT
	LDA $C082
	BRK
	
.CALCULATE.ELS.LIGHT_OFFSCREEN.LEFT.C2_STEP
	JMP .CALCULATE.ELS.LIGHT_OFFSCREEN.LEFT.C2
	
.CALCULATE.ELS.LIGHT_OFFSCREEN.LEFT.C3_STEP
	JMP .CALCULATE.ELS.LIGHT_OFFSCREEN.LEFT.C3
	
	
	
.CALCULATE.ELS.LIGHT_OFFSCREEN.LEFT.C1 ;C1 REFERS TO THE NUMBER OF COLUMNS OFFSCREEN FROM THE LEFT EDGE THE ELS IS
@START
.OFFSCREEN_C1.R0
;ROW = ELS	

;CALCULATE STARTING SCREEN TILE LOCATION (THE 1ST ON SCREEN COLUMN, SAME Y-AXIS AS ELS)	
	LDY SCREEN.MULTIPLY_TABLE, X
	STY SCREEN.DARK.ELS.ONSCREEN_ANCHOR	;SAVE ELS PSEUDO LOCATION

	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP PSEDUO ELS TILE LOCATION
	
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE

	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**	

.OFFSCREEN_C1.R1UP
;ROW = ELS + 1UP
	LDY SCREEN.DARK.ELS.ONSCREEN_ANCHOR	;LOAD ELS PSEUDO LOCATION
	
	LDA SCREEN.INDEX.ROW,Y			;LOOKUP ROW OF CURRENT TILE		
	CMP #$00						;IN FIRST ROW?
	BNE .OFFSCREEN_C1.R1UP.CONTINUE	;IF NO, CONTINUE
	JMP .OFFSCREEN_C1.R1DOWN		;IF YES, SKIP ALL ROWS UP FROM THE ELS, NEXT SECTION

.OFFSCREEN_C1.R1UP.CONTINUE	
	TYA								;MOVE 1 ROW UP
	SEC
	SBC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS PSEDUO ELS
	STA SCREEN.DARK.DATA,Y
	
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE

	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**
	
.OFFSCREEN_C1.R2UP
;ROW = ELS + 2UP
	LDY SCREEN.DARK.ELS.FLOATING_TILE	;LOAD ELS PSEUDO LOCATION
	
	LDA SCREEN.INDEX.ROW,Y			;LOOKUP ROW OF CURRENT TILE		
	CMP #$00						;IN FIRST ROW?
	BNE .OFFSCREEN_C1.R2UP.CONTINUE	;IF NO, CONTINUE
	JMP .OFFSCREEN_C1.R1DOWN		;IF YES, SKIP ALL ROWS UP FROM THE ELS, NEXT SECTION

.OFFSCREEN_C1.R2UP.CONTINUE	
	TYA								;MOVE 1 ROW UP
	SEC
	SBC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS PSEDUO ELS
	STA SCREEN.DARK.DATA,Y
	
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**

.OFFSCREEN_C1.R3UP
;ROW = ELS + 3UP
	LDY SCREEN.DARK.ELS.FLOATING_TILE	;LOAD ELS PSEUDO LOCATION
	
	LDA SCREEN.INDEX.ROW,Y			;LOOKUP ROW OF CURRENT TILE		
	CMP #$00						;IN FIRST ROW?
	BNE .OFFSCREEN_C1.R3UP.CONTINUE	;IF NO, CONTINUE
	JMP .OFFSCREEN_C1.R1DOWN		;IF YES, SKIP ALL ROWS UP FROM THE ELS, NEXT SECTION

.OFFSCREEN_C1.R3UP.CONTINUE	
	TYA								;MOVE 1 ROW UP
	SEC
	SBC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS PSEDUO ELS
	STA SCREEN.DARK.DATA,Y
	;**FALLS THROUGH**
	
.OFFSCREEN_C1.R1DOWN
;ROW = ELS + 1DOWN
	LDY SCREEN.DARK.ELS.ONSCREEN_ANCHOR	;LOAD ELS PSEUDO LOCATION
	
	LDA SCREEN.INDEX.ROW,Y				;LOOKUP ROW OF CURRENT TILE		
	CMP #SCREEN.ROW.LAST				;IN LAST ROW?
	BNE .OFFSCREEN_C1.R1DOWN.CONTINUE	;IF NO, CONTINUE
	JMP .NEXT_TILE						;IF YES, NEXT TILE IN HOPPER (CURRENT COLUMN)

.OFFSCREEN_C1.R1DOWN.CONTINUE	
	TYA									;MOVE 1 ROW DOWN
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS PSEDUO ELS
	STA SCREEN.DARK.DATA,Y
	
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE

	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**
	
.OFFSCREEN_C1.R2DOWN
;ROW = ELS + 2DOWN
	LDY SCREEN.DARK.ELS.FLOATING_TILE	;LOAD ELS PSEUDO LOCATION
	
	LDA SCREEN.INDEX.ROW,Y				;LOOKUP ROW OF CURRENT TILE		
	CMP #SCREEN.ROW.LAST				;IN LAST ROW?
	BNE .OFFSCREEN_C1.R2DOWN.CONTINUE	;IF NO, CONTINUE
	JMP .NEXT_TILE						;IF YES, NEXT TILE IN HOPPER (CURRENT COLUMN)

.OFFSCREEN_C1.R2DOWN.CONTINUE	
	TYA									;MOVE 1 ROW DOWN
	CLC	
	ADC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS PSEDUO ELS
	STA SCREEN.DARK.DATA,Y
	
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**

.OFFSCREEN_C1.R3DOWN
;ROW = ELS + 3DOWN
	LDY SCREEN.DARK.ELS.FLOATING_TILE	;LOAD ELS PSEUDO LOCATION
	
	LDA SCREEN.INDEX.ROW,Y		;LOOKUP ROW OF CURRENT TILE		
	CMP #SCREEN.ROW.LAST		;IN LAST ROW?
	BNE .OFFSCREEN_C1.R3DOWN.CONTINUE		;IF NO, CONTINUE
	JMP .NEXT_TILE				;IF YES, NEXT TILE IN HOPPER (CURRENT COLUMN)

.OFFSCREEN_C1.R3DOWN.CONTINUE	
	TYA							;MOVE 1 ROW DOWN
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS PSEDUO ELS
	STA SCREEN.DARK.DATA,Y
	
	JMP .NEXT_TILE
@END	
	
	
.CALCULATE.ELS.LIGHT_OFFSCREEN.LEFT.C2	;C2 REFERS TO THE NUMBER OF COLUMNS OFFSCREEN FROM THE LEFT EDGE THE ELS IS
@START

.OFFSCREEN_C2.R0
;ROW = ELS	

;CALCULATE STARTING SCREEN TILE LOCATION (THE 1ST ON SCREEN COLUMN, SAME Y-AXIS AS ELS)	
	LDY SCREEN.MULTIPLY_TABLE, X
	STY SCREEN.DARK.ELS.ONSCREEN_ANCHOR	;SAVE ELS PSEUDO LOCATION

	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP PSEDUO ELS TILE LOCATION
	
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**	

.OFFSCREEN_C2.R1UP
;ROW = ELS + 1UP
	LDY SCREEN.DARK.ELS.ONSCREEN_ANCHOR	;LOAD ELS PSEUDO LOCATION
	
	LDA SCREEN.INDEX.ROW,Y			;LOOKUP ROW OF CURRENT TILE		
	CMP #$00						;IN FIRST ROW?
	BNE .OFFSCREEN_C2.R1UP.CONTINUE ;IF NO, CONTINUE
	JMP .OFFSCREEN_C2.R1DOWN		;IF YES, SKIP ALL ROWS UP FROM THE ELS, NEXT SECTION

.OFFSCREEN_C2.R1UP.CONTINUE	
	TYA							;MOVE 1 ROW UP
	SEC
	SBC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS PSEDUO ELS
	STA SCREEN.DARK.DATA,Y
	
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**
	
.OFFSCREEN_C2.R2UP
;ROW = ELS + 2UP
	LDY SCREEN.DARK.ELS.FLOATING_TILE	;LOAD ELS PSEUDO LOCATION
	
	LDA SCREEN.INDEX.ROW,Y			;LOOKUP ROW OF CURRENT TILE		
	CMP #$00						;IN FIRST ROW?
	BNE .OFFSCREEN_C2.R2UP.CONTINUE	;IF NO, CONTINUE
	JMP .OFFSCREEN_C2.R1DOWN		;IF YES, SKIP ALL ROWS UP FROM THE ELS, NEXT SECTION

.OFFSCREEN_C2.R2UP.CONTINUE	
	TYA							;MOVE 1 ROW UP
	SEC
	SBC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS PSEDUO ELS
	STA SCREEN.DARK.DATA,Y
	;**FALLS THROUGH**

	
.OFFSCREEN_C2.R1DOWN
;ROW = ELS + 1DOWN
	LDY SCREEN.DARK.ELS.ONSCREEN_ANCHOR	;LOAD ELS PSEUDO LOCATION
	
	LDA SCREEN.INDEX.ROW,Y				;LOOKUP ROW OF CURRENT TILE		
	CMP #SCREEN.ROW.LAST				;IN LAST ROW?
	BNE .OFFSCREEN_C2.R1DOWN.CONTINUE 	;IF NO, CONTINUE
	JMP .NEXT_TILE						;IF YES, NEXT TILE IN HOPPER (CURRENT COLUMN)

.OFFSCREEN_C2.R1DOWN.CONTINUE	
	TYA									;MOVE 1 ROW DOWN
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS PSEDUO ELS
	STA SCREEN.DARK.DATA,Y
	
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**
	
.OFFSCREEN_C2.R2DOWN
;ROW = ELS + 2DOWN
	LDY SCREEN.DARK.ELS.FLOATING_TILE	;LOAD ELS PSEUDO LOCATION
	
	LDA SCREEN.INDEX.ROW,Y				;LOOKUP ROW OF CURRENT TILE		
	CMP #SCREEN.ROW.LAST				;IN LAST ROW?
	BNE .OFFSCREEN_C2.R2DOWN.CONTINUE 	;IF NO, CONTINUE
	JMP .NEXT_TILE						;IF YES, NEXT TILE IN HOPPER (CURRENT COLUMN)

.OFFSCREEN_C2.R2DOWN.CONTINUE	
	TYA							;MOVE 1 ROW DOWN
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS PSEDUO ELS
	STA SCREEN.DARK.DATA,Y
	
	JMP .NEXT_TILE
@END	
	
.CALCULATE.ELS.LIGHT_OFFSCREEN.LEFT.C3	;C3 REFERS TO THE NUMBER OF COLUMNS OFFSCREEN FROM THE LEFT EDGE THE ELS IS
@START


.OFFSCREEN_C3.R0
;ROW = ELS	

;CALCULATE STARTING SCREEN TILE LOCATION (THE 1ST ON SCREEN COLUMN, SAME Y-AXIS AS ELS)	
	LDY SCREEN.MULTIPLY_TABLE, X
	STY SCREEN.DARK.ELS.ONSCREEN_ANCHOR	;SAVE ELS PSEUDO LOCATION

	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP PSEDUO ELS TILE LOCATION

	;**FALLS THROUGH**	

.OFFSCREEN_C3.R1UP
;ROW = ELS + 1UP
	
	LDA SCREEN.INDEX.ROW,Y			;LOOKUP ROW OF CURRENT TILE		
	CMP #$00						;IN FIRST ROW?
	BNE .OFFSCREEN_C3.R1UP.CONTINUE ;IF NO, CONTINUE
	JMP .OFFSCREEN_C3.R1DOWN		;IF YES, SKIP ALL ROWS UP FROM THE ELS, NEXT SECTION

.OFFSCREEN_C3.R1UP.CONTINUE	
	TYA							;MOVE 1 ROW UP
	SEC
	SBC #SCREEN.ARRAY.OFFSET
	TAY

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS PSEDUO ELS
	STA SCREEN.DARK.DATA,Y

	;**FALLS THROUGH**

.OFFSCREEN_C3.R1DOWN
;ROW = ELS + 1DOWN

	LDA SCREEN.INDEX.ROW,Y				;LOOKUP ROW OF CURRENT TILE		
	CMP #SCREEN.ROW.LAST				;IN LAST ROW?
	BNE .OFFSCREEN_C3.R1DOWN.CONTINUE 	;IF NO, CONTINUE
	JMP .NEXT_TILE						;IF YES, NEXT TILE IN HOPPER (CURRENT COLUMN)

.OFFSCREEN_C3.R1DOWN.CONTINUE	
	TYA									;MOVE 1 ROW DOWN
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	TAY
	
	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS PSEDUO ELS
	STA SCREEN.DARK.DATA,Y
	;**FALLS THROUGH**
	
	JMP .NEXT_TILE
@END

	
.NEXT_TILE
	
	INX 							;INCREMENT SCREEN.TILE.HOPPER INDEX
	CPX #SCREEN.COLUMN.SIZE
	BEQ .NEXT_COLUMN
	JMP	.LOOP.SEARCH.COLUMN

	
.NEXT_COLUMN



;RESTORE REGISTERS
	LDY SAVED.YREG.LOCAL1			;RESTORE COLUMN COUNTER
	
	INY								;INCREMENT COLUMN COUNTER
	CPY #$04						;Y-REG WAS INIT TO $01, SO 3 COLUMNS WITH AN INCREMENT AFTER THE CPY PUT THE STOP VALUE AT #$04
	BEQ .EXIT

;SAVE REGISTERS
	STY SAVED.YREG.LOCAL1			;SAVE COLUMN COUNTER
	
	JMP LOOP.SEARCH.OFFSCREEN.LEFT
	
.EXIT	
@END


SEARCH.OFFSCREEN.RIGHT.ENTRANCE
@START

;INIT VARIABLES
	LDY #$01						;COLUMN COUNTER
	STY SAVED.YREG.LOCAL1			;TRANSFER COLUMN COUNTER TO A VARIABLE SINCE Y-REG IS NEEDED FOR MULTIPLE TASKS. 
	
	;16-BIT ADD
	LDA SMAP						;INIT ROW COUNTER
	CLC
	ADC #OFFSET.SCREEN.UR			;OFFSET FROM SMAP TO CALCUALTE RMAP VALUE OF UPPER RIGHT SCREEN TILE
	STA SMAP.CURRENT
	
	LDA SMAP+$1
	ADC #$00
	STA SMAP.CURRENT+$1
	
LOOP.SEARCH.OFFSCREEN.RIGHT
;SEARCH THE 1ST COLUMN OFF THE RIGHT SIDE OF SCREEN
;MOVE 1 COLUMN OFF RIGHT SIDE OF SCREEN

	;16-BIT ADD
	LDA SMAP.CURRENT
	CLC
	ADC #OFFSET.HORIZONTAL
	STA SMAP.CURRENT
	
	LDA SMAP.CURRENT+$1
	ADC #$00
	STA SMAP.CURRENT+$1

	JSR TILE.LOOKUP.OFFSCREEN.COLUMN

;INIT VARIABLES
	LDX #$00						;SCREEN.TILE.HOPPER INDEX
	
.LOOP.SEARCH.COLUMN
	LDA SCREEN.TILE.HOPPER,X
	STA TEMP				;SAVE TILE_TYPE
	
	LDA PLAYER.MAP.LOCATION_TYPE
	CMP #LOCATION.TYPE.BUILDING
	BEQ .LOCATION_TYPE.BUILDING.TILES
	JMP	.NEXT_TILE
	
.LOCATION_TYPE.BUILDING.TILES
	LDA TEMP				;RESTORE TILE_TYPE
	CMP #DARK_FLAGS.ELS.EQ1
	BEQ .ELS.FOUND
	JMP	.NEXT_TILE
	
.ELS.FOUND	
	CPY #$01
	BEQ .CALCULATE.ELS.LIGHT_OFFSCREEN.RIGHT.C1		;C1 REFERS TO THE NUMBER OF COLUMNS OFFSCREEN FROM THE LEFT EDGE THE ELS IS
	CPY #$02
	BEQ .CALCULATE.ELS.LIGHT_OFFSCREEN.RIGHT.C2_STEP	;C2 REFERS TO THE NUMBER OF COLUMNS OFFSCREEN FROM THE LEFT EDGE THE ELS IS
	CPY #$03
	BEQ .CALCULATE.ELS.LIGHT_OFFSCREEN.RIGHT.C3_STEP	;C3 REFERS TO THE NUMBER OF COLUMNS OFFSCREEN FROM THE LEFT EDGE THE ELS IS
	
.ERROR
;UNEXPECTED VALUE IN Y-REG (OFFSCREEN COLUMN COUNTER)
	LDA TEXT
	LDA $C082
	BRK
	
.CALCULATE.ELS.LIGHT_OFFSCREEN.RIGHT.C2_STEP
	JMP .CALCULATE.ELS.LIGHT_OFFSCREEN.RIGHT.C2
	
.CALCULATE.ELS.LIGHT_OFFSCREEN.RIGHT.C3_STEP
	JMP .CALCULATE.ELS.LIGHT_OFFSCREEN.RIGHT.C3
	
	
	
.CALCULATE.ELS.LIGHT_OFFSCREEN.RIGHT.C1 				;C1 REFERS TO THE NUMBER OF COLUMNS OFFSCREEN FROM THE LEFT EDGE THE ELS IS
@START
.OFFSCREEN_C1.R0
;ROW = ELS	

;CALCULATE STARTING SCREEN TILE LOCATION (THE 1ST ON SCREEN COLUMN, SAME Y-AXIS AS ELS)	
	LDY SCREEN.LAST_COLUMN.TABLE, X
	STY SCREEN.DARK.ELS.ONSCREEN_ANCHOR	;SAVE ELS PSEUDO LOCATION

	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP PSEDUO ELS TILE LOCATION
	
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE

	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**	

.OFFSCREEN_C1.R1UP
;ROW = ELS + 1UP
	LDY SCREEN.DARK.ELS.ONSCREEN_ANCHOR	;LOAD ELS PSEUDO LOCATION
	
	LDA SCREEN.INDEX.ROW,Y			;LOOKUP ROW OF CURRENT TILE		
	CMP #$00						;IN FIRST ROW?
	BNE .OFFSCREEN_C1.R1UP.CONTINUE	;IF NO, CONTINUE
	JMP .OFFSCREEN_C1.R1DOWN		;IF YES, SKIP ALL ROWS UP FROM THE ELS, NEXT SECTION

.OFFSCREEN_C1.R1UP.CONTINUE	
	TYA								;MOVE 1 ROW UP
	SEC
	SBC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS PSEDUO ELS
	STA SCREEN.DARK.DATA,Y
	
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE

	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**
	
.OFFSCREEN_C1.R2UP
;ROW = ELS + 2UP
	LDY SCREEN.DARK.ELS.FLOATING_TILE	;LOAD ELS PSEUDO LOCATION
	
	LDA SCREEN.INDEX.ROW,Y			;LOOKUP ROW OF CURRENT TILE		
	CMP #$00						;IN FIRST ROW?
	BNE .OFFSCREEN_C1.R2UP.CONTINUE	;IF NO, CONTINUE
	JMP .OFFSCREEN_C1.R1DOWN		;IF YES, SKIP ALL ROWS UP FROM THE ELS, NEXT SECTION

.OFFSCREEN_C1.R2UP.CONTINUE	
	TYA								;MOVE 1 ROW UP
	SEC
	SBC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS PSEDUO ELS
	STA SCREEN.DARK.DATA,Y
	
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**

.OFFSCREEN_C1.R3UP
;ROW = ELS + 3UP
	LDY SCREEN.DARK.ELS.FLOATING_TILE	;LOAD ELS PSEUDO LOCATION
	
	LDA SCREEN.INDEX.ROW,Y			;LOOKUP ROW OF CURRENT TILE		
	CMP #$00						;IN FIRST ROW?
	BNE .OFFSCREEN_C1.R3UP.CONTINUE	;IF NO, CONTINUE
	JMP .OFFSCREEN_C1.R1DOWN		;IF YES, SKIP ALL ROWS UP FROM THE ELS, NEXT SECTION

.OFFSCREEN_C1.R3UP.CONTINUE	
	TYA								;MOVE 1 ROW UP
	SEC
	SBC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS PSEDUO ELS
	STA SCREEN.DARK.DATA,Y
	;**FALLS THROUGH**
	
.OFFSCREEN_C1.R1DOWN
;ROW = ELS + 1DOWN
	LDY SCREEN.DARK.ELS.ONSCREEN_ANCHOR	;LOAD ELS PSEUDO LOCATION
	
	LDA SCREEN.INDEX.ROW,Y				;LOOKUP ROW OF CURRENT TILE		
	CMP #SCREEN.ROW.LAST				;IN LAST ROW?
	BNE .OFFSCREEN_C1.R1DOWN.CONTINUE	;IF NO, CONTINUE
	JMP .NEXT_TILE						;IF YES, NEXT TILE IN HOPPER (CURRENT COLUMN)

.OFFSCREEN_C1.R1DOWN.CONTINUE	
	TYA									;MOVE 1 ROW DOWN
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS PSEDUO ELS
	STA SCREEN.DARK.DATA,Y
	
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE

	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**
	
.OFFSCREEN_C1.R2DOWN
;ROW = ELS + 2DOWN
	LDY SCREEN.DARK.ELS.FLOATING_TILE	;LOAD ELS PSEUDO LOCATION
	
	LDA SCREEN.INDEX.ROW,Y				;LOOKUP ROW OF CURRENT TILE		
	CMP #SCREEN.ROW.LAST				;IN LAST ROW?
	BNE .OFFSCREEN_C1.R2DOWN.CONTINUE	;IF NO, CONTINUE
	JMP .NEXT_TILE						;IF YES, NEXT TILE IN HOPPER (CURRENT COLUMN)

.OFFSCREEN_C1.R2DOWN.CONTINUE	
	TYA									;MOVE 1 ROW DOWN
	CLC	
	ADC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS PSEDUO ELS
	STA SCREEN.DARK.DATA,Y
	
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**

.OFFSCREEN_C1.R3DOWN
;ROW = ELS + 3DOWN
	LDY SCREEN.DARK.ELS.FLOATING_TILE	;LOAD ELS PSEUDO LOCATION
	
	LDA SCREEN.INDEX.ROW,Y		;LOOKUP ROW OF CURRENT TILE		
	CMP #SCREEN.ROW.LAST		;IN LAST ROW?
	BNE .OFFSCREEN_C1.R3DOWN.CONTINUE		;IF NO, CONTINUE
	JMP .NEXT_TILE				;IF YES, NEXT TILE IN HOPPER (CURRENT COLUMN)

.OFFSCREEN_C1.R3DOWN.CONTINUE	
	TYA							;MOVE 1 ROW DOWN
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS PSEDUO ELS
	STA SCREEN.DARK.DATA,Y
	
	JMP .NEXT_TILE
@END	
	
	
.CALCULATE.ELS.LIGHT_OFFSCREEN.RIGHT.C2	;C2 REFERS TO THE NUMBER OF COLUMNS OFFSCREEN FROM THE LEFT EDGE THE ELS IS
@START

.OFFSCREEN_C2.R0
;ROW = ELS	

;CALCULATE STARTING SCREEN TILE LOCATION (THE 1ST ON SCREEN COLUMN, SAME Y-AXIS AS ELS)	
	LDY SCREEN.LAST_COLUMN.TABLE, X
	STY SCREEN.DARK.ELS.ONSCREEN_ANCHOR	;SAVE ELS PSEUDO LOCATION

	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP PSEDUO ELS TILE LOCATION
	
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**	

.OFFSCREEN_C2.R1UP
;ROW = ELS + 1UP
	LDY SCREEN.DARK.ELS.ONSCREEN_ANCHOR	;LOAD ELS PSEUDO LOCATION
	
	LDA SCREEN.INDEX.ROW,Y			;LOOKUP ROW OF CURRENT TILE		
	CMP #$00						;IN FIRST ROW?
	BNE .OFFSCREEN_C2.R1UP.CONTINUE ;IF NO, CONTINUE
	JMP .OFFSCREEN_C2.R1DOWN		;IF YES, SKIP ALL ROWS UP FROM THE ELS, NEXT SECTION

.OFFSCREEN_C2.R1UP.CONTINUE	
	TYA							;MOVE 1 ROW UP
	SEC
	SBC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS PSEDUO ELS
	STA SCREEN.DARK.DATA,Y
	
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**
	
.OFFSCREEN_C2.R2UP
;ROW = ELS + 2UP
	LDY SCREEN.DARK.ELS.FLOATING_TILE	;LOAD ELS PSEUDO LOCATION
	
	LDA SCREEN.INDEX.ROW,Y			;LOOKUP ROW OF CURRENT TILE		
	CMP #$00						;IN FIRST ROW?
	BNE .OFFSCREEN_C2.R2UP.CONTINUE	;IF NO, CONTINUE
	JMP .OFFSCREEN_C2.R1DOWN		;IF YES, SKIP ALL ROWS UP FROM THE ELS, NEXT SECTION

.OFFSCREEN_C2.R2UP.CONTINUE	
	TYA							;MOVE 1 ROW UP
	SEC
	SBC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS PSEDUO ELS
	STA SCREEN.DARK.DATA,Y
	;**FALLS THROUGH**

	
.OFFSCREEN_C2.R1DOWN
;ROW = ELS + 1DOWN
	LDY SCREEN.DARK.ELS.ONSCREEN_ANCHOR	;LOAD ELS PSEUDO LOCATION
	
	LDA SCREEN.INDEX.ROW,Y				;LOOKUP ROW OF CURRENT TILE		
	CMP #SCREEN.ROW.LAST				;IN LAST ROW?
	BNE .OFFSCREEN_C2.R1DOWN.CONTINUE 	;IF NO, CONTINUE
	JMP .NEXT_TILE						;IF YES, NEXT TILE IN HOPPER (CURRENT COLUMN)

.OFFSCREEN_C2.R1DOWN.CONTINUE	
	TYA									;MOVE 1 ROW DOWN
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS PSEDUO ELS
	STA SCREEN.DARK.DATA,Y
	
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**
	
.OFFSCREEN_C2.R2DOWN
;ROW = ELS + 2DOWN
	LDY SCREEN.DARK.ELS.FLOATING_TILE	;LOAD ELS PSEUDO LOCATION
	
	LDA SCREEN.INDEX.ROW,Y				;LOOKUP ROW OF CURRENT TILE		
	CMP #SCREEN.ROW.LAST				;IN LAST ROW?
	BNE .OFFSCREEN_C2.R2DOWN.CONTINUE 	;IF NO, CONTINUE
	JMP .NEXT_TILE						;IF YES, NEXT TILE IN HOPPER (CURRENT COLUMN)

.OFFSCREEN_C2.R2DOWN.CONTINUE	
	TYA							;MOVE 1 ROW DOWN
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS PSEDUO ELS
	STA SCREEN.DARK.DATA,Y
	
	JMP .NEXT_TILE
@END	
	
.CALCULATE.ELS.LIGHT_OFFSCREEN.RIGHT.C3	;C3 REFERS TO THE NUMBER OF COLUMNS OFFSCREEN FROM THE LEFT EDGE THE ELS IS
@START

.OFFSCREEN_C3.R0
;ROW = ELS

;CALCULATE STARTING SCREEN TILE LOCATION (THE 1ST ON SCREEN COLUMN, SAME Y-AXIS AS ELS)	
	LDY SCREEN.LAST_COLUMN.TABLE, X
	STY SCREEN.DARK.ELS.ONSCREEN_ANCHOR	;SAVE ELS PSEUDO LOCATION

	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP PSEDUO ELS TILE LOCATION

	;**FALLS THROUGH**	

.OFFSCREEN_C3.R1UP
;ROW = ELS + 1UP
	
	LDA SCREEN.INDEX.ROW,Y			;LOOKUP ROW OF CURRENT TILE		
	CMP #$00						;IN FIRST ROW?
	BNE .OFFSCREEN_C3.R1UP.CONTINUE ;IF NO, CONTINUE
	JMP .OFFSCREEN_C3.R1DOWN		;IF YES, SKIP ALL ROWS UP FROM THE ELS, NEXT SECTION

.OFFSCREEN_C3.R1UP.CONTINUE	
	TYA							;MOVE 1 ROW UP
	SEC
	SBC #SCREEN.ARRAY.OFFSET
	TAY

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS PSEDUO ELS
	STA SCREEN.DARK.DATA,Y

	;**FALLS THROUGH**

.OFFSCREEN_C3.R1DOWN
;ROW = ELS + 1DOWN

	LDA SCREEN.INDEX.ROW,Y				;LOOKUP ROW OF CURRENT TILE		
	CMP #SCREEN.ROW.LAST				;IN LAST ROW?
	BNE .OFFSCREEN_C3.R1DOWN.CONTINUE 	;IF NO, CONTINUE
	JMP .NEXT_TILE						;IF YES, NEXT TILE IN HOPPER (CURRENT COLUMN)

.OFFSCREEN_C3.R1DOWN.CONTINUE	
	TYA									;MOVE 1 ROW DOWN
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	TAY
	
	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS PSEDUO ELS
	STA SCREEN.DARK.DATA,Y

	
	JMP .NEXT_TILE
@END

	
.NEXT_TILE

	INX 							;INCREMENT SCREEN.TILE.HOPPER INDEX
	CPX #SCREEN.COLUMN.SIZE
	BEQ .NEXT_COLUMN
	JMP	.LOOP.SEARCH.COLUMN

	
.NEXT_COLUMN
;RESTORE REGISTERS
	LDY SAVED.YREG.LOCAL1			;RESTORE COLUMN COUNTER
	
	INY								;INCREMENT COLUMN COUNTER
	CPY #$04						;Y-REG WAS INIT TO $01, SO 3 COLUMNS WITH AN INCREMENT AFTER THE CPY PUT THE STOP VALUE AT #$04
	BEQ .EXIT

;SAVE REGISTERS
	STY SAVED.YREG.LOCAL1			;SAVE COLUMN COUNTER
	
	JMP LOOP.SEARCH.OFFSCREEN.RIGHT
	
.EXIT
	
	;NEXT SECTION (OFFSCREEN TO THE RIGHT)
	



	
@END


SEARCH.OFFSCREEN.TOP.ENTRANCE
@START

;INIT VARIABLES
	LDY #$01						;COLUMN COUNTER
	STY SAVED.YREG.LOCAL1			;TRANSFER COLUMN COUNTER TO A VARIABLE SINCE Y-REG IS NEEDED FOR MULTIPLE TASKS. 
	
	LDA SMAP						;INIT ROW COUNTER
	STA SMAP.CURRENT
	
	LDA SMAP+$1
	STA SMAP.CURRENT+$1
	
LOOP.SEARCH.OFFSCREEN.TOP
;SEARCH THE 1ST COLUMN OFF THE TOP SIDE OF SCREEN
;MOVE 1 COLUMN OFF ABOVE TOP OF SCREEN

	;16-BIT SUBTRACT
	LDA SMAP.CURRENT
	SEC
	SBC #OFFSET.UP					
	STA SMAP.CURRENT
	
	LDA SMAP.CURRENT+$1
	SBC #$00
	STA SMAP.CURRENT+$1

	JSR TILE.LOOKUP.OFFSCREEN.ROW

	
			; LDA TROUBLESHOOTING.HOOK
			; CMP #$01
			; BNE .TEMP
			; LDA TEXT
			; LDA $C082
			; ; LDX #SCREEN.TILE.HOPPER
			; ; LDY /SCREEN.TILE.HOPPER
			; LDA #OFFSET.SCREEN.UR
			; LDX SMAP.CURRENT
			; LDY SMAP.CURRENT+$1
			; BRK
; .TEMP	
	
;INIT VARIABLES
	LDX #$00						;SCREEN.TILE.ROW.HOPPER INDEX
	
.LOOP.SEARCH.ROW

	LDA SCREEN.TILE.ROW.HOPPER,X
	STA TEMP				;SAVE TILE_TYPE
	
	LDA PLAYER.MAP.LOCATION_TYPE
	CMP #LOCATION.TYPE.BUILDING
	BEQ .LOCATION_TYPE.BUILDING.TILES
	JMP	.NEXT_TILE
	
.LOCATION_TYPE.BUILDING.TILES
	LDA TEMP				;RESTORE TILE_TYPE
	CMP #DARK_FLAGS.ELS.EQ1
	BEQ .ELS.FOUND
	JMP	.NEXT_TILE
	
.ELS.FOUND	
	CPY #$01
	BEQ .CALCULATE.ELS.LIGHT_OFFSCREEN.TOP.R1	;R1 REFERS TO THE NUMBER OF ROWS OFFSCREEN FROM THE LEFT EDGE THE ELS IS
	CPY #$02
	BEQ .CALCULATE.ELS.LIGHT_OFFSCREEN.TOP.R2_STEP	;R2 REFERS TO THE NUMBER OF ROWS OFFSCREEN FROM THE LEFT EDGE THE ELS IS
	CPY #$03
	BEQ .CALCULATE.ELS.LIGHT_OFFSCREEN.TOP.R3_STEP	;R3 REFERS TO THE NUMBER OF ROWS OFFSCREEN FROM THE LEFT EDGE THE ELS IS
	
.ERROR
;UNEXPECTED VALUE IN Y-REG (OFFSCREEN COLUMN COUNTER)
	LDA TEXT
	LDA $C082
	BRK
	
.CALCULATE.ELS.LIGHT_OFFSCREEN.TOP.R2_STEP
	JMP .CALCULATE.ELS.LIGHT_OFFSCREEN.TOP.R2
	
.CALCULATE.ELS.LIGHT_OFFSCREEN.TOP.R3_STEP
	JMP .CALCULATE.ELS.LIGHT_OFFSCREEN.TOP.R3
	
	
	
.CALCULATE.ELS.LIGHT_OFFSCREEN.TOP.R1 ;R1 REFERS TO THE NUMBER OF ROWS OFFSCREEN FROM THE TOP EDGE THE ELS IS
@START
.OFFSCREEN_C1.R0.LEFT
;ROW = TOP SCREEN EDGE, COLUMN = LEFT OF ELS	

;SET STARTING SCREEN LOCATION
;(starting screen location is equal to X-REG (the index to SCREEN.TILE,ROW.HOPPER). THIS IS BECAUSE THE FIRST ROW OF TILES ON SCREEN STARTS WITH A SCREEN TILE LOCATION OF $00. A LOOKUP TABLE IS REQUIRED WHEN DEALING WITH ALL OTHER SCREEN EDGES.)
	TXA
	TAY

	STY SCREEN.DARK.ELS.ONSCREEN_ANCHOR	;SAVE ELS PSEUDO LOCATION

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS ELS
	STA SCREEN.DARK.DATA,Y
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #$00					;IN FIRST COLUMN?
	BEQ .OFFSCREEN_C1.R0.RIGHT	;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #$00					;IN FIRST COLUMN?
	BEQ .OFFSCREEN_C1.R0.RIGHT	;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #$00					;IN FIRST COLUMN?
	BEQ .OFFSCREEN_C1.R0.RIGHT	;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALL THROUGH**

.OFFSCREEN_C1.R0.RIGHT
;ROW = TOP SCREEN EDGE, COLUMN = RIGHT OF ELS	
	LDY SCREEN.DARK.ELS.ONSCREEN_ANCHOR 	;LOAD PSEUDO ELS LOCATION
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #SCREEN.COLUMN.LAST		;IN LAST COLUMN?
	BEQ .OFFSCREEN_C1.R1DOWN.LEFT	;IF YES, NEXT SECTION
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #SCREEN.COLUMN.LAST		;IN FIRST COLUMN?
	BEQ .OFFSCREEN_C1.R1DOWN.LEFT	;IF YES, NEXT SECTION
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #SCREEN.COLUMN.LAST		;IN FIRST COLUMN?
	BEQ .OFFSCREEN_C1.R1DOWN.LEFT	;IF YES, NEXT SECTION
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**

.OFFSCREEN_C1.R1DOWN.LEFT
;ROW = TOP SCREEN EDGE+ 1DOWN, COLUMN = LEFT OF ELS	
	LDY SCREEN.DARK.ELS.ONSCREEN_ANCHOR 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.
	
	TYA							;MOVE 1 ROW DOWN
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS ELS
	STA SCREEN.DARK.DATA,Y
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP	#$00					;IN FIRST COLUMN?
	BEQ .OFFSCREEN.R1DOWN.RIGHT	;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #$00					;IN FIRST COLUMN?
	BEQ .OFFSCREEN.R1DOWN.RIGHT	;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**

	
.OFFSCREEN.R1DOWN.RIGHT	
;ROW = TOP SCREEN EDGE +1DOWN, COLUMN = RIGHT OF ELS	
	LDY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #SCREEN.COLUMN.LAST		;IN LAST COLUMN?
	BEQ .OFFSCREEN_C1.R2DOWN.LEFT	;IF YES, NEXT SECTION	
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #SCREEN.COLUMN.LAST		;IN FIRST COLUMN?
	BEQ .OFFSCREEN_C1.R2DOWN.LEFT	;IF YES, NEXT SECTION
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**

.OFFSCREEN_C1.R2DOWN.LEFT
;ROW = TOP SCREEN EDGE + 2DOWN, COLUMN = LEFT OF ELS	
	LDY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.
	
	TYA							;MOVE 1 ROW DOWN
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS ELS
	STA SCREEN.DARK.DATA,Y
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #$00					;IN FIRST COLUMN?
	BEQ .OFFSCREEN_C1.R2DOWN.RIGHT	;IF YES, NEXT SECTION	
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**

.OFFSCREEN_C1.R2DOWN.RIGHT
;ROW = TOP SCREEN EDGE + 2DOWN, COLUMN = RIGHT OF ELS	
	LDY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA SCREEN.INDEX.COLUMN,Y				;LOOKUP COLUMN OF CURRENT TILE		
	CMP #SCREEN.COLUMN.LAST					;IN LAST COLUMN?
	BNE .OFFSCREEN_C1.R2DOWN.RIGHT.CONTINUE	;IF NO, CONTINUE
	JMP .NEXT_TILE							;IF YES, EXIT
	
.OFFSCREEN_C1.R2DOWN.RIGHT.CONTINUE	
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	JMP .NEXT_TILE



@END	
	
	
.CALCULATE.ELS.LIGHT_OFFSCREEN.TOP.R2	;R2 REFERS TO THE NUMBER OF ROWS OFFSCREEN FROM THE TOP EDGE THE ELS IS
@START
.OFFSCREEN_C2.R0.LEFT
;ROW = TOP SCREEN EDGE, COLUMN = LEFT OF ELS	

;SET STARTING SCREEN LOCATION
;(starting screen location is equal to X-REG (the index to SCREEN.TILE,ROW.HOPPER). THIS IS BECAUSE THE FIRST ROW OF TILES ON SCREEN STARTS WITH A SCREEN TILE LOCATION OF $00. A LOOKUP TABLE IS REQUIRED WHEN DEALING WITH ALL OTHER SCREEN EDGES.)
	TXA
	TAY

	STY SCREEN.DARK.ELS.ONSCREEN_ANCHOR	;SAVE ELS PSEUDO LOCATION

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS ELS
	STA SCREEN.DARK.DATA,Y
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #$00					;IN FIRST COLUMN?
	BEQ .OFFSCREEN_C2.R0.RIGHT	;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #$00					;IN FIRST COLUMN?
	BEQ .OFFSCREEN_C2.R0.RIGHT	;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALL THROUGH**

.OFFSCREEN_C2.R0.RIGHT
;ROW = TOP SCREEN EDGE, COLUMN = RIGHT OF ELS	
	LDY SCREEN.DARK.ELS.ONSCREEN_ANCHOR 	;LOAD PSEUDO ELS LOCATION
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #SCREEN.COLUMN.LAST		;IN LAST COLUMN?
	BEQ .OFFSCREEN_C2.R1DOWN.LEFT	;IF YES, NEXT SECTION
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #SCREEN.COLUMN.LAST		;IN FIRST COLUMN?
	BEQ .OFFSCREEN_C2.R1DOWN.LEFT	;IF YES, NEXT SECTION
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE

	;**FALLS THROUGH**

.OFFSCREEN_C2.R1DOWN.LEFT
;ROW = TOP SCREEN EDGE+ 1DOWN, COLUMN = LEFT OF ELS	
	LDY SCREEN.DARK.ELS.ONSCREEN_ANCHOR 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.
	
	TYA							;MOVE 1 ROW DOWN
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS ELS
	STA SCREEN.DARK.DATA,Y
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP	#$00					;IN FIRST COLUMN?
	BEQ .OFFSCREEN_C2.R1DOWN.RIGHT	;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE

	;**FALLS THROUGH**

	
.OFFSCREEN_C2.R1DOWN.RIGHT	
;ROW = TOP SCREEN EDGE +1DOWN, COLUMN = RIGHT OF ELS	
	LDY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA SCREEN.INDEX.COLUMN,Y				;LOOKUP COLUMN OF CURRENT TILE		
	CMP #SCREEN.COLUMN.LAST					;IN LAST COLUMN?
	BNE .OFFSCREEN_C2.R1DOWN.RIGHT.CONTINUE	;IF NO, CONTINUE
	JMP .NEXT_TILE		
.OFFSCREEN_C2.R1DOWN.RIGHT.CONTINUE
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	JMP .NEXT_TILE

@END
	
.CALCULATE.ELS.LIGHT_OFFSCREEN.TOP.R3	;R3 REFERS TO THE NUMBER OF ROWS OFFSCREEN FROM THE TOP EDGE THE ELS IS
.OFFSCREEN_C3.R0.LEFT
;ROW = TOP SCREEN EDGE, COLUMN = LEFT OF ELS	

;SET STARTING SCREEN LOCATION
;(starting screen location is equal to X-REG (the index to SCREEN.TILE,ROW.HOPPER). THIS IS BECAUSE THE FIRST ROW OF TILES ON SCREEN STARTS WITH A SCREEN TILE LOCATION OF $00. A LOOKUP TABLE IS REQUIRED WHEN DEALING WITH ALL OTHER SCREEN EDGES.)
	TXA
	TAY

	STY SCREEN.DARK.ELS.ONSCREEN_ANCHOR	;SAVE ELS PSEUDO LOCATION

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS ELS
	STA SCREEN.DARK.DATA,Y
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #$00					;IN FIRST COLUMN?
	BEQ .OFFSCREEN_C3.R0.RIGHT	;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE

	;**FALL THROUGH**

.OFFSCREEN_C3.R0.RIGHT
;ROW = TOP SCREEN EDGE, COLUMN = RIGHT OF ELS	
	LDY SCREEN.DARK.ELS.ONSCREEN_ANCHOR 	;LOAD PSEUDO ELS LOCATION
	
	LDA SCREEN.INDEX.COLUMN,Y				;LOOKUP COLUMN OF CURRENT TILE		
	CMP #SCREEN.COLUMN.LAST					;IN LAST COLUMN?
	BNE .OFFSCREEN_C3.R0.RIGHT.CONTINUE	;IF NO, CONTINUE
	JMP .NEXT_TILE		
.OFFSCREEN_C3.R0.RIGHT.CONTINUE	
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	JMP .NEXT_TILE
	
.NEXT_TILE
	
	INX 							;INCREMENT SCREEN.TILE.HOPPER INDEX
	CPX #SCREEN.ROW.SIZE
	BEQ .NEXT_ROW
	JMP	.LOOP.SEARCH.ROW

	
.NEXT_ROW
;RESTORE REGISTERS
	LDY SAVED.YREG.LOCAL1			;RESTORE ROW COUNTER
	
	INY								;INCREMENT ROW COUNTER
	CPY #$04						;Y-REG WAS INIT TO $01, SO 3 ROW WITH AN INCREMENT AFTER THE CPY PUT THE STOP VALUE AT #$04
	BEQ .EXIT

;SAVE REGISTERS
	STY SAVED.YREG.LOCAL1			;SAVE ROW COUNTER
	
	JMP LOOP.SEARCH.OFFSCREEN.TOP
	
.EXIT	
@END



SEARCH.OFFSCREEN.BOTTOM.ENTRANCE
@START

;INIT VARIABLES
	LDY #$01						;COLUMN COUNTER
	STY SAVED.YREG.LOCAL1			;TRANSFER COLUMN COUNTER TO A VARIABLE SINCE Y-REG IS NEEDED FOR MULTIPLE TASKS. 
	
	;16-BIT
	LDA RMAP						;INIT ROW COUNTER
	CLC
	ADC #OFFSET.SCREEN.LL			;OFFSET TO PLAYER RMAP TO CALCUALTE THE RMAP OF TILE IN THE LOWER LEFT CORNER OF VIEW SCREEN
	STA SMAP.CURRENT
	
	LDA RMAP+$1
	ADC #$00
	STA SMAP.CURRENT+$1
	
LOOP.SEARCH.OFFSCREEN.BOTTOM
;SEARCH THE 1ST COLUMN BELOW THE BOTTOM EDGE OF SCREEN
;MOVE 1 COLUMN BELOW BOTTOM EDGE OF SCREEN

	;16-BIT ADD
	LDA SMAP.CURRENT
	CLC
	ADC #OFFSET.DOWN					
	STA SMAP.CURRENT
	
	LDA SMAP.CURRENT+$1
	ADC #$00
	STA SMAP.CURRENT+$1

	JSR TILE.LOOKUP.OFFSCREEN.ROW	
	
;INIT VARIABLES
	LDX #$00						;SCREEN.TILE.ROW.HOPPER INDEX
	
.LOOP.SEARCH.ROW

	LDA SCREEN.TILE.ROW.HOPPER,X
	STA TEMP				;SAVE TILE_TYPE
	
	LDA PLAYER.MAP.LOCATION_TYPE
	CMP #LOCATION.TYPE.BUILDING
	BEQ .LOCATION_TYPE.BUILDING.TILES
	JMP	.NEXT_TILE
	
.LOCATION_TYPE.BUILDING.TILES
	LDA TEMP				;RESTORE TILE_TYPE
	CMP #DARK_FLAGS.ELS.EQ1
	BEQ .ELS.FOUND
	JMP	.NEXT_TILE
	
.ELS.FOUND	
	CPY #$01
	BEQ .CALCULATE.ELS.LIGHT_OFFSCREEN.BOTTOM.R1	;R1 REFERS TO THE NUMBER OF ROWS OFFSCREEN FROM THE BOTTOM EDGE THAT THE ELS IS
	CPY #$02
	BEQ .CALCULATE.ELS.LIGHT_OFFSCREEN.BOTTOM.R2_STEP	;R2 REFERS TO THE NUMBER OF ROWS OFFSCREEN FROM THE BOTTOM EDGE THAT THE ELS IS
	CPY #$03
	BEQ .CALCULATE.ELS.LIGHT_OFFSCREEN.BOTTOM.R3_STEP	;R3 REFERS TO THE NUMBER OF ROWS OFFSCREEN FROM THE BOTTOM EDGE THAT THE ELS IS
	
.ERROR
;UNEXPECTED VALUE IN Y-REG (OFFSCREEN COLUMN COUNTER)
	LDA TEXT
	LDA $C082
	BRK
	
.CALCULATE.ELS.LIGHT_OFFSCREEN.BOTTOM.R2_STEP
	JMP .CALCULATE.ELS.LIGHT_OFFSCREEN.BOTTOM.R2
	
.CALCULATE.ELS.LIGHT_OFFSCREEN.BOTTOM.R3_STEP
	JMP .CALCULATE.ELS.LIGHT_OFFSCREEN.BOTTOM.R3
	
	
	
.CALCULATE.ELS.LIGHT_OFFSCREEN.BOTTOM.R1 ;R1 REFERS TO THE NUMBER OF ROWS OFFSCREEN FROM THE BOTTOM EDGE THAT THE ELS IS
@START
.OFFSCREEN_C1.R0.LEFT
;ROW = BOTTOM SCREEN EDGE, COLUMN = LEFT OF ELS	

;SET STARTING SCREEN LOCATION
	LDY SCREEN.LAST_ROW.TABLE,X

	STY SCREEN.DARK.ELS.ONSCREEN_ANCHOR	;SAVE ELS PSEUDO LOCATION

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS ELS
	STA SCREEN.DARK.DATA,Y
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #$00					;IN FIRST COLUMN?
	BEQ .OFFSCREEN_C1.R0.RIGHT	;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #$00					;IN FIRST COLUMN?
	BEQ .OFFSCREEN_C1.R0.RIGHT	;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #$00					;IN FIRST COLUMN?
	BEQ .OFFSCREEN_C1.R0.RIGHT	;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALL THROUGH**

.OFFSCREEN_C1.R0.RIGHT
;ROW = TOP SCREEN EDGE, COLUMN = RIGHT OF ELS	
	LDY SCREEN.DARK.ELS.ONSCREEN_ANCHOR 	;LOAD PSEUDO ELS LOCATION
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #SCREEN.COLUMN.LAST		;IN LAST COLUMN?
	BEQ .OFFSCREEN_C1.R1DOWN.LEFT	;IF YES, NEXT SECTION
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #SCREEN.COLUMN.LAST		;IN FIRST COLUMN?
	BEQ .OFFSCREEN_C1.R1DOWN.LEFT	;IF YES, NEXT SECTION
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #SCREEN.COLUMN.LAST		;IN FIRST COLUMN?
	BEQ .OFFSCREEN_C1.R1DOWN.LEFT	;IF YES, NEXT SECTION
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**

.OFFSCREEN_C1.R1DOWN.LEFT
;ROW = BOTTOM SCREEN EDGE+ 1DOWN, COLUMN = LEFT OF ELS	
	LDY SCREEN.DARK.ELS.ONSCREEN_ANCHOR 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.
	
	TYA							;MOVE 1 ROW DOWN
	SEC
	SBC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS ELS
	STA SCREEN.DARK.DATA,Y
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP	#$00					;IN FIRST COLUMN?
	BEQ .OFFSCREEN.R1DOWN.RIGHT	;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #$00					;IN FIRST COLUMN?
	BEQ .OFFSCREEN.R1DOWN.RIGHT	;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**

	
.OFFSCREEN.R1DOWN.RIGHT	
;ROW = BOTTOM SCREEN EDGE +1DOWN, COLUMN = RIGHT OF ELS	
	LDY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #SCREEN.COLUMN.LAST		;IN LAST COLUMN?
	BEQ .OFFSCREEN_C1.R2DOWN.LEFT	;IF YES, NEXT SECTION	
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #SCREEN.COLUMN.LAST		;IN FIRST COLUMN?
	BEQ .OFFSCREEN_C1.R2DOWN.LEFT	;IF YES, NEXT SECTION
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**

.OFFSCREEN_C1.R2DOWN.LEFT
;ROW = BOTTOM SCREEN EDGE + 2DOWN, COLUMN = LEFT OF ELS	
	LDY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.
	
	TYA							;MOVE 1 ROW DOWN
	SEC
	SBC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS ELS
	STA SCREEN.DARK.DATA,Y
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #$00					;IN FIRST COLUMN?
	BEQ .OFFSCREEN_C1.R2DOWN.RIGHT	;IF YES, NEXT SECTION	
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALLS THROUGH**

.OFFSCREEN_C1.R2DOWN.RIGHT
;ROW = BOTTOM SCREEN EDGE + 2DOWN, COLUMN = RIGHT OF ELS	
	LDY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA SCREEN.INDEX.COLUMN,Y				;LOOKUP COLUMN OF CURRENT TILE		
	CMP #SCREEN.COLUMN.LAST					;IN LAST COLUMN?
	BNE .OFFSCREEN_C1.R2DOWN.RIGHT.CONTINUE	;IF NO, CONTINUE
	JMP .NEXT_TILE							;IF YES, EXIT
	
.OFFSCREEN_C1.R2DOWN.RIGHT.CONTINUE	
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	JMP .NEXT_TILE



@END	
	
	
.CALCULATE.ELS.LIGHT_OFFSCREEN.BOTTOM.R2	;R2 REFERS TO THE NUMBER OF ROWS OFFSCREEN FROM THE BOTTOM EDGE THAT THE ELS IS
@START
.OFFSCREEN_C2.R0.LEFT
;ROW = BOTTOM SCREEN EDGE, COLUMN = LEFT OF ELS	

;SET STARTING SCREEN LOCATION
	LDY SCREEN.LAST_ROW.TABLE,X

	STY SCREEN.DARK.ELS.ONSCREEN_ANCHOR	;SAVE ELS PSEUDO LOCATION

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS ELS
	STA SCREEN.DARK.DATA,Y
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #$00					;IN FIRST COLUMN?
	BEQ .OFFSCREEN_C2.R0.RIGHT	;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #$00					;IN FIRST COLUMN?
	BEQ .OFFSCREEN_C2.R0.RIGHT	;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	;**FALL THROUGH**

.OFFSCREEN_C2.R0.RIGHT
;ROW = BOTTOM SCREEN EDGE, COLUMN = RIGHT OF ELS	
	LDY SCREEN.DARK.ELS.ONSCREEN_ANCHOR 	;LOAD PSEUDO ELS LOCATION
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #SCREEN.COLUMN.LAST		;IN LAST COLUMN?
	BEQ .OFFSCREEN_C2.R1DOWN.LEFT	;IF YES, NEXT SECTION
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE	
	CMP #SCREEN.COLUMN.LAST		;IN FIRST COLUMN?
	BEQ .OFFSCREEN_C2.R1DOWN.LEFT	;IF YES, NEXT SECTION
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE

	;**FALLS THROUGH**

.OFFSCREEN_C2.R1DOWN.LEFT
;ROW = BOTTOM SCREEN EDGE+ 1DOWN, COLUMN = LEFT OF ELS	
	LDY SCREEN.DARK.ELS.ONSCREEN_ANCHOR 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.
	
	TYA							;MOVE 1 ROW DOWN
	SEC
	SBC #SCREEN.ARRAY.OFFSET
	TAY
	
	STY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS ELS
	STA SCREEN.DARK.DATA,Y
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP	#$00					;IN FIRST COLUMN?
	BEQ .OFFSCREEN_C2.R1DOWN.RIGHT	;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE

	;**FALLS THROUGH**

	
.OFFSCREEN_C2.R1DOWN.RIGHT	
;ROW = BOTTOM SCREEN EDGE +1DOWN, COLUMN = RIGHT OF ELS	
	LDY SCREEN.DARK.ELS.FLOATING_TILE 	;ENABLES ITERATION THROUGH DIFFERENT ROWS OF THE LIGHTING PATTERN WITHOUT STARTING AT THE ELS SCREEN TILE LOCATION EACH TIME.

	LDA SCREEN.INDEX.COLUMN,Y				;LOOKUP COLUMN OF CURRENT TILE		
	CMP #SCREEN.COLUMN.LAST					;IN LAST COLUMN?
	BNE .OFFSCREEN_C2.R1DOWN.RIGHT.CONTINUE	;IF NO, CONTINUE
	JMP .NEXT_TILE		
.OFFSCREEN_C2.R1DOWN.RIGHT.CONTINUE
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	JMP .NEXT_TILE

@END
	
.CALCULATE.ELS.LIGHT_OFFSCREEN.BOTTOM.R3	;R3 REFERS TO THE NUMBER OF ROWS OFFSCREEN FROM THE BOTTOM EDGE THAT THE ELS IS
@START
.OFFSCREEN_C3.R0.LEFT
;ROW = BOTTOM SCREEN EDGE, COLUMN = LEFT OF ELS	

;SET STARTING SCREEN LOCATION
;(starting screen location is equal to X-REG (the index to SCREEN.TILE,ROW.HOPPER). THIS IS BECAUSE THE FIRST ROW OF TILES ON SCREEN STARTS WITH A SCREEN TILE LOCATION OF $00. A LOOKUP TABLE IS REQUIRED WHEN DEALING WITH ALL OTHER SCREEN EDGES.)
	LDY SCREEN.LAST_ROW.TABLE,X

	STY SCREEN.DARK.ELS.ONSCREEN_ANCHOR	;SAVE ELS PSEUDO LOCATION

	LDA #$00					;LIGHT UP TILE IN SAME COLUMN AS ELS
	STA SCREEN.DARK.DATA,Y
	
	LDA SCREEN.INDEX.COLUMN,Y	;LOOKUP COLUMN OF CURRENT TILE		
	CMP #$00					;IN FIRST COLUMN?
	BEQ .OFFSCREEN_C3.R0.RIGHT	;IF YES, NEXT SECTION
	DEY							;MOVE ONE TILE LEFT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE

	;**FALL THROUGH**

.OFFSCREEN_C3.R0.RIGHT
;ROW = TOP SCREEN EDGE, COLUMN = RIGHT OF ELS	
	LDY SCREEN.DARK.ELS.ONSCREEN_ANCHOR 	;LOAD PSEUDO ELS LOCATION
	
	LDA SCREEN.INDEX.COLUMN,Y				;LOOKUP COLUMN OF CURRENT TILE		
	CMP #SCREEN.COLUMN.LAST					;IN LAST COLUMN?
	BNE .OFFSCREEN_C3.R0.RIGHT.CONTINUE	;IF NO, CONTINUE
	JMP .NEXT_TILE		
.OFFSCREEN_C3.R0.RIGHT.CONTINUE	
	INY							;MOVE ONE TILE RIGHT
	LDA #$00
	STA SCREEN.DARK.DATA,Y		;LIGHT UP CURRENT TILE
	
	JMP .NEXT_TILE
@END
	
.NEXT_TILE
	
	INX 							;INCREMENT SCREEN.TILE.HOPPER INDEX
	CPX #SCREEN.ROW.SIZE
	BEQ .NEXT_ROW
	JMP	.LOOP.SEARCH.ROW

	
.NEXT_ROW
;RESTORE REGISTERS
	LDY SAVED.YREG.LOCAL1			;RESTORE ROW COUNTER
	
	INY								;INCREMENT ROW COUNTER
	CPY #$04						;Y-REG WAS INIT TO $01, SO 3 ROW WITH AN INCREMENT AFTER THE CPY PUT THE STOP VALUE AT #$04
	BEQ .EXIT

;SAVE REGISTERS
	STY SAVED.YREG.LOCAL1			;SAVE ROW COUNTER
	
	JMP LOOP.SEARCH.OFFSCREEN.BOTTOM
	
.EXIT	
@END

	
EXIT_ELS	
;RESTORE REGISTERS (ENTRY VALUES)

	PLA
	TAY
	PLA
	TAX
	
	RTS
@END	



DARKNESS.SCREEN.UPDATE ; ======ERASE TILES IF NEEDED======
@START
;PARAMETERS: NONE
;RETURN: UPDATED SCREEN.DARK.DATA
;ENTRANCE: DARKNESS.REVIEW

;FUNCTION: ERASE ANY TILES, NET OF SUN AND LIGHT SOURCES, THAT ARE DARK NOW BUT WEREN'T DARK BEFOE

;SAVE REGISTERS (ENTRY VALUES)
	TXA
	PHA
	TYA
	PHA


;INIT INDEXES	
	LDX #$00							;SCREEN ARRAY INDEX
	
.LOOP
	LDA SCREEN.DARK.DATA,X				;LOAD SCREEN POSITION OF CURRENT TILE BEING EVALUATED
	CMP #$01							;IS CURRENT TILE FLAGGED DARK?
	BNE .NEXTTILE						;IF NO, NEXT TILE

	LDA SCREEN.DARK.DATA_BEFORE,X		
	CMP #$01							;WAS CURRENT DARK BEFORE? (LAST MOVE)
	BEQ .NEXTTILE						;IF YES, NEXT FILE
	
	;X-REG IS PARAMETER (SCREEN TILE LOCATION)
	JSR ERASE.TILE						;ERASE TILES THAT ARE FLAGGED DARK NOW BUT WERE NOT FLAGGED DARK BEFORE
	
.NEXTTILE
	INX									;INCREMENT SCREEN TILE LOCATION
	CPX #SCREEN.ARRAY.LAST_ELEMENT2
	BNE .LOOP
	
.EXIT	
;RESTORE REGISTERS (ENTRY VALUES)

	PLA
	TAY
	PLA
	TAX
	
	RTS
	
@END
	
DARKNESS.OBS ;=====DARKNESS WHICH IS BASED ON OBSCURING TILES=====		
@START
;PARAMETERS: NONE
;RETURN VALUE: SCREEN.DARK (UPDATED)
;ENTRANCE: DARKNESS.REVIEW, DRIVER.DARKNESS (TROUBLESHOOTING)

;=====================SUBROUTINE DOCUMENTATION====================================
;
;==DARKNESS.OBS Details==
;
;***ADDING an obscuring tile: add another CMP/BEQ pair to INNERLOOP.REENTRY1
;
;The spreadsheet with all the all darkness algorithm diagrams is located at My_Code\RPG Project\Map\() darkness\Darkness Algorithm Charts. Several were split out and put in the documentation folder for quick reference as noted below. 
;
;The screen is broken up into 7 zones (diagram1, see My_code/documentation)
;). This routine has an algorithm for each designed to calculate darkness for 
;obscuring tiles found in its specific zone. Terminology note: an obscuring tile is any tile which obscures (blocks) the players view, such as a tall mountains or a wall. 
;
;The 7 algorithms are illustrated in diagram2 (see My_code/documentation)
;
;--Functionality Notes--
;*Two screen arrays are used to track which tiles are hidden by any 
;obscuring tiles on the screen. SCREEN.DARK.DATA and SCREEN.DARK.DATA_BEFORE. 
;The later reflects the darkness flag for each tile the move before, but 
;after screen scrolling for the current move was applied to the array. 
;This is to keep track of where the dark tiles on the screen actually 
;are when DARKNESS.CALCULATE runs it’s algorithms.
;
;*As the algorithms calculate what tiles should be dark, they call 
;ERASE.TILE to erase tiles that are flagged dark for the current move 
;but aren't flagged in screen.dark.data_before, which means a tile 
;graphic exists at that location on the screen. 
;
;*The first part of INNERLOOP makes calls to DRAWTILE (which calls 
;DRAW.TILE.SINGLE) to draw tiles that are not flagged as dark for the 
;current move but are flagged as dark in screen.dark.data_before 
;
;*DARKNESS.CALCULATE is skips it’s calculations for any tile that is 
;already flagged as dark for the current move. This is extremely 
;significant. The logic is, if the current tile is already flagged as 
;dark then even if that tile is an obscuring tile any pattern of darkness 
;it would create would overlap the pattern of darkness projected by 
;whatever obscuring tile cause the current tile to be dark. This hold up 
;mathematically. 
;
;*The efficiency of the prior technique is increased significantly by 
;the way the search for obscuring tiles is conducted. The search is done 
;using an expanding rectangle pattern starting from the center. A lookup 
;table stores the values for the expanding search rectangle. This is done 
;instead of simply starting at the first element of SCREEN.TILE.DATA and 
;iterating toward the end of the array for efficiency. The logic is, 
;obscuring tiles closest to the player will project the most darkness. 
;Since any tile flagged as dark can be skipped for obscuring tile analysis,
;finding obscuring tiles close to the player quickly is very advantageous.
;For example, if the player’s screen was covered entirely in mountains 
;except a small path, the algorithms would calculate the darkness for 
;the entire screen after expanding the first few tiles in the search 
;pattern. 
;
;The pattern of the search algorithm is illustrated in Diagram3 
;(see My_code/documentation)
;=================================================================================





;*********NOTE ON CODE STRUCTURE: This routine has a spaghetti-eque design to avoid JSRs and extra JMPs where possible,
;by keeping code in range for branches. The main logic is in OUTERLOOP and INNERLOOP. They routines make calls to ERASE.TILE, DRAWTILE, and when done control is transfered
;to DRAW.MISC to finish up a few odds and ends, and then finially exit via RTS.  

;TROUBLESHOOTING HOOK #3
	;JMP TESTENTRY


	

;IS DARKNESS DISABLED?
	LDA PLAYER.DARKNESS_OVERRIDE
	BEQ .START			
	RTS								;DARKNESS IS DISABLED, SO EXIT. 


.START
;SAVE REGISTERS (ENTRY VALUES)
	TXA
	PHA
	TYA
	PHA

;INIT VARIABLES
	LDX #$FF				;SET TO $FF SO INX CAN BE AT TOP OF OUTERLOOP, SINCE THE INTERLOOP DOESN'T HAVE A COMMON EXIT POINT
							;INDEX FOR SCREEN.DARK.SEARCH_INDEX

	LDY #$00				;INIT TO $00 SO FIRST CPY IN OUTERLOOP DOESN'T ACCIDENTALLY TRIGGER
	
;SAVE REGISTERS	(INTERNAL VAUES)	
	TXA						;REGISTERED NEED TO BE SAVED HERE BECAUSE THEY ARE RESTORED AT START OF OUTERLOOP, SO THAT THEY CAN BE SAVE (AFTER MODIFICAITON) AT END OF OUTERLOOP, BECAUSE INNERLOOP USES X-REG. AND INNERLOOP RETURNS TO OUTERLOOP SO THE REGISTERES HAVE TO BE RESTORED AT THE START OF OUTERLOOP IN ORDER FOR OUTERLOOP TO MODIFY THEM (X-REG SPECIFICALLY). 
	PHA

	JMP OUTERLOOP					;ENTRACE TO MAIN DARKNESS LOOP


DRAW.MISC 						;LOCATING EXIT HERE SAVES 133 JMP COMMANDS BY ALLOWING OUTERLOOP TO FALL INTO INNERLOOP. THIS IS BECASUE EXIT CAN'T BE LOCATED AT THE BOTTOM DUE TO THE "TYPE" SECTIONS OF CODE NOT HAVING A COMMON EXIT, WHICH IS TO AVOID A JMP IN EACH SECTION TO A COMMON EXIT (TOO FAR FOR BRANCH)
@START
;Y-REG CONTAINS SCREEN POSITION AS MAPPED TO SCREEN.TILE.DATA.

;DRAW ANY TILES (NOT DARK NOT, BUT WAS DARK BEFORE) NOT ALREADY DRAWN
;(THE OUTER/INNER LOOPS BELOW DON'T EXAMINE THE TILES ON THE EDGES OF THE SCREEN FOR PURPOSES OF DRAWING.
; THE DRAW.ROW/COLUMN.SINGLE ROUTES TAKE CARE OF THAT BUT ONLY ONE IS CALLED FOR A GIVEN MOVE.
; THIS ROUTINE DRAWS ANY TILES NEEDED IN WHICHVER ISN'T COVERED.
;
; FOR EXAMPLE; IF MOVING EAST, THE LAST COLUMN IS DRAWN BY DRAW.COLUMN.SINGLE. THE FIRST COLUMN ISN'T A CONCERN BECAUSE THE SCROLL IS MOVING IN THAT DIRECTION, PUSING THE FIRST COLUMN OFF THE SCREEN.
; BUT THE TOP AND BOTTOM ROW NEED TO BE REVIWED FOR TILES WHICH ARE NOT DARK NOW BUT WERE DARK BEFORE
	LDA #$0D					;SET TRACE
	STA CALLED_BY
		
	LDA CALLED_BY.DRAW.SCREEN				
	CMP #$01					;WAS THIS ROUTINE CALLED BY DRAW.SCREEN?
	BEQ .EXIT_STEP				;IF YES (==01), THEN EXIT
	
	LDA PLAYER.MOVE.CURRENT		;#$00=north, $01=south, $02=east, $03=west		
	CMP #$00
	BEQ	.MOVE.NORTH_SOUTH
	CMP #$01
	BEQ .MOVE.NORTH_SOUTH
	CMP #$02
	BEQ	.MOVE.EAST_WEST_STEP
	CMP #$03
	BEQ .MOVE.EAST_WEST_STEP
	JMP .ERROR

.MOVE.EAST_WEST_STEP
	JMP .MOVE.EAST_WEST
	
.EXIT_STEP
	JMP .EXIT
	
.MOVE.NORTH_SOUTH
@START
;**OPT** Speed. Create a lookup table with the screen.tile.data element numbers for the first and last column. That way routines like this and draw.column.single which are doing ADCs to increment can instead do INX/INY
				
	LDY #$00
	LDX #SCREEN.ARRAY.LAST_COLUMN_START
	STY SAVED.YREG.GLOBAL1
	
.NORTH_SOUTH.LOOP
;ONLY DRAW IF TILE IS NOT DARK NOW, BUT WAS DARK BEFORE	

;FIRST COLUMN	
	LDA SCREEN.DARK.DATA, Y					
	CMP SCREEN.DARK.DATA_BEFORE, Y
	BEQ .NORTH_SOUTH.LAST_COLUMN
	CMP #$00
	BNE .NORTH_SOUTH.LAST_COLUMN
	
	JSR DRAW.TILE.SINGLE
	
.NORTH_SOUTH.LAST_COLUMN
	LDA SCREEN.DARK.DATA, X					
	CMP SCREEN.DARK.DATA_BEFORE, X
	BEQ .NORTH_SOUTH.NEXT_TILE1
	CMP #$00
	BNE .NORTH_SOUTH.NEXT_TILE1
	
	TXA
	TAY
	JSR DRAW.TILE.SINGLE

.NORTH_SOUTH.NEXT_TILE1
	LDY SAVED.YREG.GLOBAL1
	CPY #SCREEN.ARRAY.LAST_ROW_START
	BEQ .NORTH_SOUTH.COLUMNS_DONE
	
	TYA
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	STA SAVED.YREG.GLOBAL1
	
	TXA
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	TAX
	
	JMP .NORTH_SOUTH.LOOP
.NORTH_SOUTH.COLUMNS_DONE

	LDA PLAYER.MOVE.CURRENT		;#$00=north, $01=south, $02=east, $03=west

	CMP #$00
	BEQ	.NORTH.BOTTOM_ROW
	CMP #$01
	BEQ .SOUTH.TOP_ROW
	JMP .ERROR
		
.NORTH.BOTTOM_ROW	
	LDY #SCREEN.ARRAY.LAST_ROW_START
.NORTH.LOOP
	LDA SCREEN.DARK.DATA, Y					
	CMP SCREEN.DARK.DATA_BEFORE, Y
	BEQ .NORTH.NEXT_TILE2
	CMP #$00
	BNE .NORTH.NEXT_TILE2
	
	JSR DRAW.TILE.SINGLE
	
.NORTH.NEXT_TILE2
	CPY #SCREEN.ARRAY.LAST_ELEMENT
	BEQ .EXIT_STEP
	INY
	JMP .NORTH.LOOP

.SOUTH.TOP_ROW
	LDY #$00
.SOUTH.LOOP
	LDA SCREEN.DARK.DATA, Y					
	CMP SCREEN.DARK.DATA_BEFORE, Y
	BEQ .SOUTH.NEXT_TILE2
	CMP #$00
	BNE .SOUTH.NEXT_TILE2
	
	JSR DRAW.TILE.SINGLE
	
.SOUTH.NEXT_TILE2
	CPY #SCREEN.ROW.SIZE
	BEQ .EXIT_STEP
	INY
	JMP .SOUTH.LOOP
	
@END	
.MOVE.EAST_WEST
@START					
	LDY #$00
	LDX #SCREEN.ARRAY.LAST_ROW_START
	STY SAVED.YREG.GLOBAL1
	
.LOOP.EAST_WEST
;ONLY DRAW IF TILE IS NOT DARK NOW, BUT WAS DARK BEFORE	
	
	LDA SCREEN.DARK.DATA, Y					
	CMP SCREEN.DARK.DATA_BEFORE, Y
	BEQ .OTHERROW1
	CMP #$00
	BNE .OTHERROW1
	
	JSR DRAW.TILE.SINGLE
	
.OTHERROW1
	LDA SCREEN.DARK.DATA, X					
	CMP SCREEN.DARK.DATA_BEFORE, X
	BEQ .NEXTTILE1
	CMP #$00
	BNE .NEXTTILE1
	
	TXA
	TAY
	JSR DRAW.TILE.SINGLE

.NEXTTILE1
	LDY SAVED.YREG.GLOBAL1
	CPY #SCREEN.ARRAY.LAST_COLUMN_START
	BEQ .EAST_WEST.ROWS_DONE
	INY
	INX
	STY SAVED.YREG.GLOBAL1
	JMP .LOOP.EAST_WEST
.EAST_WEST.ROWS_DONE
	
	
	LDA PLAYER.MOVE.CURRENT		;#$00=north, $01=south, $02=east, $03=west

	CMP #$02
	BEQ	.EAST.FIRST_COLUMN
	CMP #$03
	BEQ .WEST.LAST_COLUMN
	JMP .ERROR
	
.EAST.FIRST_COLUMN	

	LDY #$00

	
.EAST.LOOP
;ONLY DRAW IF TILE IS NOT DARK NOW, BUT WAS DARK BEFORE	

;FIRST COLUMN	
	LDA SCREEN.DARK.DATA, Y					
	CMP SCREEN.DARK.DATA_BEFORE, Y
	BEQ .EAST.NEXT_TILE
	CMP #$00
	BNE .EAST.NEXT_TILE
	
	JSR DRAW.TILE.SINGLE
	
.EAST.NEXT_TILE
	CPY #SCREEN.ARRAY.LAST_ROW_START
	BEQ .EXIT
	
	TYA
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	TAY
	
	JMP .EAST.LOOP
	
	

.WEST.LAST_COLUMN

	LDY #SCREEN.ARRAY.LAST_COLUMN_START
.WEST.LOOP
	LDA SCREEN.DARK.DATA, Y					
	CMP SCREEN.DARK.DATA_BEFORE, Y
	BEQ .WEST.NEXT_TILE
	CMP #$00
	BNE .WEST.NEXT_TILE
	
	JSR DRAW.TILE.SINGLE
	
.WEST.NEXT_TILE
	CPY #SCREEN.ARRAY.LAST_ELEMENT
	BEQ .EXIT
	
	TYA
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	TAY
	
	JMP .WEST.LOOP	
@END

.EXIT			
;RETORE REGISTERS (ENTRY VALUES)

	LDA #$00							;RESET TRACE
	STA CALLED_BY
		
	PLA
	TAY
	PLA
	TAX
	
	RTS
	
.ERROR
; DRAW.MISC REPORTS AN INVALID VALUE IN MOVE.CURRENT
;
;DISABLE.BS_RAM
	LDA $C082				;READ ENABLE ROM, DISABLE WRITE ON BSM (NORMAL STATE).
							;REQUIRED FOR BEFORE BRK BECAUSE APPLE MONITOR IS A ROM ROUTINE

	LDA TEXT
	BRK
	
DRAW.MISC.STEP
;BRANCH WAS OUT OF RANGE, THIS IS THE STEPPING STONE.
	JMP DRAW.MISC

@END
	
OUTERLOOP
@START
;INCREMENT THE CURRENT TILE BEING EVALUTED BASED IN SEARCH INDEX

;TROUBLESHOOTING HOOK #3
	;BRK
	
;RESTORE REGISTERS (INTERNAL VALUES)
	PLA
	TAX

	;SEARCH FOR OBSCURING TILES	
	CPX #SCREEN.DARK.SEARCH_INDEX.STOP	;HAS LAST INDEX BEEN READ IN?
	BEQ DRAW.MISC.STEP					;IF YES, EXIT LOOP, DO FINAL DRAW ROUTINES
	
	INX									;ADVANCE ONE ELEMENT IN THE SEARCH INDEX THAT PROVIDES THE Y-REG INDEX VALUES
	LDY SCREEN.DARK.SEARCH_INDEX, X		;NEXT TILE

;SAVE REGISTERS	(INTERNAL VALUES)
	TXA
	PHA

;TROUBLESHOOTING HOOK #3	
;TESTENTRY
;NOTE: TESTENTRY IS A LABEL, UNCOMMENT IT 
	
INNERLOOP
								
;SEARCH FOR OBSCURING TILES
	LDA SCREEN.DARK.DATA,Y				;LOAD SCREEN POSITION OF CURRENT TILE BEING EVALUATED

	;VETO THIS TILE?
	CMP #$01							;IS CURRENT TILE FLAGGED DARK?
	BEQ OUTERLOOP						;IF YES, NEXT TILE

	;DRAW CURRENT TILE?
	LDA SCREEN.DARK.DATA_BEFORE, Y		
	CMP #$01							;WAS CURRENT DARK BEFORE? (LAST MOVE)
	BEQ DRAWTILE						;IF YES, DRAW THE TILE
	
	;DETERMINE IF CURRENT TILE IS AN OBSCURING TILE
INNERLOOP.REENTRY1
	LDA SCREEN.TILE.DATA,Y				;GET TILE_TYPE OF CURRENT TILE
	CMP #DARK_FLAGS.EQ1					;OBSCURING TILE?
	BEQ	DARKNESS.CALCULATE
	CMP #DARK_FLAGS.EQ2
	BEQ	DARKNESS.CALCULATE
	
	;CHECK BUILDING TILE SET
	STA TEMP							;SAVE TILE TYPE
	LDA PLAYER.MAP.LOCATION_TYPE
	CMP #LOCATION.TYPE.BUILDING			;IS LOCATION TYPE = BUILDING?
	BNE NEXTTILE
	LDA TEMP							;RESTORE TILE TYPE
	CMP #DARK_FLAGS.EQ100
	BEQ	DARKNESS.CALCULATE	
	CMP #DARK_FLAGS.EQ101
	BEQ	DARKNESS.CALCULATE		
										;IF NOT OBSCURING TILE, NEXT TILE										
NEXTTILE
		
	JMP OUTERLOOP

DRAWTILE
;Y-REG CONTAINS SCREEN POSITION AS MAPPED TO SCREEN.TILE.DATA.

		LDA #$0E							;SET TRACE
		STA CALLED_BY	
	JSR DRAW.TILE.SINGLE
		LDA #$00							;RESET TRACE
		STA CALLED_BY	
		
	JMP INNERLOOP.REENTRY1
	
@END	

DARKNESS.CALCULATE
@START
;			TROUBLESHOOTING HOOK #2
;			TYA
;			STA $9400,Y
;			NOTE: TO USE, CHANGE $9400 TO A PAGE OF FREE MEMORY (OR AT LEAST TO $00-$BA). IN A DRIVER, SET THIS RANGE TO $00 BEFORE ENTERING OUTERLOOP. THIS 
;				HOOK WILL LOG EACH Y VALUE FOR WHICH DARKNESS IS CALCUALTED. THE Y VALUE CORRESPONDS TO THE SCREEN.TILE.DATA ELEMENT. 
	
;UPDATE SCREEN COLUMN & ROW
	LDA SCREEN.INDEX.ROW, Y
	STA SCREEN.DARK.ALGORITHM.ROW

	LDA SCREEN.INDEX.COLUMN, Y
	STA SCREEN.DARK.ALGORITHM.COLUMN

	
;DETERMINE ALGORITHM TYPE FOR THIS SCREEN LOCATION
	
	;assumes column index is in ACC at this point
	CMP #SCREEN.DARK.MIDDLE_COLUMN 
	BCC .GROUP1
	BEQ .GROUP2 

;default
.GROUP3
	LDA SCREEN.DARK.ALGORITHM.ROW
	CMP #SCREEN.DARK.MIDDLE_ROW
	BCC .TYPE5.JMP
	BEQ .TYPE6.JMP
	;DEFAULT
	JMP TYPE7
.TYPE5.JMP
	JMP TYPE5
.TYPE6.JMP
	JMP TYPE6
	
.GROUP2
	LDA SCREEN.DARK.ALGORITHM.ROW
	CMP #SCREEN.DARK.MIDDLE_ROW
	BCC .TYPE3.JMP
	;DEFAULT			;if the location is == column 8, and not < row 5, it must be > row 5, because it can't be == row 5. Column 8, row 5 is the player tile. A safegaurd exists in DARKNESS REVIEW to prevent the player tile from ever entering this routine.
	JMP TYPE4 
.TYPE3.JMP
	JMP TYPE3
	
.GROUP1

	LDA SCREEN.DARK.ALGORITHM.ROW
	CMP #SCREEN.DARK.MIDDLE_ROW 
	BCC TYPE0
	BEQ TYPE1

;**OPT** Memory (without compromising speed) I think type 2 & type 7 can be combined
;because they both use addition for the offset, and literally the only difference between these two routines
;appears to be the amount of the offset. currently constants are used but when the type is determined, the offset could be loaded into
;a variable based on the type and then JMP to a common routine.
;same logic applies to combining type 0 and type 5

;DEFAULT
TYPE2
@START

	
	STY SCREEN.DARK.ALGORITHM.LOCATION
.LOOP
	LDA SCREEN.DARK.ALGORITHM.LOCATION	;MOVE 1 TILE DOWN/LEFT
	CLC
	ADC #SCREEN.ARRAY.OFFSET_RIGHT_DIAGONAL
	STA SCREEN.DARK.ALGORITHM.LOCATION
	TAX
		
	LDA #$01
	STA SCREEN.DARK.DATA,X				;SET CURRENT TILE TO DARK
	CMP SCREEN.DARK.DATA_BEFORE,X		;WAS TILE DARK BEFORE?
			
;			STA TEMP
;			LDA GMAP
;			CMP #$54
;			BNE .TEMP
			;CPY #$68			;IT SHOULD SET DARK ON TILE X=$88 VIA TYPE2
;			CPX #$88
;			BNE .TEMP
			;JSR FLIP.PAGE
			;JSR KEYIN
;			LDA SCREEN.DARK.DATA_BEFORE,X
;			TAX
;			LDA TEXT
;			LDA PAGE1
;			BRK
;.TEMP
;			LDA TEMP
			
	BEQ .SKIPERASE						;IF YES, DON'T ERASE THE TILE
;**OPT** Speed. Include straight line code for erase.tile in each algorithm type 
;		to eliminate this JSR. a JMP out of the loop won't work because each TYPE loop calls the erase routine. 

			
	JSR ERASE.TILE						;IF NO, ERASE THE TILE	
.SKIPERASE
		
	LDA SCREEN.INDEX.ROW, X
	CMP #SCREEN.ROW.LAST				;HAVE WE REACHED ROWA?
	BEQ .EXIT						;IF YES, EXIT INNERLOOP
	LDA SCREEN.INDEX.COLUMN, X			;IF NO, HAVE WE REACHED COLUMN0
	CMP #$00
	BEQ .EXIT						;IF YES, EXIT INNERLOOP
		
	JMP .LOOP	

.EXIT
	JMP OUTERLOOP
	
@END
	
TYPE0
@START
	STY SCREEN.DARK.ALGORITHM.LOCATION
.LOOP
	LDA SCREEN.DARK.ALGORITHM.LOCATION	;MOVE 1 TILE UP/LEFT
	SEC 
	SBC #SCREEN.ARRAY.OFFSET_LEFT_DIAGONAL
	STA SCREEN.DARK.ALGORITHM.LOCATION
	TAX
		
	LDA #$01
	STA SCREEN.DARK.DATA,X				;SET CURRENT TILE TO DARK
	CMP SCREEN.DARK.DATA_BEFORE,X		;WAS TILE DARK BEFORE?
	BEQ .SKIPERASE						;IF YES, DON'T ERASE THE TILE
;**OPT** Speed. Include straight line code for erase.tile in each algorithm type 
;		to eliminate this JSR. a JMP out of the loop won't work because each TYPE loop calls the erase routine. 
		
		
	JSR ERASE.TILE						;IF NO, ERASE THE TILE	
.SKIPERASE
		
	LDA SCREEN.INDEX.ROW, X
	CMP #$00						;HAVE WE REACHED ROW0?
	BEQ .EXIT						;IF YES, EXIT INNERLOOP
	LDA SCREEN.INDEX.COLUMN, X		;IF NO, HAVE WE REACHED COLUMN0
	CMP #$00
	BEQ .EXIT						;IF YES, EXIT INNERLOOP
		
	JMP .LOOP	

.EXIT
	JMP OUTERLOOP

@END
	
TYPE1	;=====AXLE & ROD, LEFT======
@START		
		
;INIT LOOP VALUES
	TYA 										;Y-REG CONTAINS LOCATION OF CURRENT OBSCURING TILE 
	SEC
	SBC #SCREEN.ARRAY.OFFSET_LEFT_DIAGONAL		;SET START VALUE OF ROD
	STA SCREEN.DARK.ALGORITHM.LOCATION_START
	STA SCREEN.DARK.ALGORITHM.LOCATION_CURRENT
		
	TYA
	CLC
	ADC #SCREEN.ARRAY.OFFSET_RIGHT_DIAGONAL		;SET STOP VALUE OF ROD
	STA SCREEN.DARK.ALGORITHM.LOCATION_STOP

.LOOP	
	LDA SCREEN.DARK.ALGORITHM.LOCATION_CURRENT
	TAX									;TRANSFER CURRENT TILE LOCATION TO X-REG
	LDA #$01
	STA SCREEN.DARK.DATA,X				;SET CURRENT TILE TO DARK
	CMP SCREEN.DARK.DATA_BEFORE,X		;WAS TILE DARK BEFORE?		
	BEQ .SKIPERASE						;IF YES, DON'T ERASE THE TILE
;**OPT** Speed. Include straight line code for erase.tile in each algorithm type 
;		to eliminate this JSR. a JMP out of the loop won't work because each TYPE loop calls the erase routine. 		
	JSR ERASE.TILE						;IF NO, ERASE THE TILE
		
.SKIPERASE				
		
	CPX SCREEN.DARK.ALGORITHM.LOCATION_STOP	;REACHED END OF THE ROD? (DARKNESS TO BE PLOTTED IN THIS COLUMN)
	BEQ .NEXTCOLUMN						;IF YES, NEXT COLUMN
	
	LDA SCREEN.DARK.ALGORITHM.LOCATION_CURRENT
	CLC
	ADC #SCREEN.ARRAY.OFFSET					;NEXT DARKNESS TILE DOWN IN CURRENT COLUMN (ROD)
	STA SCREEN.DARK.ALGORITHM.LOCATION_CURRENT	
	
	JMP .LOOP
.NEXTCOLUMN
	
	LDA SCREEN.INDEX.ROW, X						;CHECK CURRENT ROW VALUE
	CMP #SCREEN.ROW.LAST						;REACHED BOTTOM ROW?
	BEQ .SKIPINC								;IF YES, DON'T INCREMENT STARTING ROW LOCATION OF DARKNESS
	;**OPT** Speed. If the screen size were !14 tiles wide or smaller, the above 3 lines aren't needed, because there wouldn't be enough columns to max out the rod length
	LDA SCREEN.INDEX.COLUMN,X					;CHECK CURRENT COLUMN VALUE
	CMP #$00									;REACHED LEFT EDGE OF SCREEN?
	BEQ .EXIT									;IF YES, EXIT (THIS ALGORITHM IS COMPLETE)

	LDA SCREEN.DARK.ALGORITHM.LOCATION_START	;IF NO, INCREMENT STARTING ROW/COLUMN 
	SEC
	SBC #SCREEN.ARRAY.OFFSET_LEFT_DIAGONAL
	STA SCREEN.DARK.ALGORITHM.LOCATION_START
	STA SCREEN.DARK.ALGORITHM.LOCATION_CURRENT
	
	LDA SCREEN.DARK.ALGORITHM.LOCATION_STOP		;INCREMENT STOP ROW/COLUMN
	CLC
	ADC #SCREEN.ARRAY.OFFSET_RIGHT_DIAGONAL
	STA SCREEN.DARK.ALGORITHM.LOCATION_STOP
	JMP .LOOP
.SKIPINC

	LDA SCREEN.INDEX.COLUMN,X					;CHECK CURRENT COLUMN VALUE
	CMP #$00									;REACHED LEFT EDGE OF SCREEN?
	BEQ .EXIT									;IF YES, EXIT (THIS ALGORITHM IS COMPLETE)

	
	DEC SCREEN.DARK.ALGORITHM.LOCATION_START	;INCREMENT STARTING COLUMN (KEEP ROW THE SAME, WE'RE AT THE TOP ROW ALREADY)
	LDA SCREEN.DARK.ALGORITHM.LOCATION_START
	STA SCREEN.DARK.ALGORITHM.LOCATION_CURRENT
	
	DEC SCREEN.DARK.ALGORITHM.LOCATION_STOP		;INCREMENT STOP COLUN (KEEP ROW THE SAME, WE'RE AT THE BOTTOM ROW ALREADY)
	JMP .LOOP
	
.EXIT				
	JMP OUTERLOOP
@END

	
TYPE3	;=====AXLE & ROD, UP======
@START
;INIT LOOP VALUES
	TYA 										;Y-REG CONTAINS LOCATION OF CURRENT OBSCURING TILE 
	SEC
	SBC #SCREEN.ARRAY.OFFSET_LEFT_DIAGONAL		;SET START VALUE OF ROD
	STA SCREEN.DARK.ALGORITHM.LOCATION_START
	STA SCREEN.DARK.ALGORITHM.LOCATION_CURRENT
		
	TYA
	SEC
	SBC #SCREEN.ARRAY.OFFSET_RIGHT_DIAGONAL		;SET STOP VALUE OF ROD
	STA SCREEN.DARK.ALGORITHM.LOCATION_STOP

.LOOP
	LDA SCREEN.DARK.ALGORITHM.LOCATION_CURRENT
	TAX									;TRANSFER CURRENT TILE LOCATION TO X-REG
	LDA #$01
	STA SCREEN.DARK.DATA,X				;SET CURRENT TILE TO DARK
	CMP SCREEN.DARK.DATA_BEFORE,X		;WAS TILE DARK BEFORE?
	BEQ .SKIPERASE						;IF YES, DON'T ERASE THE TILE
;**OPT** Speed. Include straight line code for erase.tile in each algorithm type 
;		to eliminate this JSR. a JMP out of the loop won't work because each TYPE loop calls the erase routine. 
		
	JSR ERASE.TILE						;IF NO, ERASE THE TILE	
.SKIPERASE				
	
	CPX SCREEN.DARK.ALGORITHM.LOCATION_STOP	;REACHED END OF THE ROD? (DARKNESS TO BE PLOTTED IN THIS COLUMN)
	BEQ .NEXTCOLUMN						;IF YES, NEXT COLUMN
	
	INC SCREEN.DARK.ALGORITHM.LOCATION_CURRENT	;NEXT DARKNESS TILE DOWN IN CURRENT COLUMN (ROD)
	
	JMP .LOOP
.NEXTCOLUMN
	
	LDA SCREEN.INDEX.ROW,X						;CHECK CURRENT COLUMN VALUE
	CMP #$00									;REACHED TOP ROW?
	BEQ .EXIT									;IF YES, EXIT (THIS ALGORITHM IS COMPLETE)
			
	LDA SCREEN.DARK.ALGORITHM.LOCATION_START	;IF NO, INCREMENT STARTING ROW/COLUMN 
	SEC
	SBC #SCREEN.ARRAY.OFFSET_LEFT_DIAGONAL
	STA SCREEN.DARK.ALGORITHM.LOCATION_START
	STA SCREEN.DARK.ALGORITHM.LOCATION_CURRENT
	
	LDA SCREEN.DARK.ALGORITHM.LOCATION_STOP		;INCREMENT STOP ROW/COLUMN
	SEC
	SBC #SCREEN.ARRAY.OFFSET_RIGHT_DIAGONAL
	STA SCREEN.DARK.ALGORITHM.LOCATION_STOP
	JMP .LOOP

	
.EXIT	
	JMP OUTERLOOP
	;RETURN VIA JMP TO THE UPPER LEVEL LOOP
@END
	
TYPE4	;=====AXLE & ROD, DOWN======	
@START		
;INIT LOOP VALUES
	TYA 										;Y-REG CONTAINS LOCATION OF CURRENT OBSCURING TILE 
	CLC
	ADC #SCREEN.ARRAY.OFFSET_RIGHT_DIAGONAL		;SET START VALUE OF ROD
	STA SCREEN.DARK.ALGORITHM.LOCATION_START
	STA SCREEN.DARK.ALGORITHM.LOCATION_CURRENT
		
	TYA
	CLC
	ADC #SCREEN.ARRAY.OFFSET_LEFT_DIAGONAL		;SET STOP VALUE OF ROD
	STA SCREEN.DARK.ALGORITHM.LOCATION_STOP

.LOOP
	LDA SCREEN.DARK.ALGORITHM.LOCATION_CURRENT
	TAX									;TRANSFER CURRENT TILE LOCATION TO X-REG
	LDA #$01
	STA SCREEN.DARK.DATA,X				;SET CURRENT TILE TO DARK
	CMP SCREEN.DARK.DATA_BEFORE,X		;WAS TILE DARK BEFORE?
	BEQ .SKIPERASE						;IF YES, DON'T ERASE THE TILE
;**OPT** Speed. Include straight line code for erase.tile in each algorithm type 
;		to eliminate this JSR. a JMP out of the loop won't work because each TYPE loop calls the erase routine. 	
		
	JSR ERASE.TILE						;IF NO, ERASE THE TILE	
.SKIPERASE				
	
	CPX SCREEN.DARK.ALGORITHM.LOCATION_STOP	;REACHED END OF THE ROD? (DARKNESS TO BE PLOTTED IN THIS COLUMN)
	BEQ .NEXTCOLUMN						;IF YES, NEXT COLUMN
	
	INC SCREEN.DARK.ALGORITHM.LOCATION_CURRENT	;NEXT DARKNESS TILE DOWN IN CURRENT COLUMN (ROD)
	
	JMP .LOOP
.NEXTCOLUMN
	
	LDA SCREEN.INDEX.ROW,X						;CHECK CURRENT COLUMN VALUE
	CMP #SCREEN.ROW.LAST						;REACHED BOTTOM OF SCREEN?
	BEQ .EXIT									;IF YES, EXIT (THIS ALGORITHM IS COMPLETE)
			
	LDA SCREEN.DARK.ALGORITHM.LOCATION_START	;IF NO, INCREMENT STARTING ROW/COLUMN 
	CLC
	ADC #SCREEN.ARRAY.OFFSET_RIGHT_DIAGONAL
	STA SCREEN.DARK.ALGORITHM.LOCATION_START
	STA SCREEN.DARK.ALGORITHM.LOCATION_CURRENT
	
	LDA SCREEN.DARK.ALGORITHM.LOCATION_STOP		;INCREMENT STOP ROW/COLUMN
	CLC
	ADC #SCREEN.ARRAY.OFFSET_LEFT_DIAGONAL
	STA SCREEN.DARK.ALGORITHM.LOCATION_STOP
	JMP .LOOP

	
.EXIT	

	JMP OUTERLOOP	
	;RETURN VIA JMP TO THE UPPER LEVEL LOOP
@END
	
TYPE5
@START
	STY SCREEN.DARK.ALGORITHM.LOCATION
.LOOP
	LDA SCREEN.DARK.ALGORITHM.LOCATION	;MOVE 1 TILE UP/RIGHT
	SEC 
	SBC #SCREEN.ARRAY.OFFSET_RIGHT_DIAGONAL
	STA SCREEN.DARK.ALGORITHM.LOCATION
	TAX
		
	LDA #$01
	STA SCREEN.DARK.DATA,X				;SET CURRENT TILE TO DARK
	CMP SCREEN.DARK.DATA_BEFORE,X		;WAS TILE DARK BEFORE?
	BEQ .SKIPERASE						;IF YES, DON'T ERASE THE TILE
;**OPT** Speed. Include straight line code for erase.tile in each algorithm type 
;		to eliminate this JSR. a JMP out of the loop won't work because each TYPE loop calls the erase routine. 

	JSR ERASE.TILE						;IF NO, ERASE THE TILE	
.SKIPERASE
			
	LDA SCREEN.INDEX.ROW, X
	CMP #$00							;HAVE WE REACHED ROW0?
	BEQ .EXIT							;IF YES, EXIT INNERLOOP
	LDA SCREEN.INDEX.COLUMN, X			;IF NO, HAVE WE REACHED COLUMN10
	CMP #SCREEN.COLUMN.LAST
	BEQ .EXIT							;IF YES, EXIT INNERLOOP
		
	JMP .LOOP	

.EXIT
	JMP OUTERLOOP
	
@END

TYPE6	;=====AXLE & ROD, RIGHT======
@START
;INIT LOOP VALUES

	TYA 										;Y-REG CONTAINS LOCATION OF CURRENT OBSCURING TILE 
	SEC
	SBC #SCREEN.ARRAY.OFFSET_RIGHT_DIAGONAL		;SET START VALUE OF ROD
	STA SCREEN.DARK.ALGORITHM.LOCATION_START
	STA SCREEN.DARK.ALGORITHM.LOCATION_CURRENT
		
	TYA
	CLC
	ADC #SCREEN.ARRAY.OFFSET_LEFT_DIAGONAL		;SET STOP VALUE OF ROD
	STA SCREEN.DARK.ALGORITHM.LOCATION_STOP

.LOOP
	LDA SCREEN.DARK.ALGORITHM.LOCATION_CURRENT
	TAX									;TRANSFER CURRENT TILE LOCATION TO X-REG
	LDA #$01
	STA SCREEN.DARK.DATA,X				;SET CURRENT TILE TO DARK
	CMP SCREEN.DARK.DATA_BEFORE,X		;WAS TILE DARK BEFORE?
	BEQ .SKIPERASE						;IF YES, DON'T ERASE THE TILE
;**OPT** Speed. Include straight line code for erase.tile in each algorithm type 
;		to eliminate this JSR. a JMP out of the loop won't work because each TYPE loop calls the erase routine. 
		
	JSR ERASE.TILE						;IF NO, ERASE THE TILE	
.SKIPERASE				
	
	CPX SCREEN.DARK.ALGORITHM.LOCATION_STOP	;REACHED END OF THE ROD? (DARKNESS TO BE PLOTTED IN THIS COLUMN)
	BEQ .NEXTCOLUMN						;IF YES, NEXT COLUMN
	
	LDA SCREEN.DARK.ALGORITHM.LOCATION_CURRENT
	CLC
	ADC #SCREEN.ARRAY.OFFSET					;NEXT DARKNESS TILE DOWN IN CURRENT COLUMN (ROD)
	STA SCREEN.DARK.ALGORITHM.LOCATION_CURRENT	
	
	JMP .LOOP
.NEXTCOLUMN

			
	LDA SCREEN.INDEX.ROW, X						;CHECK CURRENT ROW VALUE
	CMP #SCREEN.ROW.LAST						;REACHED BOTTOM ROW?
	BEQ .SKIPINC								;IF YES, DON'T INCREMENT STARTING ROW LOCATION OF DARKNESS
	;**OPT** Speed. If the screen size were !14 tiles wide or smaller, the above 3 lines aren't needed, because there wouldn't be enough columns to max out the rod length
	LDA SCREEN.INDEX.COLUMN,X					;CHECK CURRENT COLUMN VALUE
	CMP #SCREEN.COLUMN.LAST						;REACHED RIGHT EDGE OF SCREEN?
	BEQ .EXIT									;IF YES, EXIT (THIS ALGORITHM IS COMPLETE)

	LDA SCREEN.DARK.ALGORITHM.LOCATION_START	;IF NO, INCREMENT STARTING ROW/COLUMN 
	SEC
	SBC #SCREEN.ARRAY.OFFSET_RIGHT_DIAGONAL
	STA SCREEN.DARK.ALGORITHM.LOCATION_START
	STA SCREEN.DARK.ALGORITHM.LOCATION_CURRENT
	
	LDA SCREEN.DARK.ALGORITHM.LOCATION_STOP		;INCREMENT STOP ROW/COLUMN
	CLC
	ADC #SCREEN.ARRAY.OFFSET_LEFT_DIAGONAL
	STA SCREEN.DARK.ALGORITHM.LOCATION_STOP
	JMP .LOOP
.SKIPINC

	LDA SCREEN.INDEX.COLUMN,X					;CHECK CURRENT COLUMN VALUE
	CMP #SCREEN.COLUMN.LAST						;REACHED LEFT EDGE OF SCREEN?
	BEQ .EXIT									;IF YES, EXIT (THIS ALGORITHM IS COMPLETE)

	
	INC SCREEN.DARK.ALGORITHM.LOCATION_START	;INCREMENT STARTING COLUMN (KEEP ROW THE SAME, WE'RE AT THE TOP ROW ALREADY)
	LDA SCREEN.DARK.ALGORITHM.LOCATION_START
	STA SCREEN.DARK.ALGORITHM.LOCATION_CURRENT
	
	INC SCREEN.DARK.ALGORITHM.LOCATION_STOP		;INCREMENT STOP COLUN (KEEP ROW THE SAME, WE'RE AT THE BOTTOM ROW ALREADY)
	JMP .LOOP
	
.EXIT	
	JMP OUTERLOOP
	;RETURN VIA JMP TO THE UPPER LEVEL LOOP
@END

TYPE7
@START
	STY SCREEN.DARK.ALGORITHM.LOCATION
.LOOP
	LDA SCREEN.DARK.ALGORITHM.LOCATION	;MOVE 1 TILE DOWN/RIGHT
	CLC
	ADC #SCREEN.ARRAY.OFFSET_LEFT_DIAGONAL
	STA SCREEN.DARK.ALGORITHM.LOCATION
	TAX
		
	LDA #$01
	STA SCREEN.DARK.DATA,X				;SET CURRENT TILE TO DARK
	CMP SCREEN.DARK.DATA_BEFORE,X		;WAS TILE DARK BEFORE?
	BEQ .SKIPERASE						;IF YES, DON'T ERASE THE TILE
;**OPT** Speed. Include straight line code for erase.tile in each algorithm type 
;		to eliminate this JSR. a JMP out of the loop won't work because each TYPE loop calls the erase routine. 

			
	JSR ERASE.TILE						;IF NO, ERASE THE TILE	
.SKIPERASE	
		
	LDA SCREEN.INDEX.ROW, X
	CMP #SCREEN.ROW.LAST				;HAVE WE REACHED ROWA?
	BEQ .EXIT						;IF YES, EXIT INNERLOOP
	LDA SCREEN.INDEX.COLUMN, X			;IF NO, HAVE WE REACHED COLUMN10
	CMP #SCREEN.COLUMN.LAST
	BEQ .EXIT						;IF YES, EXIT INNERLOOP
		
	JMP .LOOP

@END	
@END

.EXIT
	JMP OUTERLOOP

@END

;======INCLUDE FILES======

				
;======DEFINE VARIABLES===



;ORIGINAL TESTING NOTES
@START
;TEST (REMOVE)
;E/W TEST
;SCREEN.DARK.DATA	.HS	00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00
;N/S TEST
;SCREEN.DARK.DATA	.HS 00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00

;INIT VALUES ON NORTH MOVE TEST
;SCREEN.DARK.DATA .HS 00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01

;*****TESTING VARIABLES******

;lots of mountains BOTTOM/RIGHT
;SCREEN.TILE.DATA 	.HS 00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.03.03.00.00.00.00.00.00.00.00.00.00.00.00.00.03.03.03.03.00.00.00.00.00.00.00.00.00.00.AA.00.00.03.03.03.03.00.00.00.00.00.00.00.00.00.00.00.00.03.03.03.03.03.03.00.00.00.00.00.00.00.00.00.00.03.03.03.03.03.03.03.03.00.00.00.00.00.03.03.03.03.03.03.03.03.03.03.03.03.00.00.00.00.03.03.03.03.03.03.03.03.03.03.03.03.03.00.00.00.03.03.03.03.03.03.03.03.03.03.03.03.03.03


;moutain at $6E, downward axle/rod
;SCREEN.TILE.DATA	 .HS 00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00




;RAW DATA TO FOR CREATING TEST SCREEN.TILE.ARRAY
;PLAYER TILE IS THE $AA VALUE.

;this one is blank except for player $AA value (change that to $00)
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.

;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.AA.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.

;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00

;below this point has some mountains ($03) set


;SCREEN.TILE.DATA 				.HS 00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.

;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.03.AA.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.

;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.


;SCREEN.TILE.DATA 		.HS	00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00

;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.03.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.03.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.03.00.00.00.00.00.00.00.

;00.00.00.00.00.00.00.00.00.03.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.AA.03.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.

;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00





;SCREEN.TILE.DATA .HS 00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.03.03.00.00.00.00.00.00.00.00.00.00.00.00.00.03.03.03.03.00.00.00.00.00.00.00.00.00.00.00.00.00.03.03.03.03.00.00.00.00.00.00.00.00.00.00.00.00.00.03.03.03.03.00.00.00.00.AA.00.00.00.00.00.00.00.00.03.03.03.03.00.00.00.00.00.00.00.00.00.00.00.00.00.03.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00

;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.03.03.03.00.00.00.00.00.00.00.00.00.00.00.00.00.
;03.03.03.03.00.00.00.00.00.00.00.00.00.00.00.00.00.

;03.03.03.03.00.00.00.00.00.00.00.00.00.00.00.00.00.
;03.03.03.03.00.00.00.00.AA.00.00.00.00.00.00.00.00.
;03.03.03.03.00.00.00.00.00.00.00.00.00.00.00.00.00.
;03.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.

;03.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00



;SCREEN.TILE.DATA .HS 00.00.00.00.00.03.00.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.00.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.00.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.00.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.00.03.03.03.03.00.00.00.00.00.00.00.00.00.00.00.03.00.00.00.00.03.00.00.00.00.00.00.00.00.00.00.00.03.03.03.03.00.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.00.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.00.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.00.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.00.03.00.00.00.00.00.00

;00.00.00.00.00.03.00.03.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.03.00.03.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.03.00.03.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.03.00.03.00.00.00.00.00.00.00.00.00.

;00.00.00.00.00.03.00.03.03.03.03.00.00.00.00.00.00.
;00.00.00.00.00.03.00.00.AA.00.03.00.00.00.00.00.00.
;00.00.00.00.00.03.03.03.03.00.03.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.03.00.03.00.00.00.00.00.00.

;00.00.00.00.00.00.00.00.03.00.03.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.03.00.03.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.03.00.03.00.00.00.00.00.00





;SCREEN.TILE.DATA .HS 00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00

;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.

;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.03.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.

;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00



;lots of mountains on bottom and right side


;SCREEN.TILE.DATA 		.HS 00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.03.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.03.03.00.00.00.00.00.00.00.00.00.00.00.00.00.03.03.03.03.00.00.00.00.00.00.00.00.00.00.AA.00.00.03.03.03.03.00.00.00.00.00.00.00.00.00.00.00.00.03.03.03.03.03.03.00.00.00.00.00.00.00.00.00.00.03.03.03.03.03.03.03.03.00.00.00.00.00.03.03.03.03.03.03.03.03.03.03.03.03.00.00.00.00.03.03.03.03.03.03.03.03.03.03.03.03.03.00.00.00.03.03.03.03.03.03.03.03.03.03.03.03.03.03

;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.03.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.03.03.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.03.03.03.00.00.

;00.00.00.00.00.00.00.00.00.00.00.03.03.03.03.00.00.
;00.00.00.00.00.00.00.00.AA.00.00.03.03.03.03.00.00.
;00.00.00.00.00.00.00.00.00.00.03.03.03.03.03.03.00.
;00.00.00.00.00.00.00.00.00.03.03.03.03.03.03.03.03.

;00.00.00.00.00.03.03.03.03.03.03.03.03.03.03.03.03.
;00.00.00.00.03.03.03.03.03.03.03.03.03.03.03.03.03.
;00.00.00.03.03.03.03.03.03.03.03.03.03.03.03.03.03

;****SCREEN.DARK.DATA TEMPLATES*******



;SCREEN.DARK.DATA	.HS	00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00

;00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.
;00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.
;00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.
;00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.

;00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.
;00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.
;00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.
;00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.

;00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.
;00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00.
;00.01.00.00.00.00.00.00.00.00.00.00.00.01.00.00.00




;SCREEN.DARK.DATA	.HS 00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00

;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.

;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.

;01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00






;SCREEN.DARK.DATA .HS 00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.0001.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.

;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.

;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.

;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.
;01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01


;ALL 1s
;SCREEN.DARK.DATA .HS 01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01


;STARTED SOMETHING HERE BUT DIDN'T FINISH IT
;01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.
;01.01.00.00.00.00.00.00.00.00.00.00.00.00.00.00.01.
;01.01.00.00.00.00.00.00.00.00.00.00.00.00.00.00.01.
;01.01.00.00.00.00.00.00.00.00.00.00.00.00.00.00.01.

;01.01.00.00.00.00.00.00.00.00.00.00.00.00.00.00.01.
;01.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.01.
;01.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.01.
;01.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.01.

;01.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.01.
;01.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.01.
;01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01

@END
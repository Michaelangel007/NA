;************************INCLUDE FILE*****************************
;(do not assemble stand-alone. For a stand-alone version of this routine see examples/rwts2)

;=====================MAP_OBJECT_MANAGEMENT.ASM DOCUMENTATION====================================
;
;See Chart 1.2 (my_code/documentation) for an illistration of the flow control
;of MO.DRAW. The other subroutines have very straightforward flow control.
;
;The subroutines in this file have the following functions:
;	MO.BOARD		player presses key to board a map object 
;	MO.XIT			player presses key to exit a map object 
;	MO.CREATE		create a new transport map object using parameters passed
;	MO.DRAW			draw map objects on the screen, handle mob moves
;  MOB.GENERATION	randomly generate mobs in a random location, random mob type. nothing predictable here...it's all random. 
;
;
;=================================================================================


MO.BOARD ; ========PLAYER ATTEMPTS BOARD MAP OBJECT======
@START
;PARAMETERS: NONE
;ENTRANCE: DIRECT
;RETURN: PLAYER.TILE.ACTIVE, PLAYER.TRANSPORT.ACTIVE

;=====================SUBROUTINE DOCUMENTATION====================================
;
;This subroutine is called by GAME.PRIMARY_LOOP when the player executes the command
;to (B)oard a transport map object. 
;
;The player's screen tile location is checked for a transport map object and if one exists
;the variables that track active transport and the player icon's tile are updated to reflect the 
;transport object that was boarded.
;
;Additional checks apply for Frigates as they can carry skiffs. If the Frigate
;already has the max number of skiffs, and the player's active transport is a skiff, then 
;the board attempt fails. 
;=================================================================================

;NOTE: An active transport map object is removed from the screen array.
				
;VERIFY A TRANSPORT IS AT PLAYER LOCATION
	LDY #SCREEN.ARRAY.PLAYER_LOCATION
	LDA SCREEN.MO_TRANSPORT.DATA,Y				;LOAD TRANSPORT MO RECORD INDEX FROM SCREEN ARRAY FOR CURRENT PLAYER LOCATION
	CMP #$FF									;IS RECORD EMPTY? (I.E. NO MO AT THIS LOCATION)
	BEQ BOARD.NOTHING_TO_BOARD_STEP				;IF YES, EXIT
	TAX											;IF NO, USE INDEX TO LOOKUP TILE TYPE OF MO FROM MO RECORD.

;BOARD THE TRANSPORT OBJECT	
	LDA MAP_OBJECTS.TRANSPORT+$2,X				;LOAD TILE TYPE OF TRANSPORT	
	CMP #TILE_ID.HORSE_C						;BRANCH BASED ON THE TYPE OF TRASNPORT MO AT THE PLAYER LOCATION
	BEQ BOARD.HORSE
	CMP #TILE_ID.FRIGATE1.1
	BEQ BOARD.FRIGATE
	CMP #TILE_ID.CARAVEL
	BEQ BOARD.CARAVEL
	CMP #TILE_ID.WYVERN
	BEQ BOARD.WYVERN
	CMP #TILE_ID.SKIFF
	BEQ BOARD.SKIFF
	;**FALLS THROUGH

.ERROR											;IF TILE_TYPE NOT RECOGNIZED, ERROR OUT
;TILE_TYPE OF TRANSPORT PLAYER ATTEMPTED TO BOARD NOT RECOGNIZED IN MO.BOARD
;
;DISABLE.BS_RAM
	LDA $C082				;READ ENABLE ROM, DISABLE WRITE ON BSM (NORMAL STATE).
							;REQUIRED FOR BEFORE BRK BECAUSE APPLE MONITOR IS A ROM ROUTINE

	LDA TEXT
	BRK

@MIDDLE
BOARD.NOTHING_TO_BOARD_STEP
	JMP BOARD.NOTHING_TO_BOARD
	
BOARD.WYVERN
	;***NOTHING ELSE TO DO, TRANSPORT MO INDEX ALREADY SAVED TO PLAYER.TRANSPORT.ACTIVE		
	STA PLAYER.TILE.ACTIVE					;STORES HORSE AS THE ACTIVE TRASNPORT TILE
	STX PLAYER.TRANSPORT.ACTIVE					;SAVE INDEX TO BOARDED OBJECT, TO LINK THE PLAYER TO THIS TRANSPORT MO RECORD

	JMP BOARD.EXIT
	
BOARD.HORSE
	;***NOTHING ELSE TO DO, TRANSPORT MO INDEX ALREADY SAVED TO PLAYER.TRANSPORT.ACTIVE		
	STA PLAYER.TILE.ACTIVE					;STORES HORSE AS THE ACTIVE TRASNPORT TILE
	STX PLAYER.TRANSPORT.ACTIVE					;SAVE INDEX TO BOARDED OBJECT, TO LINK THE PLAYER TO THIS TRANSPORT MO RECORD

	JMP BOARD.EXIT

BOARD.SKIFF				
	STA PLAYER.TILE.ACTIVE					;STORES SKIFF AS THE ACTIVE TRASNPORT TILE
	STX PLAYER.TRANSPORT.ACTIVE					;SAVE INDEX TO BOARDED OBJECT, TO LINK THE PLAYER TO THIS TRANSPORT MO RECORD
	JMP BOARD.EXIT

BOARD.CARAVEL
	STA PLAYER.TILE.ACTIVE					;STORES SKIFF AS THE ACTIVE TRASNPORT TILE
	STX PLAYER.TRANSPORT.ACTIVE					;SAVE INDEX TO BOARDED OBJECT, TO LINK THE PLAYER TO THIS TRANSPORT MO RECORD
	JMP BOARD.EXIT	
	

@MIDDLE	
BOARD.FRIGATE
	STA SAVED.ACC.LOCAL 						;SAVE TILE_TYPE OF MO BEING BOARDED

					
;SAVE REGISTERS
	TXA
	PHA
	TYA
	PHA
.EXTRACT_FLAGS
;EXTRACT MOB BOOLEAN FLAGS	
	LDA MAP_OBJECTS.TRANSPORT+$3,X
	LDY #$00	
.LOOP	
	LSR
	BCS .CARRY_IS_SET					
.CARRY_IS_CLEAR							;THE CARRY IS NOT KATIE
	STA SAVED.ACC.LOCAL2
	LDA #$00
	JMP .WRITE_FLAG_VALUE
.CARRY_IS_SET							;THE CARRY IS KATIE
	STA SAVED.ACC.LOCAL2
	LDA #$01

.WRITE_FLAG_VALUE
	STA MAP_OBJECTS.TRANSPORT_FLAGS,Y
	CPY #$07
	BEQ .FLAGS_DONE
	INY
	LDA SAVED.ACC.LOCAL2
	JMP .LOOP
.FLAGS_DONE	

;RESTORE REGISTERS
	PLA
	TYA
	PLA
	TXA
	

;DID PLAYER HAVE A SKIFF AS ACTIVE TRANSPORT, PRIOR TO CURRENT (B)OARD COMMAND?
	LDY PLAYER.TRANSPORT.ACTIVE	
	LDA MAP_OBJECTS.TRANSPORT+$2,Y
	CMP #TILE_ID.SKIFF							
	BEQ .BOARDING.WITH.SKIFF

;NO SKIFF ACTIVE, BOARDING FRIGATE FROM WALKING MODE
	LDA SAVED.ACC.LOCAL							;LOAD TILE TYPE OF OBJECT BEING BOARDED
	STA PLAYER.TILE.ACTIVE					;STORES FRIGATE AS THE ACTIVE TRASNPORT TILE
	STX PLAYER.TRANSPORT.ACTIVE					;SAVE INDEX TO BOARDED OBJECT, TO LINK THE PLAYER TO THIS TRANSPORT MO RECORD	

	JMP .CENTER_FRIGATE_ONSCREEN	

	
.TOO_MANY_SKIFFS						;WHICH IS NOT AS BIG A PROBLEM AS TOO MANY COOKS
	JSR PLAY.SOUND.DUMB_ASS
	RTS
	
.BOARDING.WITH.SKIFF
	LDA TRANSPORT.FLAG1							;IF FLAG IS SET TO $01 THEN FRIGATE HAS 2 SKIFFS
	BNE .TOO_MANY_SKIFFS	
		
;BOARDING SUCCESSFULL: UPDATE RECORDS

;INCREMENT SKIFFS ON FRIGATE
	LDA TRANSPORT.FLAG0							;IS FLAG SET TO #$01
	BNE .HAS.1SKIFF

.HAS.0SKIFFS
	LDA #$01 									;INCREASE SKIFFS ON FRIGATE TO 1. NOTE: THIS IS WRITING THE HEX VALUE OF THE FLAG COMBINATION TO REFLECT 1 SKIFF. SEE THE FLAG CHART IN MAP OBJECTS.XLS
	STA MAP_OBJECTS.TRANSPORT+$3,X
	JMP .UPDATE.ACTIVE.TRANSPORT
	
.HAS.1SKIFF
;EXIT WITH SKIFF
	LDA #$02 									;INCREASE SKIFFS ON FRIGATE TO 2. NOTE: THIS IS WRITING THE HEX VALUE OF THE FLAG COMBINATION TO REFLECT 2 SKIFF. SEE THE FLAG CHART IN MAP OBJECTS.XLS
	STA MAP_OBJECTS.TRANSPORT+$3,X
	;**FALLS THROUGH**
	
.UPDATE.ACTIVE.TRANSPORT	
;UPDATE ACTIVE TRANSPORT	
	STX PLAYER.TRANSPORT.ACTIVE					;SAVE INDEX TO BOARDED OBJECT, TO LINK THE PLAYER TO THIS TRANSPORT MO RECORD		
	LDA SAVED.ACC.LOCAL
	STA PLAYER.TILE.ACTIVE					;STORES FRIGATE AS THE ACTIVE TRASNPORT TILE	

;ERASE SKIFF FROM MAP OBJECTS ARRAY
	LDA #$00
	STA MAP_OBJECTS.TRANSPORT,Y					;ERASE MOB'S MAP OBJECT RECORD
	STA MAP_OBJECTS.TRANSPORT+$1,Y				;Y-REG CONTAINS THE INDEX TO THE MO RECORD OF THE SKIFF WHICH WAS THE ACTIVE TRANSPORT PRIOR TO BOARDING THE FRIGATE
	STA MAP_OBJECTS.TRANSPORT+$2,Y
	STA MAP_OBJECTS.TRANSPORT+$3,Y	
;	JMP BOARD.EXIT
	;**FALLS THROUGH
	
.CENTER_FRIGATE_ONSCREEN	
;IDENTIFY WHICH TILE OF THE SHIP THE PLAYER WAS LOCATED ON WHEN EXECUTING BOARD COMMAND	
;	LDA SAVED.ACC.LOCAL							;LOAD TILE TYPE OF OBJECT BEING BOARDED
	LDA MAP_OBJECTS.TRANSPORT,X					;LOAD X-AXIS
	CMP #$7F
	BEQ .X7F
	CMP #$80
	BEQ .X80
	
.ERROR2
;FRIGATE X-AXIS IN UNEXPECTED POSITION IN .CENTER_FRIGATE_ONSCREEN
	TAY
;DISABLE.BS_RAM
	LDA $C082				;READ ENABLE ROM, DISABLE WRITE ON BSM (NORMAL STATE).
							;REQUIRED FOR BEFORE BRK BECAUSE APPLE MONITOR IS A ROM ROUTINE

	LDA TEXT
	BRK
	

.X7F
	LDA MAP_OBJECTS.TRANSPORT+$1,X					;LOAD Y-AXIS
	CMP #$7F
	BEQ .X7F.Y7F
	CMP #$80
	BEQ .X7F.Y80

.ERROR3
;FRIGATE Y-AXIS IN UNEXPECTED POSITION IN .CENTER_FRIGATE_ONSCREEN
;
;DISABLE.BS_RAM
	LDA $C082				;READ ENABLE ROM, DISABLE WRITE ON BSM (NORMAL STATE).
							;REQUIRED FOR BEFORE BRK BECAUSE APPLE MONITOR IS A ROM ROUTINE

	LDA TEXT
	BRK
	
.X80
	LDA MAP_OBJECTS.TRANSPORT+$1,X					;LOAD Y-AXIS
	CMP #$7F
	BEQ .X80.Y7F
	CMP #$80
	BEQ .X80.Y80						

.ERROR4
;FRIGATE Y-AXIS IN UNEXPECTED POSITION IN .CENTER_FRIGATE_ONSCREEN
	LDA TEXT
	BRK
	

.X80.Y80 ;NW: PLAYER IS LOCATED ON THE NORTHWEST TILE OF THE FRIGATE 
	JSR MOVE.PASS
	JMP .UPDATE.SCREEN.ARRAY
	
.X7F.Y80 ;NE: PLAYER IS LOCATED ON THE NORTHEAST TILE OF THE FRIGATE		
;UPDATE FRIGATE LOCATION
	LDA #MAP_OBJECTS.PLAYER_LOCATION
	STA MAP_OBJECTS.TRANSPORT,X
	STA MAP_OBJECTS.TRANSPORT+$1,X

;UPDATE PLAYER LOCATION	
	LDA #$01
	STA PLAYER.MOVE.FORCED						;SET FORCE MOVE FLAG SO MOVE.N/S/E/W WON'T DO COLLISION CHECKS OR CHECK FOR A KEYPRESS TO ABORT TO ALTERNATE GAME LOOP ENTRANCE (THIS NOT RETURNING VIA RTS TO THIS ROUTINE)
	
	JSR MOVE.WEST
	
	LDA #$00
	STA PLAYER.MOVE.FORCED						;RESET FLAG TO DEFAULT (OFF).
	
	JMP .UPDATE.SCREEN.ARRAY
	
.X80.Y7F ;SW: PLAYER IS LOCATED ON THE SOUTHWEST TILE OF THE FRIGATE

;UPDATE FRIGATE LOCATION
	; LDA #MAP_OBJECTS.PLAYER_LOCATION
	; STA MAP_OBJECTS.TRANSPORT,X
	; STA MAP_OBJECTS.TRANSPORT+$1,X

	INC MAP_OBJECTS.TRANSPORT+$1,X					;UPDATE FRIGATE X-AXIS LOCATION

;UPDATE PLAYER LOCATION	
	LDA #$01
	STA PLAYER.MOVE.FORCED						;SET FORCE MOVE FLAG SO MOVE.N/S/E/W WON'T DO COLLISION CHECKS OR CHECK FOR A KEYPRESS TO ABORT TO ALTERNATE GAME LOOP ENTRANCE (THIS NOT RETURNING VIA RTS TO THIS ROUTINE)
	
	JSR MOVE.NORTH
	
	LDA #$00
	STA PLAYER.MOVE.FORCED						;RESET FLAG TO DEFAULT (OFF).
	
	JMP .UPDATE.SCREEN.ARRAY
	
.X7F.Y7F ;SE: PLAYER IS LOCATED ON THE SOUTHEAST TILE OF THE FRIGATE	
;UPDATE PLAYER & FRIGATE LOCATION
				
	INC MAP_OBJECTS.TRANSPORT,X					;UPDATE FRIGATE X-AXIS LOCATION
	
	LDA #$01
	STA PLAYER.MOVE.FORCED						;SET FORCE MOVE FLAG SO MOVE.N/S/E/W WON'T DO COLLISION CHECKS OR CHECK FOR A KEYPRESS TO ABORT TO ALTERNATE GAME LOOP ENTRANCE (THIS NOT RETURNING VIA RTS TO THIS ROUTINE)
	
	TXA											
	PHA											;TRANSFER MO RECORD INDEX TO STACK
	JSR MOVE.WEST
	PLA											;RESTORE MO RECORD INDEX FROM STACK
	TAX

	INC MAP_OBJECTS.TRANSPORT+$1,X				;UPDATE FRIGATE Y-AXIS LOCATION

	JSR MOVE.NORTH

	
	LDA #$00
	STA PLAYER.MOVE.FORCED						;RESET FLAG TO DEFAULT (OFF).
	
;	JMP .UPDATE.SCREEN.ARRAY	
	
	;**FALLS THROUGH

.UPDATE.SCREEN.ARRAY		
;REMOVE FRIGATE FROM SCREEN ARRAY
;This is so that if a map object like a skiff moved onto another map object like a frigate, that the non-active transport object will be in the screen array so it can be detected for boarding purposes. 
;All transport objects are removed from screen array for consistency. The code is also setup to expect that active transport isn't in the screen array and I've seen problems like the tranport leaving a trail of itself when is left in screen array.
	LDY #PLAYER.TRANSPORT.MT.TILE_LOCATION0		;LOAD PLAYER TILES AS INDEX	 (SCREEN ARRAYS HAVEN'T BEEN SCROLLED YET FOR CURRENT PLAYER MOVE)
	LDA #$FF									;THIS IS THE VALUE FOR NO MO RECORD 
	STA SCREEN.MO_TRANSPORT.DATA,Y				;ERASE TRANSPORT FROM POSITION, BEFORE CURRENT PLAYER MOVE, IN SCREEN ARRAY

	LDY #PLAYER.TRANSPORT.MT.TILE_LOCATION1		;LOAD PLAYER TILES AS INDEX	 (SCREEN ARRAYS HAVEN'T BEEN SCROLLED YET FOR CURRENT PLAYER MOVE)
	LDA #$FF									;THIS IS THE VALUE FOR NO MO RECORD 
	STA SCREEN.MO_TRANSPORT.DATA,Y				;ERASE TRANSPORT FROM POSITION, BEFORE CURRENT PLAYER MOVE, IN SCREEN ARRAY
	
	LDY #PLAYER.TRANSPORT.MT.TILE_LOCATION2		;LOAD PLAYER TILES AS INDEX	 (SCREEN ARRAYS HAVEN'T BEEN SCROLLED YET FOR CURRENT PLAYER MOVE)
	LDA #$FF									;THIS IS THE VALUE FOR NO MO RECORD 
	STA SCREEN.MO_TRANSPORT.DATA,Y				;ERASE TRANSPORT FROM POSITION, BEFORE CURRENT PLAYER MOVE, IN SCREEN ARRAY
	
	LDY #PLAYER.TRANSPORT.MT.TILE_LOCATION3		;LOAD PLAYER TILES AS INDEX	 (SCREEN ARRAYS HAVEN'T BEEN SCROLLED YET FOR CURRENT PLAYER MOVE)
	LDA #$FF									;THIS IS THE VALUE FOR NO MO RECORD 
	STA SCREEN.MO_TRANSPORT.DATA,Y				;ERASE TRANSPORT FROM POSITION, BEFORE CURRENT PLAYER MOVE, IN SCREEN ARRAY
		


	RTS			

@MIDDLE
	
BOARD.NOTHING_TO_BOARD	
	JSR PLAY.SOUND.DUMB_ASS
	RTS

BOARD.EXIT
	; LDY #SCREEN.ARRAY.PLAYER_LOCATION			;LOAD PLAYER TILES AS INDEX	 (SCREEN ARRAYS HAVEN'T BEEN SCROLLED YET FOR CURRENT PLAYER MOVE)
	; LDA #$FF									;THIS IS THE VALUE FOR NO MO RECORD 
	; STA SCREEN.MO_TRANSPORT.DATA,Y				;ERASE TRANSPORT FROM POSITION, BEFORE CURRENT PLAYER MOVE, IN SCREEN ARRAY

	
	JSR MOVE.PASS
	
				
	RTS
@END
	
MO.XIT ; ========PLAYER ATTEMPS X.IT MAP OBJECT======
@START
;PARAMETERS: NONE
;ENTRANCE: DIRECT
;RETURN: PLAYER.TILE.ACTIVE, PLAYER.TRANSPORT.ACTIVE, PLAYER.WALKING.TILE, [PLAYER.TRANSPORT.SPEED], [PLAYER.TRANSPORT.SPEED]

;=====================SUBROUTINE DOCUMENTATION====================================
;
;This subroutine is called by GAME.PRIMARY_LOOP when the player executes the command
;to (X)it a transport map object. 
;
;There are no scenarios currently where an (X)it fails. The player is returned to walking mode immediately except
;if the player's active transport is a frigate of a skiff. 
;Frigate:  a check is done to see if the Frigate has any skiffs. If it
;		 	does, then the player're active transport is changed to a skiff.
;Skiff: a check is done to see if the player is standing on a frigate. 
;			If yes, then the skiff is added to the Frigate's skiff qty and 
;			the player is returned to walking mode.
;
;Variables are updated to return the player to walking mode and if the tranport
;object subject the (X)it has the ability to increase movement speed (i.e horse, Wyvern)
;then variables are updated to return the player to walking speed and not-flying status if
;appropriate. 
;=================================================================================

;VERIFY PLAYER HAS TRANSPORT ACTIVE
	LDX PLAYER.TRANSPORT.ACTIVE					;LOAD TRANSPORT MO RECORD INDEX
	STX SAVED.XREG.LOCAL						;SAVE INDEX FOR FUTURE USE 
	CPX #$FF									;IS PLAYER WALKING?
	BEQ XIT.NOTHING_TO_EXIT						;IF YES, DON'T MODIFY ANY MO RECORDS, PROCEED TO UPDATE VIDEO SCREEN

;EXIT THE TRANSPORT OBJECT	
	LDA #$FF									;SET TRANSPORT STATUS TO WALKING
	STA PLAYER.TRANSPORT.ACTIVE
	
	LDA MAP_OBJECTS.TRANSPORT+$2,X				;LOAD TILE TYPE OF ACTIVE TRANSPORT
	CMP #TILE_ID.HORSE_C						;BRANCH BASED ON THE TYPE OF TRASNPORT MO AT THE PLAYER LOCATION
	BEQ XIT.HORSE
	CMP #TILE_ID.FRIGATE1.1
	BEQ XIT.FRIGATE
	CMP #TILE_ID.CARAVEL
	BEQ XIT.CARAVEL
	CMP #TILE_ID.SKIFF
	BEQ .XIT.SKIFF_STEP
	CMP #TILE_ID.WYVERN
	BEQ XIT.WYVERN	

.ERROR											;IF TILE_TYPE NOT RECOGNIZED, ERROR OUT
;TILE_TYPE OF TRANSPORT PLAYER ATTEMPTED TO BOARD NOT RECOGNIZED IN MO.XIT
	BRK
@MIDDLE
.XIT.SKIFF_STEP
	JMP XIT.SKIFF

XIT.NOTHING_TO_EXIT
	JSR PLAY.SOUND.DUMB_ASS
	RTS

XIT.WYVERN		
	LDA #$00									
	STA PLAYER.TRANSPORT.SPEED					;RESET FAST TRANSPORT STATUS TO OFF
	STA PLAYER.TRANSPORT.STATUS					;""
	
	LDA PLAYER.WALKING.TILE.DEFAULT
	STA PLAYER.WALKING.TILE
	STA PLAYER.TILE.ACTIVE						;RESET TO WALKING PLAYER ICON
	
	LDA PLAYER.DARKNESS_OVERRIDE				;WAS PLAYER FLYING?
	BNE .PLAYER_WAS_FLYING						;IF YES, TURN OVER DARKNESS OVERRIDE

	JSR MOVE.PASS
	RTS

.PLAYER_WAS_FLYING
	LDA #$00
	STA PLAYER.DARKNESS_OVERRIDE				
	
	JSR MOVE.PASS
	RTS
	
;NOTE: the exit sequence below was necessary before XIT was setup to 
;automatically return to the game loop via GAME.LAUNCH. See GAME.PRIMARY_LOOP
;documentation for the reason why that got setup. 

	; PLA											;REMOVE RTS ADDED TO THE STACK WHEN MO.BOARD WAS CALLED
	; PLA

	; JMP GAME.LAUNCH								;DO A FRESH SCREEN DRAW TO FILL IN ANY DARK TILES

XIT.HORSE		
	LDA #$00									
	STA PLAYER.TRANSPORT.SPEED					;RESET FAST TRANSPORT STATUS TO OFF
	STA PLAYER.TRANSPORT.STATUS					;""

	JMP XIT.WALKING_MODE


XIT.CARAVEL
	JMP XIT.WALKING_MODE

@MIDDLE
	
XIT.FRIGATE
.EXTRACT_FLAGS
;EXTRACT MOB BOOLEAN FLAGS	
	LDA MAP_OBJECTS.TRANSPORT+$3,X
	LDY #$00	
.LOOP	
	LSR
	BCS .CARRY_IS_SET					
.CARRY_IS_CLEAR							;THE CARRY IS NOT KATIE
	STA SAVED.ACC.LOCAL
	LDA #$00
	JMP .WRITE_FLAG_VALUE
.CARRY_IS_SET							;THE CARRY IS KATIE
	STA SAVED.ACC.LOCAL
	LDA #$01

.WRITE_FLAG_VALUE
	STA MAP_OBJECTS.TRANSPORT_FLAGS,Y
	CPY #$07
	BEQ .FLAGS_DONE
	INY
	LDA SAVED.ACC.LOCAL
	JMP .LOOP
.FLAGS_DONE

;DOES THE FRIGATE HAVE ANY SKIFFS?
	LDA TRANSPORT.FLAG1							;IS FLAG SET TO #$01
	BNE .XIT.HAS.2SKIFFS	
	LDA TRANSPORT.FLAG0							;IS FLAG SET TO #$01
	BNE .XIT.HAS.1SKIFF
	
	JMP XIT.WALKING_MODE						;IF NO SKIFFS, EXIT TO WALKING MODE
	
.XIT.HAS.2SKIFFS
	LDA #$01 									;REDUCE SKIFFS ON FRIGATE TO 1. NOTE: THIS IS WRITING THE HEX VALUE OF THE FLAG COMBINATION TO REFLECT 1 SKIFF. SEE THE FLAG CHART IN MAP OBJECTS.XLS
	STA MAP_OBJECTS.TRANSPORT+$3,X	
	JMP .UPDATE.RECORDS
	
.XIT.HAS.1SKIFF
;EXIT WITH SKIFF
	LDA #$00 									;REDUCE SKIFFS ON FRIGATE TO 0. NOTE: THIS IS WRITING THE HEX VALUE OF THE FLAG COMBINATION TO REFLECT 1 SKIFF. SEE THE FLAG CHART IN MAP OBJECTS.XLS
	STA MAP_OBJECTS.TRANSPORT+$3,X
	;**FALLS THROUGH**
	
.UPDATE.RECORDS	
	LDA #TILE_ID.SKIFF
	STA PLAYER.TILE.ACTIVE					;STORES FRIGATE AS THE ACTIVE TRANSPORT TILE	

;CREATE NEW SKIFF RECORD IN MAP OBJECTS ARRAY

	;SET PARAMETERS FOR MO.TRANSPORT.CREATE 
	LDA #MAP_OBJECTS.PLAYER_LOCATION
	STA MAP_OBJECTS.CREATE.TRANSPORT.X

	LDA #MAP_OBJECTS.PLAYER_LOCATION				
	STA MAP_OBJECTS.CREATE.TRANSPORT.Y	
	
	LDA #TILE_ID.SKIFF		
	STA MAP_OBJECTS.CREATE.TRANSPORT.TILE_TYPE	

	LDA #$00
	STA MAP_OBJECTS.CREATE.TRANSPORT.SKIFFS			

	
	;CREATE MAP OBJECT FOR SKIFF
	JSR MO.TRANSPORT.CREATE						;RETURNS INDEX TO NEW MO RECORD IN X-REG

;SET NEW MO RECORD AS THE ACTIVE TRANSPORT FOR PLAYER
	STX PLAYER.TRANSPORT.ACTIVE

;EXIT
	JSR MOVE.PASS
	RTS

XIT.WALKING_MODE
	LDA PLAYER.WALKING.TILE.DEFAULT
	STA PLAYER.WALKING.TILE
	STA PLAYER.TILE.ACTIVE						;RESET TO WALKING PLAYER ICON
	
	JSR LOAD.PLAYER.WALKING.ICON
	
	JSR MOVE.PASS
	
	
	RTS

@MIDDLE
XIT.SKIFF

;IS PLAYER STANDING ON A FRIGATE?
	LDY #SCREEN.ARRAY.PLAYER_LOCATION
	LDA SCREEN.MO_TRANSPORT.DATA,Y				;LOAD TRANSPORT MO RECORD INDEX FROM SCREEN ARRAY FOR CURRENT PLAYER LOCATION
	CMP #$FF									;IS RECORD EMPTY? (I.E. NO MO AT THIS LOCATION)
	BEQ XIT.WALKING_MODE						;IF YES, XIT TO WALKING MODE
	TAX											;IF NO, USE INDEX TO LOOKUP TILE TYPE OF MO FROM MO RECORD.

;EXTRACT FLAGS SO WE CAN EXAMINE FRIGATE
;SAVE REGISTERS
	TXA
	PHA
	TYA
	PHA	
	
.EXTRACT_FLAGS
;EXTRACT MOB BOOLEAN FLAGS	
	LDA MAP_OBJECTS.TRANSPORT+$3,X
	LDY #$00	
.LOOP	
	LSR
	BCS .CARRY_IS_SET					
.CARRY_IS_CLEAR							;THE CARRY IS NOT KATIE
	STA SAVED.ACC.LOCAL
	LDA #$00
	JMP .WRITE_FLAG_VALUE
.CARRY_IS_SET							;THE CARRY IS KATIE
	STA SAVED.ACC.LOCAL
	LDA #$01

.WRITE_FLAG_VALUE
	STA MAP_OBJECTS.TRANSPORT_FLAGS,Y
	CPY #$07
	BEQ .FLAGS_DONE
	INY
	LDA SAVED.ACC.LOCAL
	JMP .LOOP
.FLAGS_DONE

;RESTORE REGISTERS
	PLA
	TYA
	PLA
	TXA		

	; LDA TROUBLESHOOTING.HOOK
	; CMP #$01
	; BNE .TEMP
	; LDA TEXT
			; LDA PLAYER.ACTIVE.TRANSPORT
			; ;LDA MAP_OBJECTS.TRANSPORT+$3,X
			; ;LDX TRANSPORT.FLAG0
			; ;LDY TRANSPORT.FLAG1	
	; BRK
; .TEMP

;OK, SO THE PLAYER IS STANDING ON A TRANSPORT MO (IN ADDITION TO ACTIVE SKIFF), IS IT A FRIGATE?
	LDA MAP_OBJECTS.TRANSPORT+$2,X				;LOAD TILE TYPE OF TRANSPORT	
	CMP #TILE_ID.FRIGATE1.1
	BEQ .LEAVE_SKIFF_ON_FRIGATE

	JMP XIT.WALKING_MODE						;XIT FRIGATE, RETURN TO WALKING MODE

	
.LEAVE_SKIFF_ON_FRIGATE
	LDA TRANSPORT.FLAG1							;DOES THE FRIGATE ALREADY HAVE THE MAX # OF SKIFFS ON IT? (CURRENTLY 2)
	BNE .TOO_MANY_SKIFFS						;ABORT THE BOARD ATTEMPT ON THE FRIGATE

	
;LEAVE SKIFF ON FRIGATE SUCCESSFULL: UPDATE RECORDS

;INCREMENT SKIFFS ON FRIGATE
	
	LDA TRANSPORT.FLAG0							;IS FLAG SET TO #$01
	BNE .HAS.1SKIFF

.HAS.0SKIFFS
	LDA #$01 									;INCREASE SKIFFS ON FRIGATE TO 1. NOTE: THIS IS WRITING THE HEX VALUE OF THE FLAG COMBINATION TO REFLECT 1 SKIFF. SEE THE FLAG CHART IN MAP OBJECTS.XLS
	STA MAP_OBJECTS.TRANSPORT+$3,X

	JMP .ERASE.SKIFF.MO
	
.HAS.1SKIFF
	LDA #$02 									;INCREASE SKIFFS ON FRIGATE TO 2. NOTE: THIS IS WRITING THE HEX VALUE OF THE FLAG COMBINATION TO REFLECT 2 SKIFF. SEE THE FLAG CHART IN MAP OBJECTS.XLS
	STA MAP_OBJECTS.TRANSPORT+$3,X
		

	;**FALLS THROUGH**
	
.ERASE.SKIFF.MO
;ERASE SKIFF FROM MAP OBJECTS ARRAY, SINCE IT'S NOW ON THE BOAT
	LDY SAVED.XREG.LOCAL						;XREG WAS SAVED IN THE BEGINNING OF XIT, WHICH CONTAINED THE INDEX OF THE ACTIVE TRANSPORT MO
	LDA #$00
	STA MAP_OBJECTS.TRANSPORT,Y					;ERASE MOB'S MAP OBJECT RECORD
	STA MAP_OBJECTS.TRANSPORT+$1,Y				;Y-REG CONTAINS THE INDEX TO THE MO RECORD OF THE SKIFF WHICH WAS THE ACTIVE TRANSPORT PRIOR TO BOARDING THE FRIGATE
	STA MAP_OBJECTS.TRANSPORT+$2,Y
	STA MAP_OBJECTS.TRANSPORT+$3,Y	
	JMP XIT.WALKING_MODE

.TOO_MANY_SKIFFS								;WHICH ISN'T AS BIG A PROBLEM AS TOO MANY COOKS
	LDX SAVED.XREG.LOCAL
	STX PLAYER.TRANSPORT.ACTIVE					;KEEP SKIFF AS ACTIVE TRANSPORT.
	JSR PLAY.SOUND.DUMB_ASS
	RTS
@END

MO.TRANSPORT.CREATE	;===========ADD A TRANSPORT OBJECT TO THE MAP OBJECTS ARRAY======
@START
;PARAMETERS; MAP_OBJECTS.CREATE.TRANSPORT.X, MAP_OBJECTS.CREATE.TRANSPORT.Y, MAP_OBJECTS.CREATE.TRANSPORT.TILE_TYPE, MAP_OBJECTS.CREATE.TRANSPORT.SKIFFS
;ENTRANCE: MO.XIT, DIRECT
;RETURN: ;X-REG RETURNS THE INDEX TO THE MO RECORD CREATED

;=====================SUBROUTINE DOCUMENTATION====================================
;Used by MO.XIT to create a new skiff map object if the player (X)its a frigate carrying skiffs.
;=================================================================================


;FIND OPEN MO RECORD
	LDX #$00
.RECORD_LOOP
	LDA MAP_OBJECTS.TRANSPORT+$2,X
	CMP #$00								;#$00 IS THE ARRAY STOP VALUE
	BEQ .OPEN_RECORD_FOUND
	TXA
	CLC
	ADC #MAP_OBJECTS.RECORD_LENGTH
	BEQ .ARRAY_FULL							;IF COUNTER FLIPS TO #$00, THEN NO OPEN RECORDS AVAILABLE, EXIT

	TAX
	JMP .RECORD_LOOP

.ARRAY_FULL
	;IF THE TRANSPORT OBJECT ARRAY IS FULL, THE FIRST RECORD WILL ALWAYS BE OVERWRITTEN
	;**FALLS THROUGH
	
.OPEN_RECORD_FOUND
	LDA MAP_OBJECTS.CREATE.TRANSPORT.X	
	STA MAP_OBJECTS.TRANSPORT,X

	LDA MAP_OBJECTS.CREATE.TRANSPORT.Y
	STA MAP_OBJECTS.TRANSPORT+$1,X

	LDA MAP_OBJECTS.CREATE.TRANSPORT.TILE_TYPE
	STA MAP_OBJECTS.TRANSPORT+$2,X

	LDA MAP_OBJECTS.CREATE.TRANSPORT.SKIFFS
	STA MAP_OBJECTS.TRANSPORT+$3,X


;RETURN VALUE
	;X-REG RETURNS THE INDEX TO THE MO RECORD CREATED

	RTS
@END

MO.DRAW ;==========UPDATE LOCATION TO REFLECT PLAYER MOVE==============
@START
;=====================**TOP LEVEL** SUBROUTINE DOCUMENTATION====================================
;This subroutine is called by all movement routines (including MOVE.PASS) in movement_manager.ASM
;It is responsible for the following:
;				*Updating the x,y of map objects (i.e. transport and mobs) to reflect the player move because the x,y tracked for map object's is relative to the player's position
;				*Determining if mobs will move this turn, where they will move to, and if that move is permitted.
;				*After the above have been considered, drawing the mob in it's final location and erasing the mob in the prior location if needed. 
;
;
;=================================================================================


;PARAMETERES: INITIAL_SCREEN_DRAW (SET TO $01 IF CALLING FROM DRAW.SCREEN, SKIPS UPDATE TO MO X/Y THAT OCCURS AFTER PLAYER MOVE)
;RETURN: NONE
;ENTRANCE: DIRECT

;**OPT** Speed. This comment was originall written when doing the MO.ERASE routine, which erased the MOs and redrew terrain, until I realized erase wasn't needed. Not sure if this idea still applies.
;Since transport objects don't move unless boarded (which is handled through the player icon) it would probably be faster
;if the transport objects were allowed to scroll. I think this would mean modifying MO.DRAW so that transport objects are only drawn if called from draw.screen, and then
; column row/draw would need to handle drawing of transport objects if present. This would slow things down if no transport objects are present so
;it's hard to say which is better, short of a player building a boat bridge or somethign. 


;INITIAL VARIABLES, COUNTERS, INDEXES
@START

;Init Index and MO SCREEN ARRAYS to $FFs
;($FF is the flag for no map object in that tile location)

;CALLING ROUTINE CHECK: INITIAL SCREEN DRAW 


					;RTS
	LDA CALLED_BY.DRAW.SCREEN
	CMP #$01
	BNE .ENTRANCE2					;ONLY INIT MO SCREEN ARRAYS DURING INITIAL SCREEN DRAW.

				;INC $9400
	LDY #$00
.INIT_LOOP
	LDA #$FF	
	STA SCREEN.MO_TRANSPORT.DATA,Y
	STA SCREEN.MO_MOB.DATA,Y
	CPY #$BA
	BEQ .DONE
	INY
	JMP .INIT_LOOP
.DONE

.ENTRANCE2

;INIT VARIABLES, INDEXES, COUNTERS
	LDX #$00						;INDEX FOR MAP_OBJECT ARRAYS
				
	LDA #$00
	STA MOB.GEN.SS_QTY				;TRACKS THE QTY OF OFF SCREEN SS IN THE CURRENT REGION

@END
	
PRIMARY_LOOP ;
@START
;=====================SUBROUTINE DOCUMENTATION====================================
;This subroutine iterates through the map object arrays. Once the stop value 
;for one of the arrays is reached, processing continues for the other array only, other
;than the stop value check at the top of TRANSPORT.ENTRACE and MOB.ENTRANCE
;
;There is a check done in several locations for whether this routine was called
;during an initial screen draw. If so, then all map objects on screen are drawn,
;whereas normally drawing might be skipped under some circumstances. For example,
;transport objects don't require drawing after the initial screen draw because they
;are only moving on screen because the player moved and thus screen scrolling takes care 
;of moving them to the correct location after a player move. Drawing is also 
;skipped if a mob passes for its move because as previously mentioned, it would be in the
;correct location due to graphics screen scrolling.
;
;The very first activity the loop does is to update the x,y position of
;the current record in the transport and mob map object arrays to reflect
;the player move. A player move is assumed because the top level subroutine 
;MO.DRAW is only called from the movement routines in movement_mgr.ASM
;(other than the initial screen draw, in which case the x,y position adjustment is skipped) 
;=================================================================================


;CALLING ROUTINE CHECK: INITIAL SCREEN DRAW 
	LDA CALLED_BY.DRAW.SCREEN
	CMP #$01
	BEQ MANAGE.OBJECTS

.ONSCREEN_CHECK.INITIAL
@START
;BEFORE PLAYER MOVE, CHECK TO SEE IF CURRENT TRANSPORT MO IS LOCATED ON THE VIEW SCREEN

;**OPT** Speed. Memory. There appears to be two view screen checks. This one, which for some reason
;is only for MOBs, and there is also one at the start of the transport and MOB routines. Maybe
;there is a reason. I don't remember. 



	LDA MAP_OBJECTS.MOB,X						;LOAD X POSITION OF CURRENT MOB
	CMP #MAP_OBJECTS.X_FLAG.LOWER				;IS OBJECT BEYOND LEFT EDGE OF SCREEN?
	BCC	.MOB.NOTONSCREEN_STEP	
	
	CMP #MAP_OBJECTS.X_FLAG.UPPER				;IS OBJECT BEYOND RIGHT EDGE OF SCREEN?
	BCS	.MOB.NOTONSCREEN_STEP	
	
	LDA MAP_OBJECTS.MOB+$1,X
	CMP #MAP_OBJECTS.Y_FLAG.LOWER				;IS OBJECT BEYOND LOWER EDGE OF SCREEN?
	BCC	.MOB.NOTONSCREEN_STEP	
	
	CMP #MAP_OBJECTS.Y_FLAG.UPPER				;IS OBJECT BEYOND UPPER EDGE OF SCREEN?
	BCS	.MOB.NOTONSCREEN_STEP

	LDA #$00								
	STA MOB.SCREEN_STATUS.START					;SET TO $00 (ONSCREEN)
	
	JMP .APPLY.PLAYER_MOVE

.MOB.NOTONSCREEN_STEP
	LDA #$01								
	STA MOB.SCREEN_STATUS.START					;SET TO $01 (OFFSCREEN)

	;***FALLS THROUGH
@END

.APPLY.PLAYER_MOVE
@START	
;INCREMENT MOB X,Y POSITION	NET OF PLAYER'S CURRENT MOVE. 
	LDA PLAYER.MOVE.CURRENT		;#$00=north, $01=south, $02=east, $03=west, $04=PASS
					
	CMP #$00
	BEQ	.MOVE.NORTH
	CMP #$01
	BEQ .MOVE.SOUTH
	CMP #$02
	BEQ	.MOVE.EAST
	CMP #$03
	BEQ .MOVE.WEST
	CMP #$04
	BEQ MANAGE.OBJECTS
	JMP ERROR1
					
.MOVE.NORTH
	INC MAP_OBJECTS.TRANSPORT+$1,X			;+1 TO Y POSITION
	INC MAP_OBJECTS.MOB+$1,X				;+1 TO Y POSITION
	JMP MANAGE.OBJECTS
	
.MOVE.SOUTH	
	DEC MAP_OBJECTS.TRANSPORT+$1,X			;-1 TO Y POSITION
	DEC MAP_OBJECTS.MOB+$1,X				;-1 TO Y POSITION
	JMP MANAGE.OBJECTS	
	
.MOVE.EAST	
		
	DEC MAP_OBJECTS.TRANSPORT,X				;-1 TO X POSITION
	DEC MAP_OBJECTS.MOB,X					;-1 TO X POSITION
	JMP MANAGE.OBJECTS	

.MOVE.WEST
			
	INC MAP_OBJECTS.TRANSPORT,X				;+1 TO X POSITION
	INC MAP_OBJECTS.MOB,X					;+1 TO X POSITION
	;*****FALLS THROUGH*****		
			
@END

MANAGE.OBJECTS
@START
;(test each map array for $00 in the first field of the current record, if all arrays are at end, then exit)
	LDA MAP_OBJECTS.TRANSPORT+$2,X			;AT END OF ARRAY?
	CMP #$00	
	BNE TRANSPORT.ENTRANCE
	LDA MAP_OBJECTS.MOB+$2,X				;AT END OF ARRAY?
	CMP #$00	
	BNE .MOB_ENTRANCE_STEP	
	JMP INCREMENT_INDEX
	
.MOB_ENTRANCE_STEP
	JMP MOB.ENTRANCE
	

;END-OF-ARRAYS CHECK	
TRANSPORT.ENTRANCE
@START
;=====================CODE-SECTION DOCUMENTATION====================================
;The first order of business is to determine if the current transport record
;has an x/y located on the view screen. If not, the rest of this routine 
;is skipped and the code falls through to MOB.ENTRANCE
;=================================================================================


;**OPT** Speed. Since scolling takes care of shifting transport on screen relative to the player,
;and transport doesn't make any 'moves' itself, I'm speculating there are only three times we need to draw transport on screen:
;1) initial screen draw
;2) when player walks on a transport and then walks off, without boarding it.
;3) the first time a transport appears on screen. 
;
;the first two cases are easy. For the third, maybe trigger a draw only if the transport's x,y
;is on the edge. Even better, for a given edge, only trigger the draw it the player was moving
;toward that edge, otherwise for all other edges the scrolling would handle proper placement
;
;this should make it so a boat bridge or harbor filled with ships doesn't slow things down. 
	


.ONSCREEN_CHECK ;
;CHECK TO SEE IF CURRENT TRANSPORT MO IS LOCATED ON THE VIEW SCREEN
	LDA MAP_OBJECTS.TRANSPORT,X
	CMP #MAP_OBJECTS.X_FLAG.LOWER				;IS OBJECT BEYOND LEFT EDGE OF SCREEN?
	BCC	.TRANSPORT.NOTVISIBLE_STEP	
	
	CMP #MAP_OBJECTS.X_FLAG.UPPER				;IS OBJECT BEYOND RIGHT EDGE OF SCREEN?
	BCS	.TRANSPORT.NOTVISIBLE_STEP
	
	LDA MAP_OBJECTS.TRANSPORT+$1,X
	CMP #MAP_OBJECTS.Y_FLAG.LOWER				;IS OBJECT BEYOND LOWER EDGE OF SCREEN?
	BCC	.TRANSPORT.NOTVISIBLE_STEP	
	
	CMP #MAP_OBJECTS.Y_FLAG.UPPER				;IS OBJECT BEYOND UPPER EDGE OF SCREEN?
	BCS	.TRANSPORT.NOTVISIBLE_STEP

	JMP .TRANSPORT.IDENTIFY.TILE_LOCATION	

.TRANSPORT.NOTVISIBLE_STEP
	JMP .TRANSPORT.NOTVISIBLE
	
.TRANSPORT.IDENTIFY.TILE_LOCATION	
@START
;=====================CODE-SECTION DOCUMENTATION====================================
;
;This code section is responsible for converting the transport's relative x,y
;position into a screen tile location (the index to the screen arrays).
;The screen tile location is needed later to draw the tile since 
;DRAW.TILE.SINGLE needs this as a parameter.
;
;The mechanic of doing the conversion is essentially done by using the 
;difference between the player's x/y and the transport's x/y as an adjustment to 
;the players screen tile position, using the appropriate offsets for the
;screen tile grid. For example, for a y axis differential, a multiplication table is used
;to calculate the offset to apply to the player's location. 
;
;Calculating the difference between player and transport x,y starts 
;determining whether the transport x,y is less than the player x,y.
;This is done so that negative numbers can be avoided. 
;=================================================================================


;IDENTIFY SCREEN TILE #							;OBJECT IS ON SCREEN, WHERE DO WE DRAW IT?
				
	LDA MAP_OBJECTS.TRANSPORT,X
	CMP #MAP_OBJECTS.PLAYER_LOCATION
	BCC .TRANSPORT.MO_X_LESS
	
	LDA MAP_OBJECTS.TRANSPORT,X
	SEC
	SBC #MAP_OBJECTS.PLAYER_LOCATION
	STA MAP_OBJECTS.X_ADJ
	LDA #SCREEN.ARRAY.PLAYER_LOCATION
	CLC
	ADC MAP_OBJECTS.X_ADJ
	STA TEMP
	JMP .TRANSPORT.YTEST

.TRANSPORT.MO_X_LESS
	LDA #MAP_OBJECTS.PLAYER_LOCATION
	SEC
	SBC MAP_OBJECTS.TRANSPORT,X
	STA MAP_OBJECTS.X_ADJ
	LDA #SCREEN.ARRAY.PLAYER_LOCATION
	SEC
	SBC MAP_OBJECTS.X_ADJ
	STA TEMP


.TRANSPORT.YTEST	

	LDA MAP_OBJECTS.TRANSPORT+$1,X
	CMP #MAP_OBJECTS.PLAYER_LOCATION
	BCC .TRANSPORT.MO_Y_LESS
	
	LDA MAP_OBJECTS.TRANSPORT+$1,X
	SEC
	SBC #MAP_OBJECTS.PLAYER_LOCATION
	TAY
	LDA SCREEN.MULTIPLY_TABLE,Y
	STA MAP_OBJECTS.Y_ADJ
	
	LDA TEMP								;PARTIAL CALCULATION. CONTAINS #MAP_OBJECTS.PLAYER_LOCATION +/- MAP_OBJECTS.X_ADJ 
	CLC
	ADC MAP_OBJECTS.Y_ADJ
	STA MAP_OBJECTS.TILE_LOCATION	

	JMP .LOCATION.FOUND

.TRANSPORT.DRAWTILE_STEP
	JMP .TRANSPORT.DRAWTILE
.TRANSPORT.MO_Y_LESS
	LDA #MAP_OBJECTS.PLAYER_LOCATION
	SEC
	SBC MAP_OBJECTS.TRANSPORT+$1,X		
	TAY
	LDA SCREEN.MULTIPLY_TABLE,Y
	STA MAP_OBJECTS.Y_ADJ
	
	LDA TEMP								;PARTIAL CALCULATION. CONTAINS #MAP_OBJECTS.PLAYER_LOCATION +/- MAP_OBJECTS.X_ADJ 
	SEC
	SBC MAP_OBJECTS.Y_ADJ
	STA MAP_OBJECTS.TILE_LOCATION
	;***FALLS THROUGH TO

.LOCATION.FOUND
	
	LDA MAP_OBJECTS.TRANSPORT+$2,X			;LOAD TILE TYPE OF ACTIVE TRANSPORT
	CMP #TILE_ID.FRIGATE1.1					;IS TRANSPORT A MULTI-TILETILE OBJECT? (FRIGATES ARE THE ONLY MULTI-TILE TRANSPORT IN THE GAME. IF MORE WERE ADDED, THEN EITHER TWO TILE_TYPE CHECKS ARE NEEDED OR A MULTI-TILE FLAG WOULD BE NEEDED
	BEQ .TRANSPORT.DRAWTILE.MT				;IF YES, USE MT TILE DRAW ROUTINE 
@END
	;**FALLS THROUGH**


.TRANSPORT.DRAWTILE	
@START						
	LDY MAP_OBJECTS.TILE_LOCATION			;LOAD SCREEN ARRAY LOCATION OF THE CURRENT TRANSPORT MO					
							
;DOUBLE CHECK THAT WE REALLY WANT TO DRAW A MAP OBJECT TILE IN THIS LOCAITON 	
;IS TILE HIDDEN (DARKNESS)?	
	LDA SCREEN.DARK.DATA,Y			
	CMP #$01
	BEQ .TRANSPORT.NOTVISIBLE_STEP			;IF YES, DON'T DRAW TILE


;IS TILE AT PLAYER LOCATION?		
	CPY #SCREEN.ARRAY.PLAYER_LOCATION
	BNE .UPDATE.SCREEN_ARRAY2				;IF NOT PLAYER LOCATION, PROCEED TO UPDATE SCREEN ARRAY

	CPX PLAYER.TRANSPORT.ACTIVE				;IS MO RECORD INDEX A TRANSPORT OBJECT BOARDED BY PLAYER?
	BEQ .SAVE.TILE_TYPE						;IF YES, SKIP SCREEN ARRAY UPDATE AND DRAW TILE (THIS IS SO THAT IF THE PLAYER IS LOCATION ON TOP OF ANOTHER TRANSPORT OBJECT,, IT WILL BE DETECTED IN THE SCREEN ARRRAY VIA BOARD COMMAND. EXAMPLE, PLAYER IS BOARDED A SKIFF AND IS LOCATED ON A TILE WITH A FRIGATE)	

.UPDATE.SCREEN_ARRAY2	
	TXA										;ACC = MAP_OBJECTS.TRANSPORT INDEX		
	STA SCREEN.MO_TRANSPORT.DATA,Y			;SAVE MAP_OBJECTS.TRANSPORT INDEX TO SCREEN ARRAY TO MARK MOB'S PRESENCE FOR OTHER ROUTINES LIKE ANIMATION

.SAVE.TILE_TYPE
	LDA MAP_OBJECTS.TRANSPORT+$2,X
	STA SAVED_TILE_TYPE
	
		LDA #$07					;SET TRACE
		STA CALLED_BY
	JSR DRAW.TILE.SINGLE
		LDA #$07					;SET TRACE
		STA CALLED_BY
	
	JMP .EXIT
@END
	
.TRANSPORT.DRAWTILE.MT
@START
;IF MULTI-TILE MOB, RECORD THE SCREEN TILE # FOR EACH OF IT'S FOUR TILES		
	LDY MAP_OBJECTS.TILE_LOCATION			;LOAD SCREEN ARRAY LOCATION OF THE CURRENT TRANSPORT MO, CALCUALTED IN MAIN IDENTIFY TILE ROUTINE ABOVE
	STY TRANSPORT.MT.TILE_LOCATIONS			;SAVE AS TILE #0 (UPPER LEFT) OF MT TRANSPORT (BORROWING THE MOB MT ARRAY)

	INY
	STY TRANSPORT.MT.TILE_LOCATIONS+$1		;SAVE AS TILE #1 (UPPER RIGHT) OF MT TRANSPORT (BORROWING THE MOB MT ARRAY)
	TYA
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	STA TRANSPORT.MT.TILE_LOCATIONS+$3		;SAVE AS TILE #3 (LOWER RIGHT) OF MT TRANSPORT (BORROWING THE MOB MT ARRAY)
	TAY
	DEY
	STY TRANSPORT.MT.TILE_LOCATIONS+$2		;SAVE AS TILE #2 (LOWER LEFT) OF MT TRANSPORT (BORROWING THE MOB MT ARRAY)

;CALCUALTE THE TILE TYPES FOR EACH TILE OF MT TRANSPORT
	LDY MAP_OBJECTS.TRANSPORT+$2,X			;LOAD TILE TYPE OF MOB RECORD
	STY TRANSPORT.MT.TILE_TYPES				;SAVE TILE TYPE TO A HOLDING ARRAY (BORROWED FROM MOB ROUTINE)
	INY
	STY TRANSPORT.MT.TILE_TYPES+$1
	INY
	STY TRANSPORT.MT.TILE_TYPES+$2
	INY
	STY TRANSPORT.MT.TILE_TYPES+$3
	
	LDA MAP_OBJECTS.TRANSPORT,X				;LOAD X-AXIS (COLUMN) OF TILE0 OF MT MOB
	STA TRANSPORT.MT.POSITION.X				;SAVE FOR FUTURE USE, WHEN X/Y-REG ARE BOTH BUSY
	
	STX SAVED.XREG.LOCAL					;SAVE X-REG SO WE CAN USE IT AS LOOP COUNTER
	LDX #$00								;INIT LOOP COUNTER
.LOOP	
	LDY TRANSPORT.MT.TILE_LOCATIONS,X

;IS TILE ON THE VIEW SCREEN
;(normally this condition indicates an error, but with MT Mobs, it can happen legitimately if the mob is half on/off the screen. In that case, it's legit but the correct process is to not draw the offscreen tiles)	
	;IF TILE IS OFFSCREEN TO NORTH OR SOUTH, THE TILE # WILL EXCEED THE LAST ARRAY ELEMENT

	LDA #SCREEN.ARRAY.LAST_ELEMENT
	CMP TRANSPORT.MT.TILE_LOCATIONS,X	
	BCS .CHECK.EAST_WEST
	JMP .TILE.OFFSCREEN
.CHECK.EAST_WEST
	;OFFSCREEN EAST/WEST REQUIRES CHECKING THE COLUMN 
	LDA TRANSPORT.MT.POSITION.X				;LOAD X-AXIS (COLUMN) OF TILE0 OF MT MOB. LOADING FROM VARIABLE BECAUSE X/Y-REG ARE BOTH IN USE	

	CPX #$00								;IS TILE 0 THE CURRENT TILE??
	BEQ .TILE0.OFFSCREEN_CHECK
	CPX #$01								;IS TILE 1 THE CURRENT TILE??
	BEQ .TILE1.OFFSCREEN_CHECK
	CPX #$02								;IS TILE 2 THE CURRENT TILE??
	BEQ .TILE2.OFFSCREEN_CHECK
	CPX #$03								;IS TILE 3 THE CURRENT TILE??
	BEQ .TILE3.OFFSCREEN_CHECK

.TILE0.OFFSCREEN_CHECK
	CMP MAP_OBJECTS.X_APPROACH+$1
	BEQ .TILE.OFFSCREEN
	JMP .TILE_ONSCREEN
	
.TILE1.OFFSCREEN_CHECK
	CMP #MAP_OBJECTS.X.LAST_COLUMN
	BEQ .TILE.OFFSCREEN
	JMP .TILE_ONSCREEN

.TILE2.OFFSCREEN_CHECK
	CMP MAP_OBJECTS.X_APPROACH+$1
	BEQ .TILE.OFFSCREEN
	JMP .TILE_ONSCREEN

.TILE3.OFFSCREEN_CHECK

	CMP #MAP_OBJECTS.X.LAST_COLUMN
	BEQ .TILE.OFFSCREEN
	JMP .TILE_ONSCREEN
	
	
.TILE_ONSCREEN	
;IS TILE HIDDEN (DARKNESS)?	
	LDA SCREEN.DARK.DATA,Y			
	CMP #$01
	BEQ .TILE.NOTVISIBLE						;IF YES, DON'T DRAW TILE

;IS TILE PLAYER LOCATION? & CURRENT RECORD IS ACTIVE TRANSPORT? 	
	LDA SAVED.XREG.LOCAL						;LOAD MO RECORD INDEX
	CMP PLAYER.TRANSPORT.ACTIVE					;IS MO RECORD INDEX A TRANSPORT OBJECT BOARDED BY PLAYER?
	BNE .VALID.DRAW.LOCATION
	CPY #PLAYER.TRANSPORT.MT.TILE_LOCATION0		;CHECK MULTI-TILE PLAYER TRANSPORT LOCATIONS
	BEQ .EXIT_TEST								;IF PLAYER LOCATION, SKIP DRAW & SCREEN ARRAY UDPATE. (THIS IS SO THAT IF THE PLAYER IS LOCATION ON TOP OF ANOTHER TRANSPORT OBJECT,, IT WILL BE DETECTED IN THE SCREEN ARRRAY VIA BOARD COMMAND. EXAMPLE, PLAYER IS BOARDED A SKIFF AND IS LOCATED ON A TILE WITH A FRIGATE)	
	CPY #PLAYER.TRANSPORT.MT.TILE_LOCATION1		;CHECK MULTI-TILE PLAYER TRANSPORT LOCATIONS
	BEQ .EXIT_TEST								;IF PLAYER LOCATION, SKIP DRAW & SCREEN ARRAY UDPATE. (THIS IS SO THAT IF THE PLAYER IS LOCATION ON TOP OF ANOTHER TRANSPORT OBJECT,, IT WILL BE DETECTED IN THE SCREEN ARRRAY VIA BOARD COMMAND. EXAMPLE, PLAYER IS BOARDED A SKIFF AND IS LOCATED ON A TILE WITH A FRIGATE)	
	CPY #PLAYER.TRANSPORT.MT.TILE_LOCATION2		;CHECK MULTI-TILE PLAYER TRANSPORT LOCATIONS
	BEQ .EXIT_TEST								;IF PLAYER LOCATION, SKIP DRAW & SCREEN ARRAY UDPATE. (THIS IS SO THAT IF THE PLAYER IS LOCATION ON TOP OF ANOTHER TRANSPORT OBJECT,, IT WILL BE DETECTED IN THE SCREEN ARRRAY VIA BOARD COMMAND. EXAMPLE, PLAYER IS BOARDED A SKIFF AND IS LOCATED ON A TILE WITH A FRIGATE)	
	CPY #PLAYER.TRANSPORT.MT.TILE_LOCATION3		;CHECK MULTI-TILE PLAYER TRANSPORT LOCATIONS
	BEQ .EXIT_TEST								;IF PLAYER LOCATION, SKIP DRAW & SCREEN ARRAY UDPATE. (THIS IS SO THAT IF THE PLAYER IS LOCATION ON TOP OF ANOTHER TRANSPORT OBJECT,, IT WILL BE DETECTED IN THE SCREEN ARRRAY VIA BOARD COMMAND. EXAMPLE, PLAYER IS BOARDED A SKIFF AND IS LOCATED ON A TILE WITH A FRIGATE)	

.VALID.DRAW.LOCATION
	LDA MOB.MT.TILE_TYPES,X					;LOAD NEXT MT TILE_TYPE
	STA SAVED_TILE_TYPE	
	
				
		LDA #$0F							;SET TRACE
		STA CALLED_BY
	JSR DRAW.TILE.SINGLE
		LDA #$00							;RESET TRACE
		STA CALLED_BY

		
.UPDATE.SCREEN_ARRAY1
.TILE.NOTVISIBLE
	LDA SAVED.XREG.LOCAL					;LOAD MAP_OBJECTS.MOB INDEX						
	STA SCREEN.MO_TRANSPORT.DATA,Y			;SAVE TO SCREEN ARRAY TO MARK MOB'S PRESENCE FOR OTHER ROUTINES LIKE ANIMATION

.TILE.OFFSCREEN
@END

.EXIT_TEST
	INX
	CPX #$04
	BNE .LOOP
	LDX SAVED.XREG.LOCAL	
	;**FALLS THROUGH**
	
.TRANSPORT.NOTVISIBLE	
.EXIT
	;**FALLS THROUGH
@END
MOB.ENTRANCE ;	
@START
;======END-OF-ARRAY CHECK, EXTRACT FLAGS, INIT VARS=====
@START	
;END-OF-ARRAY CHECK
;(test each map array for $00 in the first field of the current record, if all arrays are at end, then exit)	
	LDA MAP_OBJECTS.MOB+$02,X				;AT END OF ARRAY?
	CMP #$00	
	BNE .EXTRACT_FLAGS
	JMP INCREMENT_INDEX


.EXTRACT_FLAGS

;EXTRACT MOB BOOLEAN FLAGS	
	LDA MAP_OBJECTS.MOB+$3,X
	LDY #$00	
.LOOP	
	LSR
	BCS .CARRY_IS_SET					
.CARRY_IS_CLEAR							;THE CARRY IS NOT KATIE
	STA SAVED.ACC.LOCAL
	LDA #$00
	JMP .WRITE_FLAG_VALUE
.CARRY_IS_SET							;THE CARRY IS KATIE
	STA SAVED.ACC.LOCAL
	LDA #$01

.WRITE_FLAG_VALUE
	STA MAP_OBJECTS.MOB_FLAGS,Y
	CPY #$07
	BEQ .FLAGS_DONE
	INY
	LDA SAVED.ACC.LOCAL
	JMP .LOOP

.FLAGS_DONE
;TROUBLESHOOTING HOOK
;RETURNS THE LO/HO ADDRESS OF THE LOCTION THE 8 FLAGS ARE STORED
	; LDX #MAP_OBJECTS.MOB_FLAGS
	; LDY /MAP_OBJECTS.MOB_FLAGS
	
	; LDA TEXT
	; LDA PAGE1
	; ;LDA MOB.FLAG2
	; BRK

;INIT VARIABLES

	LDA #$00								;START COUNTER AT 1ST MOVE
	STA MOB.MOVE.COUNTER					;USED FOR TRACKING DOUBLE MOVER MOBS
	STA MOB.MOVE.ERASE_COUNTER				;START TILE ERASE COUNTER AT $00

@END
	
.ONSCREEN_CHECK.NPM	;
@START
;=====================CODE-SECTION DOCUMENTATION====================================
;The first order of business is to determine if the current mob record
;has an x/y located on the view screen. If not, the rest of this routine 
;is skipped and the code falls through to INCREMENT.INDEX
;
;Unless the mob's record has the SS flag set. Mob's with this flag set
;are permitted to move even when not located on the view screen, IF
;they are located within the regional map. 
;
;SS mobs are managed the same way as non-SS mobs when on the view screen,
;so this code section sets a flag (MOB.SCREEN_STATUS.SS) if the current
;record is an SS located off the view screen. Other routines will use this 
;flag to make flow control descision. 
;=================================================================================

;NET OF PLAYER MOVE (NPM), CHECK TO SEE IF CURRENT MOB MO IS LOCATED ON THE VIEW SCREEN
	LDA #$00								
	STA MOB.SCREEN_STATUS.NPM					;BY DEFAULT SET TO $00 (ONSCREEN)
	STA MOB.SCREEN_STATUS.SS					;BY DEFAULT SET TO $00 (NOT OFFSCREEN SS)
	
	LDA MAP_OBJECTS.MOB,X						;LOAD X POSITION OF CURRENT MOB
	CMP #MAP_OBJECTS.X_FLAG.LOWER				;IS OBJECT BEYOND LEFT EDGE OF SCREEN?
	BCC	.MOB.NOTONSCREEN_STEP	
	
	CMP #MAP_OBJECTS.X_FLAG.UPPER				;IS OBJECT BEYOND RIGHT EDGE OF SCREEN?
	BCS	.MOB.NOTONSCREEN_STEP	
	
	LDA MAP_OBJECTS.MOB+$1,X
	CMP #MAP_OBJECTS.Y_FLAG.LOWER				;IS OBJECT BEYOND LOWER EDGE OF SCREEN?
	BCC	.MOB.NOTONSCREEN_STEP	
	
	CMP #MAP_OBJECTS.Y_FLAG.UPPER				;IS OBJECT BEYOND UPPER EDGE OF SCREEN?
	BCS	.MOB.NOTONSCREEN_STEP
								
	JMP MOB.IDENTIFY.TILE_LOCATION	

.MOB.NOTONSCREEN_STEP
					
	LDA #$01
	STA MOB.SCREEN_STATUS.NPM
	
	LDA CALLED_BY.DRAW.SCREEN
	CMP #$01
	BEQ .DEFAULT

			
	LDA MOB.FLAG1								;MOB FLAG1: ON=SS
	CMP #$01									;IS CURRENT MOB AN SS?
	BNE .DEFAULT								;IF NO, DON'T MOVE OR DRAW MOB
	LDA #$01									;IF YES, SET OFFSCREEN SS FLAG
	STA MOB.SCREEN_STATUS.SS
				
	JMP MOB.SS.REGI0N_CHECK
	
.DEFAULT	
				
	JMP MOB.NOTONSCREEN
@END

MOB.SS.REGI0N_CHECK	;======DETERMINES IF AN OFFSCREEN SS IS LOCATED ON THE REGIONAL MAP=========
@START
;=====================CODE-SECTION DOCUMENTATION====================================
;An offscreen SS mob is not permitted to move if it is not located on
;the regional map. The reason is because map data is needed for collision checks,
;and the regional map is only uncompressed tile data that exists in 
;memory when this routine is run. All other zone data is compressed
; and stored in auxiliary memory.
;
;Theoretically, a zone could be copied from auxiliary memory and uncompressed,
;to faciliate a few tile_ID lookups to do collision checks but I concluded
;this would be speed prohibitive. The player is waiting for the screen
;to be drawn after pressing a movement key, we've got to hurry it up!!
;
;=================================================================================


;THESE FLAGS ARE ADJUSTED ON EACH PLAYER MOVE (see movement_manager.asm) SINCE PLAYERS LOCATION ON REGIONAL MAP CHANGES. 	
	LDA MAP_OBJECTS.MOB,X						;LOAD X POSITION OF CURRENT MOB
	CMP MAP_OBJECTS.SS.X_FLAG.LOWER				;IS SS MOB BEYOND LEFT EDGE OF REGIONAL MAP?
	BCC	.MOB.NOTINREGION	

	CMP MAP_OBJECTS.SS.X_FLAG.UPPER				;IS SS MOB BEYOND RIGHT EDGE OF REGIONAL MAP?
	BCS	.MOB.NOTINREGION	
	
	LDA MAP_OBJECTS.MOB+$1,X
	CMP MAP_OBJECTS.SS.Y_FLAG.LOWER				;IS SS MOB BEYOND TOP EDGE OF REGIONAL MAP?
	BCC	.MOB.NOTINREGION
	
	CMP MAP_OBJECTS.SS.Y_FLAG.UPPER				;IS SS MOB BEYOND BOTTOM EDGE OF REGIONAL MAP?
	BCS	.MOB.NOTINREGION
	
		
	INC MOB.GEN.SS_QTY							;INCREMENT THE TOM CANFIELD COUNTER.
												;ACTUALLY, THAT WON'T HELP, INCREMENT THE SS COUNTER
												;INSTEAD WHICH TRACKS THE NUMBER OF OFFSCREEN SS
												;IN THE CURRENT REGION.


	JMP MOB.IDENTIFY.LOCATION
	
.MOB.NOTINREGION
	JMP MOB.NOTONSCREEN
@END
	
MOB.IDENTIFY.LOCATION ;
@START	
	LDA MOB.SCREEN_STATUS.SS
	CMP #$01 									;IS MOB AN OFFSCREEN SS?
	BEQ MOB.IDENTIFY.MAP_LOCATION				;IF YES, FIND THE MAP LOCATION FOR USE WITH COLLISION CHECKS ONLY
	JMP MOB.IDENTIFY.TILE_LOCATION				;IF NO, FIND THE SCREEN LOCATION OF THE MOB	

MOB.IDENTIFY.MAP_LOCATION ;=============USED ONLY FOR MOBS WITH SS FLAG SET=======
@START

;=====================CODE-SECTION DOCUMENTATION====================================
;
;Converts the mob's relative x,y position to an RMAP position. This
;is needed for collision checks later since the mob is not on the view
;screen and thus the screen arrays won't have the applicable tile data. 
;=================================================================================
	
;INIT VARIABLES
	LDA #$00
	STA MOB.POSITION.X_GR
	STA MOB.POSITION.X_LT
	STA MOB.POSITION.Y_GR	
	STA MOB.POSITION.Y_LT


;IDENTIFY MAP LOCATION OF MOB SO WE CAN DETERMINE WHICH MAP LOCATIONS TO CHECK FOR COLLISSIONS
	LDA MAP_OBJECTS.MOB,X
	CMP #MAP_OBJECTS.PLAYER_LOCATION
	BCC .MOB.MO_X_LESS

;MO_X_GREATER	
	LDA MAP_OBJECTS.MOB,X
	SEC
	SBC #MAP_OBJECTS.PLAYER_LOCATION
	STA MAP_OBJECTS.X_ADJ
	
;=======INLINE CODE FOR ADC.16========	
;RMAP(2)+ MAP_OBJECTS.X_ADJ(1)


; DO THE MATH
	CLD 
    CLC                       	 ;ALWAYS BEFORE ADD
    LDA RMAP
    ADC MAP_OBJECTS.X_ADJ
    STA TEMP16
		 
    LDA RMAP+$1
    ADC #$00					;carry flag not cleared via CLC intentionally, it's part of 16-bit adding. 
    STA TEMP16+$1
	
;======================================


;RECORD X-AXIS COMPARISON FOR MOB MOVEMENT 	
	LDA MAP_OBJECTS.MOB,X
	CMP #MAP_OBJECTS.PLAYER_LOCATION
	BEQ .X_AXIS.SAME
	
	STA MOB.POSITION.X_GR								;RECORDS THAT MOB'S X-AXIS IS GREATER THAN PLAYER'S. IT DOESN'T MATTER WHAT VALUE IS STORED, AS LONG AS IT IS != $00 

.X_AXIS.SAME	
	JMP .MOB.YTEST

.MOB.MO_X_LESS
	LDA #MAP_OBJECTS.PLAYER_LOCATION
	SEC
	SBC MAP_OBJECTS.MOB,X
	STA MAP_OBJECTS.X_ADJ
	
;=======INLINE CODE FOR SBC.16========	
;RMAP(2)+ MAP_OBJECTS.X_ADJ(1)
	
	CLD 
    SEC                           ;ALWAYS BEFORE SUBTRACTION
    LDA RMAP
    SBC MAP_OBJECTS.X_ADJ
    STA TEMP16
    LDA RMAP+$1
    SBC #$00
    STA TEMP16+$1
;======================================
	
;RECORD X-AXIS COMPARISON FOR MOB MOVEMENT 	

	STA MOB.POSITION.X_LT								;RECORDS THAT MOB'S X-AXIS IS LESS THAN PLAYER'S. IT DOESN'T MATTER WHAT VALUE IS STORED, AS LONG AS IT IS != $00 

.MOB.YTEST	


	LDA MAP_OBJECTS.MOB+$1,X
	CMP #MAP_OBJECTS.PLAYER_LOCATION					;IS MOB Y AXIS < PLAYER Y AXIS?
	BCC .MOB.MO_Y_LESS
	
	LDA MAP_OBJECTS.MOB+$1,X
	SEC
	SBC #MAP_OBJECTS.PLAYER_LOCATION
	TAY
	
	LDA RMAP.MULTIPLY_TABLE.LO,Y
	STA MAP_OBJECTS.Y_ADJ
	LDA RMAP.MULTIPLY_TABLE.HO,Y
	STA MAP_OBJECTS.Y_ADJ+$1
	

	
;=======INLINE CODE FOR ADC.16========	
;TEMP16(2)- MAP_OBJECTS.Y_ADJ(1)


; DO THE MATH
	CLD 								;**OPT** Memory. CLD isn't needed every time. to remove it though I need to know when I'll be using decimal mode (proabbly just with merchants) and then the map routine probably just needs to to a CLD once, so anytime somebody exits a merchant conversation it will get executed. 
    CLC                       			 ;ALWAYS BEFORE ADD
    LDA TEMP16							;PARTIAL CALCULATION. CONTAINS #MAP_OBJECTS.PLAYER_LOCATION +/- MAP_OBJECTS.X_ADJ 
    ADC MAP_OBJECTS.Y_ADJ
    STA MAP_OBJECTS.MAP_LOCATION
		 
    LDA TEMP16+$1
    ADC MAP_OBJECTS.Y_ADJ+$1			;carry flag not cleared via CLC intentionally, it's part of 16-bit adding. 
    STA MAP_OBJECTS.MAP_LOCATION+$1
	
;======================================



;RECORD Y-AXIS COMPARISON FOR MOB MOVEMENT 	
	LDA MAP_OBJECTS.MOB+$1,X
	CMP #MAP_OBJECTS.PLAYER_LOCATION
	BEQ .Y_AXIS.SAME
	
	STA MOB.POSITION.Y_GR								;RECORDS THAT MOB'S Y-AXIS IS GREATER THAN PLAYER'S. IT DOESN'T MATTER WHAT VALUE IS STORED, AS LONG AS IT IS != $00 
	
.Y_AXIS.SAME	
	JMP .EXIT

.MOB.MO_Y_LESS
	LDA #MAP_OBJECTS.PLAYER_LOCATION
	SEC
	SBC MAP_OBJECTS.MOB+$1,X		
	TAY
	LDA RMAP.MULTIPLY_TABLE.LO,Y
	STA MAP_OBJECTS.Y_ADJ
	LDA RMAP.MULTIPLY_TABLE.HO,Y
	STA MAP_OBJECTS.Y_ADJ+$1

;=======INLINE CODE FOR SBC.16========	
;TEMP16(2)- MAP_OBJECTS.Y_ADJ(1)
	
	CLD 
    SEC                           ;ALWAYS BEFORE SUBTRACTION
    LDA TEMP16
    SBC MAP_OBJECTS.Y_ADJ
    STA MAP_OBJECTS.MAP_LOCATION
    LDA TEMP16+$1
    SBC MAP_OBJECTS.Y_ADJ+$1
    STA MAP_OBJECTS.MAP_LOCATION+$1
;======================================	
		
;RECORD Y-AXIS COMPARISON FOR MOB MOVEMENT 	
	STA MOB.POSITION.Y_LT								;RECORDS THAT MOB'S Y-AXIS IS LESS THAN PLAYER'S. IT DOESN'T MATTER WHAT VALUE IS STORED, AS LONG AS IT IS != $00 
	

.EXIT
;IS MOB ON A ROW OR COLUMN ON THE EDGE OF THE VIEW SCREEN (/AKA AN APPROACH ROW/COLUMN), AND A ROW OR COLUMN IS WITHIN THE VIEW SCREEN BOUNDARIES?
;IF YES, IDENTIFY THE TILE LOCATION JUST IN CASE THE MOB MOVES INTO THE VIEW SCREEN.
	
			
	LDY #$00	
.LOOP	
	LDA MAP_OBJECTS.MOB,X
	CMP MAP_OBJECTS.X_APPROACH,Y				;CHECK X-AXIS APPROACH VALUES	
	BEQ .CHECK.Y_AXIS							;IF ON X APPROACH COLUMN, CHECK Y-AXIS
	
	LDA MAP_OBJECTS.MOB+$1,X
	CMP MAP_OBJECTS.Y_APPROACH,Y				;CHECK Y-AXIS APPROACH VALUES
	BEQ .CHECK.X_AXIS							;IF ON Y APPROACH ROW, CHECK X-AXIS
	
	INY
	CPY #$04
	BNE .LOOP
	
.CHECK.X_AXIS
	LDA MAP_OBJECTS.MOB,X						;LOAD X POSITION OF CURRENT MOB
	CMP #MAP_OBJECTS.X_FLAG.LOWER				;IS OBJECT BEYOND LEFT EDGE OF SCREEN?
	BCC	.MOB_NOT_ON_EDGE	
	
	CMP #MAP_OBJECTS.X_FLAG.UPPER				;IS OBJECT BEYOND RIGHT EDGE OF SCREEN?
	BCS	.MOB_NOT_ON_EDGE	

	JMP MOB.IDENTIFY.TILE_LOCATION

.CHECK.Y_AXIS	
	LDA MAP_OBJECTS.MOB+$1,X
	CMP #MAP_OBJECTS.Y_FLAG.LOWER				;IS OBJECT BEYOND LOWER EDGE OF SCREEN?
	BCC	.MOB_NOT_ON_EDGE	
	
	CMP #MAP_OBJECTS.Y_FLAG.UPPER				;IS OBJECT BEYOND UPPER EDGE OF SCREEN?
	BCS	.MOB_NOT_ON_EDGE
	
	JMP MOB.IDENTIFY.TILE_LOCATION
	

.MOB_NOT_ON_EDGE
	JMP MOB.MOVEMENT
@END
	
MOB.IDENTIFY.TILE_LOCATION	
@START
;=====================CODE-SECTION DOCUMENTATION====================================
;
;This code section (virtually identical to it's transport counterpart above,
;is responsible for converting the mob's relative x,y position into a 
;screen tile location (the index to the screen arrays).
;The screen tile location is later to used during the mob movement
;routines in activies such as collission checks. The screen tile location
;is also used to draw the tile since DRAW.TILE.SINGLE needs this as a parameter
;
;The mechanic of doing the conversion is essentially done by using the 
;difference between the player's x/y and the mob's x/y as an adjustment to 
;the players screen tile position, using the appropriate offsets for the
;screen tile grid. For example, for a y axis differential, a multiplication table is used
;to calculate the offset to apply to the player's location. 
;
;Calculating the difference between player and mob x,y starts 
;determining whether the mob x,y is less than the player x,y.
;This is done so that negative numbers can be avoided. 
;
;=================================================================================
			
;INIT VARIABLES
	LDA #$00
	STA MOB.POSITION.X_GR
	STA MOB.POSITION.X_LT
	STA MOB.POSITION.Y_GR	
	STA MOB.POSITION.Y_LT

;IDENTIFY SCREEN TILE #							;OBJECT IS ON SCREEN, WHICH SCREEN TILE SHOULD WE DRAW IT IN?
	LDA MAP_OBJECTS.MOB,X
	CMP #MAP_OBJECTS.PLAYER_LOCATION
	BCC .MOB.MO_X_LESS
	
	LDA MAP_OBJECTS.MOB,X ;**OPT** Speed. Memory. This line can probably be deleted as that value is already in ACC
	SEC
	SBC #MAP_OBJECTS.PLAYER_LOCATION
	STA MAP_OBJECTS.X_ADJ
	LDA #SCREEN.ARRAY.PLAYER_LOCATION
	CLC
	ADC MAP_OBJECTS.X_ADJ
	STA TEMP

;RECORD X-AXIS COMPARISON FOR MOB MOVEMENT 	
	LDA MAP_OBJECTS.MOB,X
	CMP #MAP_OBJECTS.PLAYER_LOCATION
	BEQ .X_AXIS.SAME	
	STA MOB.POSITION.X_GR								;RECORDS THAT MOB'S X-AXIS IS GREATER THAN PLAYER'S. IT DOESN'T MATTER WHAT VALUE IS STORED, AS LONG AS IT IS != $00 

.X_AXIS.SAME	


	JMP .MOB.YTEST

.MOB.MO_X_LESS
	LDA #MAP_OBJECTS.PLAYER_LOCATION
	SEC
	SBC MAP_OBJECTS.MOB,X
	STA MAP_OBJECTS.X_ADJ
	LDA #SCREEN.ARRAY.PLAYER_LOCATION
	SEC
	SBC MAP_OBJECTS.X_ADJ
	STA TEMP

;RECORD X-AXIS COMPARISON FOR MOB MOVEMENT 	

	STA MOB.POSITION.X_LT								;RECORDS THAT MOB'S X-AXIS IS LESS THAN PLAYER'S. IT DOESN'T MATTER WHAT VALUE IS STORED, AS LONG AS IT IS != $00 


.MOB.YTEST	

	LDA MAP_OBJECTS.MOB+$1,X
	CMP #MAP_OBJECTS.PLAYER_LOCATION
	BCC .MOB.MO_Y_LESS
	
	LDA MAP_OBJECTS.MOB+$1,X				;**OPT** Speed. Memory. This line can probably be deleted as that value is already in ACC
	SEC
	SBC #MAP_OBJECTS.PLAYER_LOCATION
	TAY
	LDA SCREEN.MULTIPLY_TABLE,Y
	STA MAP_OBJECTS.Y_ADJ
	
	LDA TEMP								;PARTIAL CALCULATION. CONTAINS #MAP_OBJECTS.PLAYER_LOCATION +/- MAP_OBJECTS.X_ADJ 
	CLC
	ADC MAP_OBJECTS.Y_ADJ
	STA MAP_OBJECTS.TILE_LOCATION
		

;RECORD X-AXIS COMPARISON FOR MOB MOVEMENT 	
	LDA MAP_OBJECTS.MOB+$1,X
	CMP #MAP_OBJECTS.PLAYER_LOCATION
	BEQ .Y_AXIS.SAME
	
	STA MOB.POSITION.Y_GR								;RECORDS THAT MOB'S Y-AXIS IS GREATER THAN PLAYER'S. IT DOESN'T MATTER WHAT VALUE IS STORED, AS LONG AS IT IS != $00 
.Y_AXIS.SAME	

	JMP .FINAL_ROUTINE

.MOB.MO_Y_LESS
	LDA #MAP_OBJECTS.PLAYER_LOCATION
	SEC
	SBC MAP_OBJECTS.MOB+$1,X		
	TAY
	LDA SCREEN.MULTIPLY_TABLE,Y
	STA MAP_OBJECTS.Y_ADJ
	
	LDA TEMP								;PARTIAL CALCULATION. CONTAINS #MAP_OBJECTS.PLAYER_LOCATION +/- MAP_OBJECTS.X_ADJ 
	SEC
	SBC MAP_OBJECTS.Y_ADJ
	STA MAP_OBJECTS.TILE_LOCATION										

	


;RECORD Y-AXIS COMPARISON FOR MOB MOVEMENT 	
	STA MOB.POSITION.Y_LT					;RECORDS THAT MOB'S Y-AXIS IS LESS THAN PLAYER'S. IT DOESN'T MATTER WHAT VALUE IS STORED, AS LONG AS IT IS != $00 


.FINAL_ROUTINE
;IF MULTI-TILE MOB, RECORD THE SCREEN TILE # FOR EACH OF IT'S FOUR TILES

	LDA MOB.FLAG3							
	CMP #$01								;IS CURENT MO RECORD FOR A MULTI-TILE MOB?
	BNE MOB.MOVEMENT
	LDY MAP_OBJECTS.TILE_LOCATION			;LOAD TILE LOCATION CALCUALTED IN MAIN ROUTINE ABOVE
	STY MOB.MT.TILE_LOCATIONS				;SAVE AS TILE #0 (UPPER LEFT) OF MT MOB

	INY
	STY MOB.MT.TILE_LOCATIONS+$1			;SAVE AS TILE #1 (UPPER RIGHT) OF MT MOB
	TYA
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	STA MOB.MT.TILE_LOCATIONS+$3			;SAVE AS TILE #3 (LOWER RIGHT) OF MT MOB
	TAY
	DEY
	STY MOB.MT.TILE_LOCATIONS+$2			;SAVE AS TILE #2 (LOWER LEFT) OF MT MOB

	;******FALLS THROUGH
	
@END
@END
	
MOB.MOVEMENT
@START
;=====================CODE-SECTION DOCUMENTATION====================================
;
;The following is an outline of the approach taken for mob movement:
;	*Is mob stopped by slow progress (terrain driven)? If yes, them move = pass (.SLOW.PROGRESS.CHECK)
;  *Collision check: examine the adjancent tile in all 4 directions and 
;		record whether each is blocked or permitted. (CHOOSE.COLLISION.SUBROUTINE)
;  *Based on the mob's position on the screen relative to the player, 
;		record primary and secondary moves based on the shortest path to 
;		the player. Movement profiles determined by flags aren't considered yet. (IDENTIFY.SCREEN_SECTION) 
;	*Use random numbers to choose between the various primary and secondary moves. 
;		is based on which, if any, moves are blocked and the movement profile of the mob 
;		as indicated by the flag setting on the mob's record. (CHOOSE.MOB.MOVE)
;		Be careful if you have to take a look at the mob's record. It's worse that I thought (Bob the Orc's greatest polka hits).
;=================================================================================

;====TOP LEVEL FLOW CONTROL & INIT VARIABLES====
@START

;CALLING ROUTINE CHECK: INITIAL SCREEN DRAW 
	
	LDA CALLED_BY.DRAW.SCREEN
	CMP #$01
	BNE .NOT_INITIAL_DRAW
	JMP MOB.DRAWTILE.ENTRANCE2


.NOT_INITIAL_DRAW
;IS MOB APPEARING ON SCREEN FOR FIRST TIME? IF SO, SKIP MOVEMENT. 
;(IF SCREEN STATUS AT START WAS OFFSCREEN AND SCREEN STATUS AFTER PLAYER MOVE IS ONSCREEN, THEN SKIP)
;

	LDA MOB.SCREEN_STATUS.START			;CHECK SCREEN STATUS AT START
	CMP #$01							;$01 = OFFSCREEN
	BNE .MOB.MOVEMENT.START
	LDA MOB.SCREEN_STATUS.NPM			;CHECK SCREEN STATUS NET OF PLAYER MOVE (NPM)
	CMP #$00							;$00 = ONSCREEN
	BNE .MOB.MOVEMENT.START
	
	LDA #$10
	STA MOB.MOVE.COUNTER				;WHEN A DOUBLE MOVER FIRST APPEARS ON SCREEN IT FORFEITS IT'S 2ND MOVE
	JMP MOB.DRAWTILE
	
.MOB.MOVEMENT.START
;TESTHOOK1
;Reports the RMAP of the current MOB (only works if MOB has SS Flag set)
				;LDX MAP_OBJECTS.MAP_LOCATION
				;LDY MAP_OBJECTS.MAP_LOCATION+$1


;INIT VARIABLES
	LDY #$00
	STY MOB.MOVE.TOTAL_OPEN_PATHS
	LDA #$FF
.INIT_LOOP
	STA MOB.MOVE.OPTIONS_PRIMARY,Y							
	STA MOB.MOVE.OPTIONS_SECONDARY,Y	
	STA MOB.MOVE.OPEN_PATHS,Y
	LDA #$00
	STA MOB.MOVES.BLOCKED,Y	
	CPY #$04
	BEQ .DONE2
	INY
	JMP .INIT_LOOP
.DONE2	
@END

;====IS MOB FROZEN?=============================
@START
.MOB.FROZEN.CHECK

	LDA MOB.FLAG0					;MOB FROZEN IF FLAG0 = $00 AND FLAG1 = $01
	BNE .SLOW.PROGRESS.CHECK
	LDA MOB.FLAG1
	BEQ .SLOW.PROGRESS.CHECK
	JMP .FORCE_PASS					;SKIP COLLISION CHECKS AND REGULAR MOVE SELECTION ROUTINES

@END

;====IS MOB ON SLOW PROGRESS TERRAIN?===========
@START
.SLOW.PROGRESS.CHECK
	LDY MAP_OBJECTS.TILE_LOCATION

	LDA SCREEN.TILE.DATA,Y
	CMP #TILE_ID.HILLS
	BNE .CHECK.GAME.TURN
	
	JSR RANDOM.8
	CMP #$C0								;IF MOB TILE IS ON HILLS THEN 25% CHANCE OF SLOW PROGRESS
	BCC .CHECK.GAME.TURN					;NO SLOW PROGRESS
	
	LDA #$01								;SET SLOW PROGRESS FLAG TO ON. THIS IS TO FORCE A DRAW OF THE TILE IF MOB IS A DOUBLE MOVER BECAUSE SLOW PROGRESS = PASS AND NORMALLY TILES AREN'T DRAWN ON A PASS BECAUSE THE MOB'S POSITION HASN'T CHANGED. HOWEVER, IF IT'S THE DOUBLE MOVER'S SECOND MOVE WHEN THE SLOW PROGRESS/PASS OCCURS, IT'S POSITION HAS CHANGED. 
	STA MOB.MOVE.SLOW.PROGRESS 
	;**FALLS THROUGH
	
.FORCE_PASS	
	LDA #$04
	STA MOB.MOVE.CURRENT 					;SET MOB'S FINAL MOVE DECISION TO PASS, WHICH IS HOW SLOW PROGRESS IS IMPLIMENTED

	STX SAVED.XREG.LOCAL					;MOB.MOVE.MAKE EXPECTS THE CURRENT MOB RECORD INDEX TO BE IN THIS VARIABLE
	JMP MOB.MOVE.MAKE

.CHECK.GAME.TURN
	LDA GAME.TURN.CONTROL					;$00 FOR PLAYER TURN, HOLDS $01 FOR MOB/NPC TURN
	BNE .CHOOSE.COLLISION.SUBROUTINE		;IF MOBS TURN, CONTINUE 
	JMP .FORCE_PASS							;IF PLAYERS TURN, (THIS COULD HAPPEN IF PLAYER HAS BOARDED TRANSPORT THAT GIVES PLAYER MULTIPLE MOVES)

@END
	
.CHOOSE.COLLISION.SUBROUTINE
@START
;CHOOSE COLLISION CHECK SUBROUTINE

				
	LDA MOB.FLAG1										;FLAG1: ON=SS										
	CMP #$01											
	BNE COLLISION_CHECK_ONSCREEN						;IF NOT SS, ALWAYS USE ONSCREEN ROUTINE

	LDA MOB.SCREEN_STATUS.NPM
	CMP #$00											;EVEN IF SS, USE ONSCREEN ROUTINE IF THE SS'S X/Y IS ON THE VIEW SCREEN, AS MAP POSITION IS NO LONGER NEEDED 
	BEQ COLLISION_CHECK_ONSCREEN
	
	JMP COLLISION_CHECK_OFFSCREEN						;ONLY IF AN SS, AND OFFSCREEN. USES RMAP POSITION FOR COLLISION CHECKS. 
	
	
	
COLLISION_CHECK_ONSCREEN_MTT_STEP
	JMP COLLISION_CHECK_ONSCREEN_MTT
	
COLLISION_CHECK_ONSCREEN
@START
;Collision check for all on-screen mobs (including SS type)	

	LDA MOB.FLAG3								;IS CURRENT MOB RECORD A MULTI-TILE MOB?
	CMP #$01
	BEQ COLLISION_CHECK_ONSCREEN_MTT_STEP		;IF YES, USE THE MULTI-TILE COLLISION CHECK

;===COLLISION CHECK

;STORE TILE #S ADJACENT TO MOB IN AN ARRAY SO WE CAN USE A LOOP TO APPLY COLLISION RULES

;	LDY	MAP_OBJECTS.TILE_LOCATION   (DUPLICATE)

;SAVE TILE # NORTH OF MOB
	TYA
	SEC
	SBC #SCREEN.ARRAY.OFFSET
	STA MOB.ADJACENT_TILES						;BORROWING SCREEN.TILE.HOPPER TO STORE THE TILE #S ADJACENT TO THE MOB
;SAVE TILE # SOUTH OF MOB
	TYA
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	STA MOB.ADJACENT_TILES+$1					;BORROWING SCREEN.TILE.HOPPER TO STORE THE TILE #S ADJACENT TO THE MOB
;SAVE TILE # EAST OF MOB
	INY
	STY MOB.ADJACENT_TILES+$2					;BORROWING SCREEN.TILE.HOPPER TO STORE THE TILE #S ADJACENT TO THE MOB
;SAVE TILE # WEST OF MOB
	DEY
	DEY
	STY MOB.ADJACENT_TILES+$3					;BORROWING SCREEN.TILE.HOPPER TO STORE THE TILE #S ADJACENT TO THE MOB

	STX SAVED.XREG.LOCAL						;COLLISION LOOP WILL USE BOTH X/Y-REG	
	LDA MAP_OBJECTS.MOB+$2,X
	CMP #COLLISION_FLAG.MOB_SEA.START			;FIRST TILE IN SEA MOB RANGE. 
	BCS .COLLISION.LOOP.MOB_SEA_STEP
	JMP .LOOP.MOB_LAND.ENTRANCE

.COLLISION.LOOP.MOB_SEA_STEP
	JMP .COLLISION.LOOP.MOB_SEA
	
@MIDDLE	
.LOOP.MOB_LAND.ENTRANCE
	LDX #$00
.LOOP.MOB_LAND
	LDA MOB.ADJACENT_TILES,X					;LOAD NEXT ADJACENT TILE#
	TAY

	
;IS PLAYER ADJACENT? IF SO, ATTACK
	CPY #$5D
	BNE .OVERRIDE_TEST
	LDX SAVED.XREG.LOCAL
	JMP COMBAT
	
.OVERRIDE_TEST	
;IS MOB COLLISION OVERRIDE ON?
	LDA MOB.COLLISION_OVERRIDE
	CMP #$01
	BEQ .MOVE_PERMITTED

;DOES MOB HAVE A SPECIAL COLISSION FLAG? 
;Note: a special colission flag specifies the type types permitted instead of the standard rules which specify the tile tiles not permitted

	LDA MOB.FLAG5
	CMP #$01
	BEQ .SPECIAL.COLLISION.FLAG
	
.WALKING_RULES		
;APPLY MOB WALKING COLLISION RULES		
	LDA SCREEN.MO_MOB.DATA,Y					;DOES DESTINATION TILE HAVE A MOB MO?	
	CMP #$FF
	BNE .MOVE_BLOCKED

	LDA SCREEN.MO_TRANSPORT.DATA,Y				;DOES DESTINATION TILE HAVE A TRANSPORT MO?	
	CMP #$FF
	BNE .MOVE_BLOCKED						
	
	
	LDA SCREEN.TILE.DATA,Y						;LOAD TILE TYPE OF DESTINATION TILE
	
	CMP #COLLISION_FLAG.MOB_LAND.LT1			;ABSOLUTE OBSTACLE?
	BCC .MOVE_BLOCKED

	CMP #COLLISION_FLAG.MOB_LAND.EQ1			;QUICKSAND?
	BEQ .MOVE_BLOCKED
	
	CMP #COLLISION_FLAG.MOB_LAND.GRE			;WATER?	
	BCS .WATER_TEST1.PASS
	JMP .NEXT_COLLISION_TEST
.WATER_TEST1.PASS
	CMP #COLLISION_FLAG.MOB_LAND.LT2			;WATER?	
	BCC .MOVE_BLOCKED
	
.NEXT_COLLISION_TEST	
;NO MORE TESTS FOR NOW

;	JMP .MOVE_PERMITTED
@MIDDLE

.MOVE_PERMITTED
	LDA #$00		;PERMITTS MOVE BY RECORDING $00 
	STA MOB.MOVES.BLOCKED,X
	;**OPT** Memory. Speed. Moves are permitted by default ($00 is init to the MOB.MOVES.BLOCKED array at start of MOB.MOVEMENT.START). I think I can commment out the above two lines in this section and the other Collision check sections. 
	JMP .COLLISION_EXIT_TEST

.SPECIAL.COLLISION.FLAG
;Note: a special colission flag specifies the type types permitted instead of the standard rules which specify the tile tiles not permitted
	
	LDA MOB.FLAG6
	CMP #$01
	BEQ .SPECIAL_FLAG.COASTAL
	;ADD MORE CHECKS FOR FUTURE FLAGS
	
.SPECIAL_FLAG.COASTAL

	LDA SCREEN.TILE.DATA,Y						;LOAD TILE TYPE OF DESTINATION TILE
	CMP #COLLISION_FLAG.MOB_CROC.EQ2			;IS TILE SHALLOW WATER?
	BEQ .MOVE_PERMITTED							;IF YES, PERMIT MOVE IN THIS DIRECTION
	CMP #COLLISION_FLAG.MOB_CROC.EQ1			;IS TILE BEACH
	BEQ .MOVE_PERMITTED							;IF YES, PERMIT MOVE IN THIS DIRECTION
	CMP #COLLISION_FLAG.MOB_CROC.GRE1			;IS TILE_ID LESS THAN THE START OF LAND-WATER TILE RANGE?
	BCC .MOVE_BLOCKED							;IF YES, BLOCK MOVE
	CMP	#COLLISION_FLAG.MOB_CROC.LT1			;FROM THE LAST TEST WE KNOW THE TILE IS >= THE START OF THE LAND-TILE RANGE. IS TILE_ID LESS THAN THE END OF LAND-WATER TILE RANGE?
	BCC	.MOVE_PERMITTED							;IF YES, PREMITT MOVE
	;***FALLS THROUGH****

.MOVE_BLOCKED
	LDA #$01		;BLOCKS MOVE BY RECORDING $01
	STA MOB.MOVES.BLOCKED,X

.COLLISION_EXIT_TEST
		LDA #$AA
		STA TEMP16
	CPX #$03
	BEQ .COLLISION_TESTS_COMPLETE_STEP
	INX
	JMP .LOOP.MOB_LAND

.COLLISION.LOOP.MOB_SEA	
	;***<INSERT RULES FOR SEA MOBS>***
	;COPY THE SECTION ABOVE FOR LAND MOBS AS A STARTING POINT
	
	;****NOTE: make sure to check for player location using regular constant and also the constants for the MT frigate if frigate is active as transport

.COLLISION_TESTS_COMPLETE_STEP
	JMP COLLISION_TESTS_COMPLETE
	
@END
	
COLLISION_CHECK_ONSCREEN_MTT ;
@START
;Collision check for all on-screen mobs (including SS type)	



;STORE TILE #S ADJACENT TO MOB IN AN ARRAY SO WE CAN USE A LOOP TO APPLY COLLISION RULES
;
;The following Diagram illustrates the MT MOB's Tiles ($0-$3) and the adjacent tiles to be 
;checked for collision ($0-$7). If any tile in the directional group (i.e. $0-$1 is the north group)
;then the direction is marked as blocked in MOB.BLOCKED.MOVES	
;	  01
;    6014
;	 7235
;	  23
;
;The following routine uses the upper left tile of the MT MOB as the starting point and
;uses offsets to calculate the screen tile #s of each of the adjacent tiles. 
	STX SAVED.XREG.LOCAL						;SAVE MOB RECORD INDEX	
	LDX #$00
	;**OPT** Above LDX looks duplicate. .LOOP.IDENTIFY_TILES doesn't seem to be a loop and there is another LDX #$00 right before the next loop. 

.LOOP.IDENTIFY_TILES
	;NORTH GROUP
	LDA	MOB.MT.TILE_LOCATIONS+$0
	SEC
	SBC #SCREEN.ARRAY.OFFSET
	TAY
	STY MOB.MT.ADJACENT_TILES+$0
	INY
	STY MOB.MT.ADJACENT_TILES+$1
	;EAST GROUP
	LDY MOB.MT.TILE_LOCATIONS+$3
	INY
	STY MOB.MT.ADJACENT_TILES+$5
	TYA
	SBC #SCREEN.ARRAY.OFFSET
	TAY
	STY MOB.MT.ADJACENT_TILES+$4
	;WEST GROUP	
	LDY	MOB.MT.TILE_LOCATIONS+$2
	DEY 
	STY MOB.MT.ADJACENT_TILES+$7
	TYA
	SBC #SCREEN.ARRAY.OFFSET
	TAY
	STY MOB.MT.ADJACENT_TILES+$6	
	;SOUTH GROUP					;SOUTH COMES LAST BECAUSE IT CLEARS THE CARRY FLAG. THIS WAY ONLY ONE SEC IS NEEDED ABOVE, SINCE NO UNDERFLOWS ARE EXPECTED
	LDA	MOB.MT.TILE_LOCATIONS+$2
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	TAY
	STY MOB.MT.ADJACENT_TILES+$2
	INY
	STY MOB.MT.ADJACENT_TILES+$3
	
@MIDDLE
;MOB.MT.ADJACENT_TILES Diagram
;North Group: 0,1
;South Group: 2,3
;East Group : 4,5
;West Group : 6,7	

;SUMMARY OF INDEXES
;SAVED.XREG.LOCAL == MOB RECORD INDEX
;MOB.MT.GROUP_COUNTER == OUTERLOOP INDEX
;Y-REG == INNERLOOP INDEX & MISC USE


;===COLLISION CHECK

	LDX #$00
	STX MOB.MT.GROUP_COUNTER
.OUTERLOOP
	LDX MOB.MT.GROUP_COUNTER
	
	CPX #$00
	BEQ .SET_GROUP_NORTH
	CPX #$01
	BEQ .SET_GROUP_SOUTH
	CPX #$02
	BEQ .SET_GROUP_EAST
	CPX #$03
	BEQ .SET_GROUP_WEST
	JMP .ERROR
	
.SET_GROUP_NORTH
	LDA #MOB.MT.NORTH_GROUP
	STA MOB.MT.ADJACENT_TILES.PTR
	LDA /MOB.MT.NORTH_GROUP
	STA MOB.MT.ADJACENT_TILES.PTR+$1
	
	JMP .GROUP_SET_COMPLETE
	
.SET_GROUP_SOUTH
	LDA #MOB.MT.SOUTH_GROUP
	STA MOB.MT.ADJACENT_TILES.PTR
	LDA /MOB.MT.SOUTH_GROUP
	STA MOB.MT.ADJACENT_TILES.PTR+$1
	JMP .GROUP_SET_COMPLETE	

.SET_GROUP_EAST
	LDA #MOB.MT.EAST_GROUP
	STA MOB.MT.ADJACENT_TILES.PTR
	LDA /MOB.MT.EAST_GROUP
	STA MOB.MT.ADJACENT_TILES.PTR+$1
	
	JMP .GROUP_SET_COMPLETE

.SET_GROUP_WEST
	LDA #MOB.MT.WEST_GROUP
	STA MOB.MT.ADJACENT_TILES.PTR
	LDA /MOB.MT.WEST_GROUP
	STA MOB.MT.ADJACENT_TILES.PTR+$1
	
	JMP .GROUP_SET_COMPLETE
.GROUP_SET_COMPLETE	


@MIDDLE
	LDY #$00
.LOOP.DIRECTION_GROUP
	LDA (MOB.MT.ADJACENT_TILES.PTR),Y			;LOAD NEXT ADJACENT TILE#
	TAX
	
	
;IS PLAYER ADJACENT? IF SO, ATTACK
	CPX #$5D
	BNE .OVERRIDE_TEST
	LDX SAVED.XREG.LOCAL
	JMP COMBAT
	
.OVERRIDE_TEST
;IS MOB COLLISION OVERRIDE ON?
	LDA MOB.COLLISION_OVERRIDE
	CMP #$01
	BEQ .COLLISION_TESTS_COMPLETE_STEP			;THE PERMIT CODE IS INIT TO MOB.MOVES.BLOCKED BY DEFAULT, SO NO NEED TO WRITE IT HERE.
	
		
;APPLY MOB WALKING COLLISION RULES		
	LDA SCREEN.MO_MOB.DATA,X					;DOES DESTINATION TILE HAVE A MOB MO?	
	CMP #$FF
	BNE .MOVE_BLOCKED

	LDA SCREEN.MO_TRANSPORT.DATA,X				;DOES DESTINATION TILE HAVE A TRANSPORT MO?	
	CMP #$FF
	BNE .MOVE_BLOCKED						
	
	
	LDA SCREEN.TILE.DATA,X						;LOAD TILE TYPE OF DESTINATION TILE
	
	CMP #COLLISION_FLAG.MOB_LAND.LT1			;ABSOLUTE OBSTACLE?
	BCC .MOVE_BLOCKED

	CMP #COLLISION_FLAG.MOB_LAND.EQ1			;QUICKSAND?
	BEQ .MOVE_BLOCKED
	
	CMP #COLLISION_FLAG.MOB_LAND.GRE			;WATER?	
	BCS .WATER_TEST1.PASS
	JMP .NEXT_COLLISION_TEST
.WATER_TEST1.PASS
	CMP #COLLISION_FLAG.MOB_LAND.LT2			;WATER?	
	BCC .MOVE_BLOCKED
	
.NEXT_COLLISION_TEST	
;NO MORE TESTS FOR NOW
	JMP .COLLISION_EXIT_TEST

@MIDDLE
	
.COLLISION.LOOP.MOB_SEA	
	;***<INSERT RULES FOR SEA MOBS>***
	;COPY THE SECTION ABOVE FOR LAND MOBS AS A STARTING POINT

	;****NOTE: make sure to check for player location using regular constant and also the constants for the MT frigate if frigate is active as transport
	
.MOVE_BLOCKED
	LDX MOB.MT.GROUP_COUNTER
	LDA #$01		;BLOCKS MOVE BY RECORDING $01
	STA MOB.MOVES.BLOCKED,X	
	LDY #$01									;FORCE TERMINATION OF INNER LOOP. ONLY ONE BLOCKED TILE PER DIRECTIONAL GROUP IS REQUIRED TO MARK THAT DIRECTION IS BLOCKED. 
	
.COLLISION_EXIT_TEST
	CPY #$01
	BEQ .INNERLOOP_COMPLETE
	INY
	JMP .LOOP.DIRECTION_GROUP

.INNERLOOP_COMPLETE	
	LDX MOB.MT.GROUP_COUNTER
	CPX #$03
	BEQ .COLLISION_TESTS_COMPLETE_STEP
	INX
	STX MOB.MT.GROUP_COUNTER
	JMP .OUTERLOOP


.COLLISION_TESTS_COMPLETE_STEP

			; LDX #MOB.MOVES.BLOCKED
			; LDY /MOB.MOVES.BLOCKED
			; LDA TEXT
			; LDA PAGE1
			; BRK
			
	JMP COLLISION_TESTS_COMPLETE
.ERROR
;COLLISION_CHECK_ONSCREEN_MTT, .OUTERLOOP Reports unexpected value (!=0,4,8,$C) in MOB.MT.GROUP_COUNTER
	BRK
@END
 	
COLLISION_CHECK_OFFSCREEN
@START
;===COLLISION CHECK FOR MOBS WITH SS FLAG SET, WHICH ARE LOCATED OFF THE VIEW SCREEN====

;STORE TILE #S ADJACENT TO MOB IN AN ARRAY SO WE CAN USE A LOOP TO APPLY COLLISION RULES

	STX SAVED.XREG.LOCAL						;COLLISION_CHECK_ONSCREEN USE AN X INDEX, SO IT SAVES X-REG, RESULTING IN A RESTORE X-REG UP AHEAD. SO THIS CODE NEEDS TO SAVE X-REG TO SO THAT THE CORRECT VALUE IS LOADED IN THE RESTORE. 
;SAVE TILE # NORTH OF MOB
;=======INLINE CODE FOR SBC.16========	
;MAP_OBJECTS.MAP_LOCATION(2)- #OFFSET.UP(1)
	
	CLD 
    SEC                           ;ALWAYS BEFORE SUBTRACTION
    LDA MAP_OBJECTS.MAP_LOCATION
    SBC #OFFSET.UP
    STA RMAP.LOOKUP	
    LDA MAP_OBJECTS.MAP_LOCATION+$1
    SBC #$00
    STA RMAP.LOOKUP+$1	
	
;======================================

;LOOKUP TILE_TYPE
;=======INLINE CODE FOR ADC.16========	
;RZONE.ARRAY(2) + RMAP.LOOKUP(2)
	
	CLC                          			;ALWAYS BEFORE ADD
	LDA #RZONE.ARRAY						;OP1
	ADC RMAP.LOOKUP							;OP2  
	STA RZONE.ARRAY.INDEX_ROW
				 
	LDA /RZONE.ARRAY						;OP1+$1
	ADC RMAP.LOOKUP+$1						;OP2+$2 carry flag not cleared via CLC intentionally, it's part of 16-bit adding. 
	STA RZONE.ARRAY.INDEX_ROW+$1
;======================================	

	LDY #$00
	LDA (RZONE.ARRAY.INDEX_ROW),Y	;LOOKUP TILE_TYPE FROM REGIONAL MAP ARRAY
	STA MOB.ADJACENT_TILES		 	;BORROWING SCREEN.TILE.HOPPER TO STORE THE TILE TYPE ADJACENT TO THE MOB
				
;
;SAVE TILE # WEST OF MOB
;=======INLINE CODE FOR SBC.16========	
;MAP_OBJECTS.MAP_LOCATION(2) - $01 (ALWAYS THE OFFSET TO THE LEFT)
	
	CLD 
    SEC                         	  ;ALWAYS BEFORE SUBTRACTION
    LDA MAP_OBJECTS.MAP_LOCATION
    SBC #$01
    STA RMAP.LOOKUP	
    LDA MAP_OBJECTS.MAP_LOCATION+$1
    SBC #$00
    STA RMAP.LOOKUP+$1					;BORROWING SCREEN.TILE.HOPPER TO STORE THE RMAP OF THE TILE #S ADJACENT TO THE MOB
;======================================
;LOOKUP TILE_TYPE
;=======INLINE CODE FOR ADC.16========	
;RZONE.ARRAY(2) + RMAP.LOOKUP(2)
	
	CLC                          			;ALWAYS BEFORE ADD
	LDA #RZONE.ARRAY						;OP1
	ADC RMAP.LOOKUP							;OP2  
	STA RZONE.ARRAY.INDEX_ROW
				 
	LDA /RZONE.ARRAY						;OP1+$1
	ADC RMAP.LOOKUP+$1						;OP2+$2 carry flag not cleared via CLC intentionally, it's part of 16-bit adding. 
	STA RZONE.ARRAY.INDEX_ROW+$1
;======================================	

	LDY #$00
	LDA (RZONE.ARRAY.INDEX_ROW),Y		;LOOKUP TILE_TYPE FROM REGIONAL MAP ARRAY
	STA MOB.ADJACENT_TILES+$3			;BORROWING SCREEN.TILE.HOPPER TO STORE THE TILE TYPE ADJACENT TO THE MOB	

;
;				
;SAVE TILE # EAST OF MOB
;=======INLINE CODE FOR ADC.16========	
;MAP_OBJECTS.MAP_LOCATION(2)+ $01 (ALWAYS THE OFFSET TO THE RIGHT)


; DO THE MATH
	CLD 								
    CLC                       			 ;ALWAYS BEFORE ADD
    LDA MAP_OBJECTS.MAP_LOCATION							
    ADC #$01
    STA RMAP.LOOKUP
		 
    LDA MAP_OBJECTS.MAP_LOCATION+$1
    ADC #$00							;carry flag not cleared via CLC intentionally, it's part of 16-bit adding. 
    STA RMAP.LOOKUP+$1			
	
;======================================


;LOOKUP TILE_TYPE
;=======INLINE CODE FOR ADC.16========	
;RZONE.ARRAY(2) + RMAP.LOOKUP(2)
	
	CLC                          			;ALWAYS BEFORE ADD
	LDA #RZONE.ARRAY						;OP1
	ADC RMAP.LOOKUP							;OP2  
	STA RZONE.ARRAY.INDEX_ROW
				 
	LDA /RZONE.ARRAY						;OP1+$1
	ADC RMAP.LOOKUP+$1						;OP2+$2 carry flag not cleared via CLC intentionally, it's part of 16-bit adding. 
	STA RZONE.ARRAY.INDEX_ROW+$1
;======================================	

	LDY #$00
	LDA (RZONE.ARRAY.INDEX_ROW),Y		;LOOKUP TILE_TYPE FROM REGIONAL MAP ARRAY
	STA MOB.ADJACENT_TILES+$2			;BORROWING SCREEN.TILE.HOPPER TO STORE THE TILE TYPE ADJACENT TO THE MOB		
				
;
;	
;SAVE TILE # SOUTH OF MOB
;=======INLINE CODE FOR ADC.16========	
;MAP_OBJECTS.MAP_LOCATION(2)+ #OFFSET.DOWN(1)


; DO THE MATH
	CLD 								
    CLC                       			 ;ALWAYS BEFORE ADD
    LDA MAP_OBJECTS.MAP_LOCATION							
    ADC #OFFSET.DOWN
    STA RMAP.LOOKUP
		 
    LDA MAP_OBJECTS.MAP_LOCATION+$1
    ADC #$00							;carry flag not cleared via CLC intentionally, it's part of 16-bit adding. 
    STA RMAP.LOOKUP+$1					;BORROWING SCREEN.TILE.HOPPER TO STORE THE TILE #S ADJACENT TO THE MOB
	
;======================================

;LOOKUP TILE_TYPE
;=======INLINE CODE FOR ADC.16========	
;RZONE.ARRAY(2) + RMAP.LOOKUP(2)
	
	CLC                          			;ALWAYS BEFORE ADD
	LDA #RZONE.ARRAY						;OP1
	ADC RMAP.LOOKUP							;OP2  
	STA RZONE.ARRAY.INDEX_ROW
				 
	LDA /RZONE.ARRAY						;OP1+$1
	ADC RMAP.LOOKUP+$1						;OP2+$2 carry flag not cleared via CLC intentionally, it's part of 16-bit adding. 
	STA RZONE.ARRAY.INDEX_ROW+$1
;======================================	

	LDY #$00
	LDA (RZONE.ARRAY.INDEX_ROW),Y			;LOOKUP TILE_TYPE FROM REGIONAL MAP ARRAY
	STA MOB.ADJACENT_TILES+$1				;BORROWING SCREEN.TILE.HOPPER TO STORE THE TILE TYPE ADJACENT TO THE MOB	

@MIDDLE

;MOB GROUP: DETERMINE WHETHER TO APPLY LAND OR SEA MOB COLLISION RULES	
	LDA MAP_OBJECTS.MOB+$2,X
	CMP #COLLISION_FLAG.MOB_SEA.START			;FIRST TILE IN SEA MOB RANGE. 
	BCS .COLLISION.LOOP.MOB_SEA


;APPLY MOB WALKING COLLISION RULES		
	LDY #$00
.LOOP.MOB_LAND
;IS MOB COLLISION OVERRIDE ON?
	LDA MOB.COLLISION_OVERRIDE
	CMP #$01
	BEQ .MOVE_PERMITTED

;BEGIN MAIN TESTS
	LDA MOB.ADJACENT_TILES,Y					;LOAD NEXT ADJACENT TILE TYPE
			
	CMP #COLLISION_FLAG.MOB_LAND.LT1			;ABSOLUTE OBSTACLE?
	BCC .MOVE_BLOCKED

	CMP #COLLISION_FLAG.MOB_LAND.EQ1			;QUICKSAND?
	BEQ .MOVE_BLOCKED
	
	CMP #COLLISION_FLAG.MOB_LAND.GRE			;WATER?	
	BCS .WATER_TEST1.PASS
	JMP .NEXT_COLLISION_TEST
.WATER_TEST1.PASS
	CMP #COLLISION_FLAG.MOB_LAND.LT2			;WATER?	
	BCC .MOVE_BLOCKED
	
.NEXT_COLLISION_TEST	
;NO MORE TESTS FOR NOW
;	JMP .MOVE_PERMITTED

@MIDDLE
	
.MOVE_PERMITTED
	LDA #$00		;PERMITTS MOVE BY RECORDING $00 
	STA MOB.MOVES.BLOCKED,Y
	JMP .COLLISION_EXIT_TEST
	
.MOVE_BLOCKED
	LDA #$01		;BLOCKS MOVE BY RECORDING $01
	STA MOB.MOVES.BLOCKED,Y

.COLLISION_EXIT_TEST
		LDA #$00
		STA TEMP16
	CPY #$03
	BEQ COLLISION_TESTS_COMPLETE
	INY
	JMP .LOOP.MOB_LAND
	
.COLLISION.LOOP.MOB_SEA	
	;***<INSERT RULES FOR SEA MOBS>***
	;COPY THE SECTION ABOVE FOR LAND MOBS AS A STARTING POINT
 
	;*****FALLS THROUGH

COLLISION_TESTS_COMPLETE




@END
@END

;====IDENTIFY.SCREEN_SECTION=====================
@START
	LDX SAVED.XREG.LOCAL

PASSIVE.MOB.CHECK
@START
;SKIP IDENTIFY SCREEN SECTION IF MOB IS PASSIVE	
	LDA MOB.FLAG4								;IS PASSIVE FLAG SET ON MOB RECORD?
	BEQ IDENTIFY.SCREEN_SECTION					;IF NO, PROCEED TO NEXT SECTION (FLAG4=0 IS PASSIVE)


;DECIDE IF PASSIVE MOB WILL PASS	
	JSR RANDOM.8	
	CMP #$19									;90% CHANCE OF PASS
	BCS .PASS									;IF MOB PASSES, 

	LDA #$00	
	STA MOB.MOVE.OPTIONS_PRIMARY
	LDA #$01
	STA MOB.MOVE.OPTIONS_PRIMARY+$1
	LDA #$02
	STA MOB.MOVE.OPTIONS_SECONDARY
	LDA #$03
	STA MOB.MOVE.OPTIONS_SECONDARY+$1
	JMP PASSIVE_MOB.ENTRANCE

.PASS
	LDA #$04
	STA MOB.MOVE.CURRENT 						;SET MOB'S FINAL MOVE DECISION TO PASS
	JMP MOB.MOVE.MAKE
@END

IDENTIFY.SCREEN_SECTION ;
@START
;Prioritize move options based on location of player
;
;
;=========WHAT IS A SCREEN SECTION?========
;It refers to the region of the screen the mob is located in. 
;Screen sections are identical to those used to select the algorithm
;type in the darkness_manager.ASM routines. See /my_code/documentation/diagram1.xls
;
;=========DETERMINE CANDIDATE MOVE=========
;QUICK REFERENCE (MOVE DIRECTIONAL CODES): #$00=north, $01=south, $02=east, $03=west
; Here is a summary of the preferred move rules. Multiple rules can apply to a single position, the way that is handled is different for less-aggressive mobs vs. aggressive mobs. 
; if mob.x >  player.x then mob.move.preferred  = $03  (West)
; if mob.x <  player.x then mob.move.preferred  = $02  (East)
; if mob.y >  player.y then mob.move.preferred  = $00  (north)
; if mob.y <  player.y then mob.move.preferred  = $01  (south)


;**OPT** Speed. It may be possible to assign a value to each 1/8 screen section, and tally up the values based on the X/Y GR/LT hits int the 
;calucalte tile location section above. As long each the numbers assigned yield a unique result for each screen section, then the portion of the code below because 8 LDA/CMPs to assign the section number. Even 
;thay mabe can be skipped if the tally of the values is used as the section number in the code further down.


TEST1	;===========DETECT SECTION 0/2/1=================
@START
	LDA MOB.POSITION.X_LT
	CMP #$00
	BEQ .TEST2_STEP
	LDA MOB.POSITION.Y_LT
	CMP #$00
	BEQ SUBTEST1.1
	JMP .SECTION0	
.TEST2_STEP
	JMP TEST2
.SECTION0	
	;SECTION 0
;	STA MOB.POSITION.SCREEN_SECTION
	LDX SAVED.XREG.LOCAL
	LDA MAP_OBJECTS.MOB+$1,X	
	CMP #MAP_OBJECTS.Y.FIRST_ROW								;IF MOB IS IN FIRST ROW, ONLY PROVIDE SOUTH AS A PRIMARY MOVE OPTION
	BEQ .FIRST_ROW

	LDA MAP_OBJECTS.MOB,X	
	CMP #MAP_OBJECTS.X.FIRST_COLUMN								;IF MOB IS IN FIRST COLUMN, ONLY PROVIDE EAST AS A PRIMARY MOVE OPTION
	BEQ .FIRST_COLUMN

;MOB NOT IN FIRST ROW OR LAST COLUMN
	LDA #$02	;EAST										
	STA MOB.MOVE.OPTIONS_PRIMARY
	LDA #$01	;SOUTH
	STA MOB.MOVE.OPTIONS_PRIMARY+$1
	JMP .CONTINUE
.FIRST_COLUMN	
	LDA #$02	;EAST										
	STA MOB.MOVE.OPTIONS_PRIMARY
	LDA #$02	;EAST										
	STA MOB.MOVE.OPTIONS_PRIMARY+$1
	JMP .CONTINUE	
.FIRST_ROW
	LDA #$01	;SOUTH								
	STA MOB.MOVE.OPTIONS_PRIMARY
	LDA #$01	;SOUTH
	STA MOB.MOVE.OPTIONS_PRIMARY+$1	
	;****FALLS THROUGH
	
.CONTINUE	
	LDA #$00	;NORTH										
	STA MOB.MOVE.OPTIONS_SECONDARY								;S0: SET SECONDARY MOVE OPTIONS	
	LDA #$03	;WEST
	STA MOB.MOVE.OPTIONS_SECONDARY+$1
	
	JMP SCREEN_SECTION.DETERMINED
SUBTEST1.1
	LDA MOB.POSITION.Y_GR
	CMP #$00
	BEQ SUBTEST1.2

.SECTION2	
	;SECTION 2
;	LDA #$02	;EAST
;	STA MOB.POSITION.SCREEN_SECTION	

			
	LDX SAVED.XREG.LOCAL
	LDA MAP_OBJECTS.MOB+$1,X	
	CMP #MAP_OBJECTS.Y.LAST_ROW									;IF MOB IS IN LAST ROW, ONLY PROVIDE NORTH AS A PRIMARY MOVE OPTION
	BEQ .LAST_ROW

	LDA MAP_OBJECTS.MOB,X	
	CMP #MAP_OBJECTS.X.FIRST_COLUMN								;IF MOB IS IN FIRST COLUMN, ONLY PROVIDE EAST AS A PRIMARY MOVE OPTION
	BEQ .FIRST_COLUMN

;MOB NOT IN LAST COLUMN OR LAST ROW
	LDA #$02	;EAST										
	STA MOB.MOVE.OPTIONS_PRIMARY
	LDA #$00	;NORTH
	STA MOB.MOVE.OPTIONS_PRIMARY+$1
	JMP .CONTINUE
.FIRST_COLUMN	
	LDA #$02	;EAST										
	STA MOB.MOVE.OPTIONS_PRIMARY
	LDA #$02	;EAST										
	STA MOB.MOVE.OPTIONS_PRIMARY+$1
	JMP .CONTINUE	
.LAST_ROW
	LDA #$00	;NORTH								
	STA MOB.MOVE.OPTIONS_PRIMARY
	LDA #$00	;NORTH
	STA MOB.MOVE.OPTIONS_PRIMARY+$1
	;****FALLS THROUGH
	
.CONTINUE
	LDA #$01	;SOUTH										
	STA MOB.MOVE.OPTIONS_SECONDARY								;S2: SET SECONDARY MOVE OPTIONS
	LDA #$03	;WEST
	STA MOB.MOVE.OPTIONS_SECONDARY+$1
	JMP SCREEN_SECTION.DETERMINED
SUBTEST1.2
	;X-AXIS < PLAYER,Y-AXIS = TO PLAYER (IMPUTED)

	;SECTION 1													
;	LDA #$01
;	STA MOB.POSITION.SCREEN_SECTION
	
	LDA #$02	;EAST										
	STA MOB.MOVE.OPTIONS_PRIMARY								;S1: SET PRIMARY MOVE OPTIONS
	LDA #$02	;EAST
	STA MOB.MOVE.OPTIONS_PRIMARY+$1
	LDA #$00	;NORTH										
	STA MOB.MOVE.OPTIONS_SECONDARY								;S1: SET SECONDARY MOVE OPTIONS		
	LDA #$01	;SOUTH
	STA MOB.MOVE.OPTIONS_SECONDARY+$1
	
	JMP SCREEN_SECTION.DETERMINED

TEST3_STEP
	JMP TEST3
@END
	
TEST2	;===========DETECT SECTION 5/7/6=================
@START
	LDA MOB.POSITION.X_GR
	CMP #$00
	BEQ TEST3_STEP
	LDA MOB.POSITION.Y_LT
	CMP #$00
	BEQ SUBTEST2.1
	
.SECTION5	
	;SECTION 5
;	LDA #$05
;	STA MOB.POSITION.SCREEN_SECTION

	LDX SAVED.XREG.LOCAL
	LDA MAP_OBJECTS.MOB+$1,X	
	CMP #MAP_OBJECTS.Y.FIRST_ROW								;IF MOB IS IN FIRST ROW, ONLY PROVIDE SOUTH AS A PRIMARY MOVE OPTION
	BEQ .FIRST_ROW

	LDA MAP_OBJECTS.MOB,X	
	CMP #MAP_OBJECTS.X.LAST_COLUMN								;IF MOB IS IN LAST COLUMN, ONLY PROVIDE WEST AS A PRIMARY MOVE OPTION
	BEQ .LAST_COLUMN

;MOB NOT IN FIRST ROW OR LAST COLUMN
	LDA #$03	;WEST										
	STA MOB.MOVE.OPTIONS_PRIMARY
	LDA #$01	;SOUTH
	STA MOB.MOVE.OPTIONS_PRIMARY+$1
	JMP .CONTINUE
.LAST_COLUMN	
	LDA #$03	;WEST										
	STA MOB.MOVE.OPTIONS_PRIMARY
	LDA #$03	;WEST										
	STA MOB.MOVE.OPTIONS_PRIMARY+$1
	JMP .CONTINUE	
.FIRST_ROW
	LDA #$01	;SOUTH								
	STA MOB.MOVE.OPTIONS_PRIMARY
	LDA #$01	;SOUTH
	STA MOB.MOVE.OPTIONS_PRIMARY+$1
	;****FALLS THROUGH
	
.CONTINUE	
	LDA #$00	;NORTH										
	STA MOB.MOVE.OPTIONS_SECONDARY								;S5: SET SECONDARY MOVE OPTIONS
	LDA #$02	;EAST
	STA MOB.MOVE.OPTIONS_SECONDARY+$1	
	JMP SCREEN_SECTION.DETERMINED
SUBTEST2.1
	LDA MOB.POSITION.Y_GR
	CMP #$00
	BEQ SUBTEST2.2

.SECTION7	
	;SECTION 7	
;	LDA #$07
;	STA MOB.POSITION.SCREEN_SECTION

	LDX SAVED.XREG.LOCAL
	LDA MAP_OBJECTS.MOB+$1,X	
	CMP #MAP_OBJECTS.Y.LAST_ROW									;IF MOB IS IN LAST ROW, ONLY PROVIDE NORTH AS A PRIMARY MOVE OPTION
	BEQ .LAST_ROW

	LDA MAP_OBJECTS.MOB,X	
	CMP #MAP_OBJECTS.X.LAST_COLUMN								;IF MOB IS IN LAST COLUMN, ONLY PROVIDE WEST AS A PRIMARY MOVE OPTION
	BEQ .LAST_COLUMN

;MOB NOT IN LAST COLUMN OR LAST ROW
	LDA #$03	;WEST										
	STA MOB.MOVE.OPTIONS_PRIMARY
	LDA #$00	;NORTH
	STA MOB.MOVE.OPTIONS_PRIMARY+$1
	JMP .CONTINUE
.LAST_COLUMN	
	LDA #$03	;WEST										
	STA MOB.MOVE.OPTIONS_PRIMARY
	LDA #$03	;WEST										
	STA MOB.MOVE.OPTIONS_PRIMARY+$1
	JMP .CONTINUE	
.LAST_ROW
	LDA #$00	;NORTH								
	STA MOB.MOVE.OPTIONS_PRIMARY
	LDA #$00	;NORTH
	STA MOB.MOVE.OPTIONS_PRIMARY+$1
	;****FALLS THROUGH
	
.CONTINUE
	LDA #$01	;SOUTH									
	STA MOB.MOVE.OPTIONS_SECONDARY							;S7: SET SECONDARY MOVE OPTIONS
	LDA #$02	;EAST
	STA MOB.MOVE.OPTIONS_SECONDARY+$1
	JMP SCREEN_SECTION.DETERMINED
SUBTEST2.2
	;X-AXIS > PLAYER, Y-AXIS = TO PLAYER (IMPUTED)
.SECTION6
	;SECTION 6
;	LDA #$06
;	STA MOB.POSITION.SCREEN_SECTION
;	LDA #$03	;WEST
;	STA MOB.MOVE.CANDIDATE
	LDA #$03	;WEST									
	STA MOB.MOVE.OPTIONS_PRIMARY
	LDA #$03	;WEST
	STA MOB.MOVE.OPTIONS_PRIMARY+$1
	LDA #$00	;NORTH										
	STA MOB.MOVE.OPTIONS_SECONDARY							
	LDA #$01	;SOUTH
	STA MOB.MOVE.OPTIONS_SECONDARY+$1

	JMP SCREEN_SECTION.DETERMINED
@END

TEST3	;===========DETECT SECTION 4/3===================
@START
	;X-AXIS = TO PLAYER (IMPUTED)
	LDA MOB.POSITION.Y_GR
	CMP #$00
	BEQ SUBTEST3.1
.SECTION4	
	;SECTION 4
;	LDA #$00	;NORTH
;	STA MOB.MOVE.CANDIDATE
;	LDA #$04
;	STA MOB.POSITION.SCREEN_SECTION
	LDA #$00	;NORTH									
	STA MOB.MOVE.OPTIONS_PRIMARY				;S4: SET SECONDARY MOVE OPTIONS
	LDA #$00	;NORTH
	STA MOB.MOVE.OPTIONS_PRIMARY+$1
	LDA #$02	;EAST										
	STA MOB.MOVE.OPTIONS_SECONDARY				;S4: SET SECONDARY MOVE OPTIONS						
	LDA #$03	;WEST
	STA MOB.MOVE.OPTIONS_SECONDARY+$1
				
	JMP SCREEN_SECTION.DETERMINED
SUBTEST3.1
	;X-AXIS = TO PLAYER (IMPUTED), Y-AXIS < PLAYER (IMPUTED)
.SECTION3	
	;SECTION 3
;	LDA #$03
;	STA MOB.POSITION.SCREEN_SECTION
;	LDA #$01	;SOUTH
;	STA MOB.MOVE.CANDIDATE
	LDA #$01	;SOUTH								
	STA MOB.MOVE.OPTIONS_PRIMARY				;S3: SET PRIMARY MOVE OPTIONS
	LDA #$01	;SOUTH
	STA MOB.MOVE.OPTIONS_PRIMARY+$1
	LDA #$02	;EAST										
	STA MOB.MOVE.OPTIONS_SECONDARY				;S3: SET SECONDARY MOVE OPTIONS			
	LDA #$03	;WEST
	STA MOB.MOVE.OPTIONS_SECONDARY+$1
	JMP SCREEN_SECTION.DETERMINED

SCREEN_SECTION.DETERMINED
@END
@END
@END

CHOOSE.MOB.MOVE ;
@START
	LDA MOB.FLAG0								;FLAG0: OFF=LESS AGGRESSIVE, ON=AGGRESSIVE
	CMP #$01
	BEQ MOB.TYPE_01
	JMP MOB.TYPE_00
	
;MOB-MOVEMENT TYPES
;less-aggressive mobs 
;		randomly pick one of moves stored in MOB.MOVE.OPTIONS_PRIMARY (2)
;		if that move is blocked, then it randomly chooses one of the open paths, or pass
;aggressive (bee-line) mobs
;		attempts moves in order (primary, primary+1,) until an unblocked move is found
;		randomly chooses between (secondary, secondary+1) 
;
;SS mobs
;		same as aggressive but they are allowed to move (and thus pursue) even when not
;		on the view screen
;
;Double Moves
;		Mob gets 2 moves to every mob turn. If player has a transport giving him/her 2 moves,
;		then on players turns, player moves two tile, and on mobs turn, mob moves two tiles. 



MOB.TYPE_01 ;=======AGGRESSIVE (BEE-LINE) MOBS======
@START
			;**OPT** Speed. Create a routine called by the game loop to generate random numbers (1 per game loop cycle) and store them in an array 1 page long, and increment a random number pointer.
			;			routines could them use the random number pointer to load a random # from the holding array, which is a lot faster than running the RANDOM.8 routine. 
;RANDOMIZE PRIMARY MOVES
	JSR RANDOM.8
	CMP #$80
	BCS .SCENARIO1
;SCENARIO0
	LDA MOB.MOVE.OPTIONS_PRIMARY
	STA TEMP
	LDA MOB.MOVE.OPTIONS_PRIMARY+$1
	STA MOB.MOVE.OPTIONS_PRIMARY
	LDA TEMP
	STA MOB.MOVE.OPTIONS_PRIMARY+$1
	JMP .EVALUATE_PRIMARY
.SCENARIO1
	;LEAVE PRIMARY MOVES IN DEFAULT ORDER

.EVALUATE_PRIMARY
;CHOOSE WHICHEVER PRIMARY MOVE IS AN OPEN PATH	
	LDY MOB.MOVE.OPTIONS_PRIMARY
	LDA MOB.MOVES.BLOCKED,Y
	CMP #$00
	BEQ .PRIMARY0
	LDY MOB.MOVE.OPTIONS_PRIMARY+$1
	LDA MOB.MOVES.BLOCKED,Y
	CMP #$00
	BNE .EVALUATE_SECONDARY
;.PRIMARY1
	LDA MOB.MOVE.OPTIONS_PRIMARY+$1
	STA MOB.MOVE.CURRENT
	JMP MOB.MOVE.MAKE
.PRIMARY0
	LDA MOB.MOVE.OPTIONS_PRIMARY
	STA MOB.MOVE.CURRENT
	JMP MOB.MOVE.MAKE

.EVALUATE_SECONDARY
;RANDOMIZE SECONDARY MOVES
	JSR RANDOM.8
	CMP #$80
	BCS .SCENARIO1_SECONDARY
;SCENARIO0
	LDA MOB.MOVE.OPTIONS_SECONDARY
	STA TEMP
	LDA MOB.MOVE.OPTIONS_SECONDARY+$1
	STA MOB.MOVE.OPTIONS_SECONDARY
	LDA TEMP
	STA MOB.MOVE.OPTIONS_SECONDARY+$1
	JMP .EVALUATE_SECONDARY.START
.SCENARIO1_SECONDARY
	;LEAVE PRIMARY MOVES IN DEFAULT ORDER

.EVALUATE_SECONDARY.START
;CHOOSE WHICHEVER PRIMARY MOVE IS AN OPEN PATH	
	LDY MOB.MOVE.OPTIONS_SECONDARY
	LDA MOB.MOVES.BLOCKED,Y
	CMP #$00
	BEQ .SECONDARY0
	LDY MOB.MOVE.OPTIONS_SECONDARY+$1
	LDA MOB.MOVES.BLOCKED,Y
	CMP #$00
	BNE .PASS
;.SECONDARY1
	LDA MOB.MOVE.OPTIONS_SECONDARY+$1
	STA MOB.MOVE.CURRENT
	JMP MOB.MOVE.MAKE
.SECONDARY0
	LDA MOB.MOVE.OPTIONS_SECONDARY
	STA MOB.MOVE.CURRENT
	JMP MOB.MOVE.MAKE	
.PASS
;THIS SHOULD NEVER HAPPEN. IT'S LIKE THE EMERGENCY BRAKE. NEVER USE. 
	LDA #$04
	STA MOB.MOVE.CURRENT
	JMP MOB.MOVE.MAKE
	
@END
	
MOB.TYPE_00 ;=======LESS-AGGRESSIVE MOBS============
@START
;CHOOSE CANDIDATE MOVE
	JSR RANDOM.8
	CMP #$80
	BCS .OPTION1.CANDIDATE
;OPTION0 PREFERRED
	LDA MOB.MOVE.OPTIONS_PRIMARY
	STA MOB.MOVE.CANDIDATE
	JMP .CANDIDATE_MOVE.DETERMINED
.OPTION1.CANDIDATE
	LDA MOB.MOVE.OPTIONS_PRIMARY+$1
	STA MOB.MOVE.CANDIDATE
	
.CANDIDATE_MOVE.DETERMINED
;RE-INIT VARIABLES
	; LDA #$FF
	; LDA MOB.MOVE.OPTIONS_PRIMARY
	; LDA MOB.MOVE.OPTIONS_PRIMARY+$1
	; LDA MOB.MOVE.OPTIONS_SECONDARY
	; LDA MOB.MOVE.OPTIONS_SECONDARY+$1
	
;IS CANDIDATE MOVE BLOCKED?
	LDY MOB.MOVE.CANDIDATE
	LDA MOB.MOVES.BLOCKED,Y
	CMP #$01
	BEQ .MOVE.CHOOSE_ALTERNATE

.MOVE.NOT_BLOCKED	
	LDA MOB.MOVE.CANDIDATE
	STA MOB.MOVE.CURRENT
	JMP MOB.MOVE.MAKE

.MOVE.CHOOSE_ALTERNATE	
	STX SAVED.XREG.LOCAL
	
	LDA #$04											;ADD PASS AS A MOVE OPTION
	STA MOB.MOVE.OPTIONS_SECONDARY+$2

	;FALLS THROUGH
	
@END

;===================PASSIVE MOB MOVEMENT=============
@START
;****BUG: I'M NOT SURE THE PASS MOVE OPTION IS HOOKED UP. THE ROUTINE BELOW ENDS WITH SECONDARY+$1

	;**I THINK THAT THE CODE IN PASSIVE_MOB.ENTRANCE IN SHARED BY
	;MOB.TYPE_00 AND MOBS THAT HAVE A POSSIVE FLAG SET (CROCODILES?),
	;WHICH I THINK IS DETECTED FURTHER UP IN THE CODE AND JUMP IN HERE. 
	
	
PASSIVE_MOB.ENTRANCE
;DETERMINE OPEN PATHS AND STORE IN ARRAY

	LDX #$00
	LDY #$00
	
	LDA MOB.MOVE.OPTIONS_PRIMARY					
	TAX	
	LDA MOB.MOVES.BLOCKED,X								;EVALUATE THE PRIMARY AND SECONDARY MOVE OPTOINS TO SEE IF THEY ARE BLOCKED. 
	CMP #$01
	BEQ .OPTION0.BLOCKED								;IF YES, DON'T RECORD AS AN OPEN PATH
	LDA MOB.MOVE.OPTIONS_PRIMARY						
	STA MOB.MOVE.OPEN_PATHS,Y							;IF NO, RECORD AS AN OPEN PATH
	INY													;INCREMENT TALLY OF OPEN PATHS, WHICH WILL BE USED TO BRANCH INTO A RANDOM NUMBER ROUTINE WITH THE NUMBER OF CHOICES EQUAL TO THE NUMBER OF OPEN PATHS 
.OPTION0.BLOCKED
	LDA MOB.MOVE.OPTIONS_PRIMARY+$1						;REPEAT ABOVE CONCEPT, UNTIL ALL MOVE OPTIONS ARE EVALUATED
	TAX
	LDA MOB.MOVES.BLOCKED,X
	CMP #$01
	BEQ .OPTION1.BLOCKED
	LDA MOB.MOVE.OPTIONS_PRIMARY+$1
	STA MOB.MOVE.OPEN_PATHS,Y
	INY	
.OPTION1.BLOCKED
	LDA MOB.MOVE.OPTIONS_SECONDARY
	TAX
	LDA MOB.MOVES.BLOCKED,X
	CMP #$01
	BEQ .OPTION2.BLOCKED
	LDA MOB.MOVE.OPTIONS_SECONDARY
	STA MOB.MOVE.OPEN_PATHS,Y
	INY	
.OPTION2.BLOCKED
	LDA MOB.MOVE.OPTIONS_SECONDARY+$1
	TAX
	LDA MOB.MOVES.BLOCKED,X
	CMP #$01
	BEQ .OPTION3.BLOCKED
	LDA MOB.MOVE.OPTIONS_SECONDARY+$1
	STA MOB.MOVE.OPEN_PATHS,Y
	INY	
.OPTION3.BLOCKED
	LDA #$04
	STA MOB.MOVE.OPEN_PATHS,Y
	INY
	;Y-REG HOLDS A TALLY, THE NUMBER OF OPEN PATHS

;RANDOMLY CHOOSE AN OPEN PATH AS THE FINAL MOVE CHOICE	
	LDX #$00
	
	CPY #$01
	BEQ .PATHS_1
	CPY #$02
	BEQ .PATHS_2
	CPY #$03
	BEQ .PATHS_3
	CPY #$04
	BEQ .PATHS_4
	CPY #$05
	BEQ .PATHS_5
;			JMP .PATHS_4

.PATHS_ERROR
;UNEXPECTED NUMBER OF OPEN PATHS REPORTED IN .MOB.MOVE.CHOOSE_ALTERNATE	
	BRK
	
.PATHS_1
	LDA MOB.MOVE.OPEN_PATHS,X
	STA MOB.MOVE.CURRENT
	JMP MOB.MOVE.MAKE
.PATHS_2
	JSR RANDOM.8
	CMP #$80
	BCS .P2.OPTION1.CANDIDATE
;P2.OPTION0
	LDA MOB.MOVE.OPEN_PATHS
	STA MOB.MOVE.CURRENT
	JMP MOB.MOVE.MAKE
.P2.OPTION1.CANDIDATE
	LDA MOB.MOVE.OPEN_PATHS+$1
	STA MOB.MOVE.CURRENT
	JMP MOB.MOVE.MAKE

.PATHS_3 ;SPLIT POINTS $55, $AA
	JSR RANDOM.8
	CMP #$55
	BCS .PATHS_3.NEXT_TEST
;P3.OPTION0
	LDA MOB.MOVE.OPEN_PATHS
	STA MOB.MOVE.CURRENT
	JMP MOB.MOVE.MAKE
.PATHS_3.NEXT_TEST
	CMP #$AA
	BCC .P3.OPTION2.CANDIDATE
;P3.OPTION1
	LDA MOB.MOVE.OPEN_PATHS+$1
	STA MOB.MOVE.CURRENT
	JMP MOB.MOVE.MAKE
.P3.OPTION2.CANDIDATE
	LDA MOB.MOVE.OPEN_PATHS+$2
	STA MOB.MOVE.CURRENT
	JMP MOB.MOVE.MAKE

.PATHS_4 ;SPLIT POINTS $3F, $74, $BF
	JSR RANDOM.8
	CMP #$3F
	BCS .PATHS_4.NEXT_TEST1
;P4.OPTION0
	LDA MOB.MOVE.OPEN_PATHS
	STA MOB.MOVE.CURRENT
	JMP MOB.MOVE.MAKE
.PATHS_4.NEXT_TEST1
	CMP #$BF
	BCS .P4.OPTION3.CANDIDATE
;PATHS_4.NEXT_TEST2 
	CMP #$74
	BCS .P4.OPTION2.CANDIDATE
;P4.OPTION1	
	LDA MOB.MOVE.OPEN_PATHS+$1
	STA MOB.MOVE.CURRENT
	JMP MOB.MOVE.MAKE
.P4.OPTION2.CANDIDATE
	LDA MOB.MOVE.OPEN_PATHS+$2
	STA MOB.MOVE.CURRENT
	JMP MOB.MOVE.MAKE
.P4.OPTION3.CANDIDATE
	LDA MOB.MOVE.OPEN_PATHS+$3
	STA MOB.MOVE.CURRENT
	JMP MOB.MOVE.MAKE
	
	
.PATHS_5 ;SPLIT POINTS $33, $66, $99, $CC,
	JSR RANDOM.8
	CMP #$33
	BCS .PATHS_5.NEXT_TEST1
;P5.OPTION0
	LDA MOB.MOVE.OPEN_PATHS
	STA MOB.MOVE.CURRENT
	JMP MOB.MOVE.MAKE
.PATHS_5.NEXT_TEST1
	CMP #$CC
	BCS .P5.OPTION3.CANDIDATE
;PATHS_5.NEXT_TEST2 
	CMP #$99
	BCS .P5.OPTION2.CANDIDATE
;PATHS_5.NEXT_TEST3
	CMP #$66
	BCS .P5.OPTION4.CANDIDATE		
;P5.OPTION1	
	LDA MOB.MOVE.OPEN_PATHS+$1
	STA MOB.MOVE.CURRENT
	JMP MOB.MOVE.MAKE
.P5.OPTION2.CANDIDATE
	LDA MOB.MOVE.OPEN_PATHS+$2
	STA MOB.MOVE.CURRENT
	JMP MOB.MOVE.MAKE
.P5.OPTION3.CANDIDATE
	LDA MOB.MOVE.OPEN_PATHS+$3
	STA MOB.MOVE.CURRENT
	JMP MOB.MOVE.MAKE
.P5.OPTION4.CANDIDATE
	LDA MOB.MOVE.OPEN_PATHS+$4
	STA MOB.MOVE.CURRENT
;	JMP MOB.MOVE.MAKE
	
	;***FALLS THROUGH TO MOB.MOVE.MAKE
@END
@END
	
MOB.MOVE.MAKE ;
@START	
;PARAMETERS: ACC (MOB.MOVE.CURRENT), SAVED.XREG.LOCAL (MOB RECORD INDEX), MAP_OBJECTS.TILE_LOCATION
;QUICK REFERENCE: #$00=north, $01=south, $02=east, $03=west, $04 = NO MOVE


;=====================SUBROUTINE DOCUMENTATION====================================
;This subroutine is passed the move code for the move the mob made via the ACC.
;Unless the mob is an offscreen SS, or unless the tile the mob is located in
;(prior to making its move) is hidden, the mob's tile is erased. 
;
;Then .MOB.MOVE.IMPLIMENT branches to the mob move routine associated with the move code
;in the ACC a the start of this routine. 
;
;The movement routines adjust the x,y position of the mob and also
;make a final decision on whether the mob's tile should be drawn. Things
;considered include whether the mob's move resulted in an offscreen SS moving onto the view screen
;or any kind of mob moving off the view screen. 
;
;If the players move resulted in the mob being located in the 1st column or row
;of the view screen, a move for the mob isn't permitted this turn to avoid
;the appearance that the mob appeared out of nowhere. This is handled in .NOT_INITIAL_DRAW (MOB.MOVEMENT)
;
;---Double Movers----
;In general mob's with the double mover flag set are given a 2nd move
;by MOB.MOVE.COMPLETE jumping back to MOB.MOVEMENT if the mob has the
;double mover flag set. The number of moves is tracked in MOB.MOVE.COUNTER.
;There is also an erase counter (MOB.MOVE.ERASE_COUNTER) so that the 
;double mover isn't erased more than once (I think).
;
;There was some kind of issue that occured with double movers hitting 
;slow progress. I don't recall what the issue was, but this fix has something
;to do with the code in MOB.MOVE.PASS. That section didn't exist unil the issue 
;occured (pass was handled differently, probably just a JMP to MOB.MOVE.COMPLETE)
;
;The double mover implementation is complicated, there were a variety of
;corner cases that came up, and it's pretty much shoe horned into the 
;code. There could be things I didn't remember when writing this. 
;=================================================================================



;MOB.MOVE.CURRENT IS IN ACC AT THIS POINT
	STA MOB.MOVE.LAST
	LDX SAVED.XREG.LOCAL
	LDY MAP_OBJECTS.TILE_LOCATION
;====BRANCH TO CORRECT MOVE ROUTINE=======
						

				
;IF MOB IS AN OFFSCREEN SS TYPE SKIP ERASE TILE AND DARKNESS CHECK
	LDA MOB.SCREEN_STATUS.SS
	CMP #$01 									;IS MOB AN OFFSCREEN SS?
	BEQ .MOB.MOVE.IMPLIMENT_STEP				;IF YES, FIND THE MAP LOCATION FOR USE WITH COLLISION CHECKS ONLY
												;IF NO, FIND THE SCREEN LOCATION OF THE MOB
									
	LDA MOB.MOVE.CURRENT	
	CMP #$04					
	BNE .MOB.MOVE.ERASETILE
;	LDY #$00								;RESET SCREEN TILE INDEX SO THAT COMBAT PROXIMITY CHECK FAILS, SINCE MOB IS OFFSCREEN
	JMP MOB.MOVE.PASS						;IF NO MOB MOVE, NEXT TILE OR EXIT, UNLESS DOUBLE MOVER. 
												
.MOB.MOVE.IMPLIMENT_STEP
	JMP .MOB.MOVE.IMPLIMENT
	
.MOB.MOVE.MAKE.ONSCREEN ;
;TESTHOOK2
;(HARD CODE MOB MOB, OVERRIDE COMPUTER SELECTION)
;		LDA #$02
;		STA MOB.MOVE.CURRENT

.MOB.MOVE.ERASETILE 
@START
	LDA MOB.FLAG2
	CMP #$01									;IS DOUBLE MOVER FLAG SET? 
	BNE .CONTINUE								;IF NO, CONTINUE WITH ERASE TILE
	LDA MOB.MOVE.ERASE_COUNTER				
	CMP #$01									;WAS TILE ALREADY ERASED THIS TURN? (I.E. ON THE MOB'S 1ST MOVE)
	BCS .MOB.MOVE.IMPLIMENT_STEP				;IF YES, SKIP ERASE TILE
												;IF NO, CONTINUE WITH ERASE TILE
.CONTINUE	
	LDA MOB.FLAG3								;MULT-TILE MOB?
	CMP #$01
	BEQ .MOB.MOVE.ERASETILE.MT					;IF YES, USE THE MULTI-TILE ERASE ROUTINE
	
;IS TILE HIDDEN (DARKNESS)?	
	LDA SCREEN.DARK.DATA,Y			
	CMP #$01
	BEQ .MOB.PREMOVE_LOCATION.NOTVISIBLE	;IF YES, DON'T DRAW TILE
		
	LDA SCREEN.TILE.DATA,Y
	STA SAVED_TILE_TYPE
		;**OPT** Memory. Speed. I think the above two lines can be removed. SAVE_TILE_TYPE is only used when the tile type you want drawn is not stored in SCREEN.TILE.DATA, which in this case it is since we are "erasing".
		LDA #$08							;SET TRACE
		STA CALLED_BY
	JSR DRAW.TILE.SINGLE					;REPLACE MOB TILE WITH UNDERLYING MAP TILE
		LDA #$00							;RESET TRACE
		STA CALLED_BY
		
	LDA #$01
	STA MOB.MOVE.ERASE_COUNTER				;RECORD THAT TILE WAS ERASED THIS TURN SO IT'S NOT ERASED ON MOB'S SECOND MOVE, IF ITS A DOUBEL MOVER
	
.MOB.PREMOVE_LOCATION.NOTVISIBLE	
	LDA #$FF
	STA SCREEN.MO_MOB.DATA,Y				;REMOVE MOB FROM MO SCREEN ARRAY
		;***OPT** Memory. Speed. it may be possible to remove .MOB.PREMOVE_LOCATION.NOTVISIBLE. SCREEN.MO_MOB.DATA is init to $FF at start of MO.DRAW. The location of the mob is recorded after the mob moves. Thus, if the pre-move location isn't visible, I'm not sure why we'd need to record that in the array. The erase routine is needed though as the graphic would have scrolled from the mob location prior to the player move. 
	
	JMP .MOB.MOVE.IMPLIMENT
@END	
.MOB.MOVE.ERASETILE.MT
@START	
	LDA MAP_OBJECTS.MOB,X					;LOAD X-AXIS (COLUMN) OF TILE0 OF MT MOB
	STA MOB.MT.POSITION.X					;SAVE FOR FUTURE USE, WHEN X/Y-REG ARE BOTH BUSY
	
	STX SAVED.XREG.LOCAL					;CONTAINS MOB RECORD INDEX
	LDX #$00	

.MT.ERASELOOP	
	LDY MOB.MT.TILE_LOCATIONS,X				;LOAD NEXT TILE LOCATION



;IS TILE ON THE VIEW SCREEN
;(normally this condition indicates an error, but with MT Mobs, it can happen legitimately if the mob is half on/off the screen. In that case, it's legit but the correct process is to not draw the offscreen tiles)	
	;IF TILE IS OFFSCREEN TO NORTH OR SOUTH, THE TILE # WILL EXCEED THE LAST ARRAY ELEMENT
	LDA #SCREEN.ARRAY.LAST_ELEMENT
	CMP MOB.MT.TILE_LOCATIONS,X	
	BCS .CHECK.EAST_WEST
	JMP .TILE.OFFSCREEN
.CHECK.EAST_WEST
	;OFFSCREEN EAST/WEST REQUIRES CHECKING THE COLUMN 
	LDA MOB.MT.POSITION.X					;LOAD X-AXIS (COLUMN) OF TILE0 OF MT MOB. LOADING FROM VARIABLE BECAUSE X/Y-REG ARE BOTH IN USE	

	CPX #$00								;IS TILE 0 THE CURRENT TILE??
	BEQ .TILE0.OFFSCREEN_CHECK
	CPX #$01								;IS TILE 1 THE CURRENT TILE??
	BEQ .TILE1.OFFSCREEN_CHECK
	CPX #$02								;IS TILE 2 THE CURRENT TILE??
	BEQ .TILE2.OFFSCREEN_CHECK
	CPX #$03								;IS TILE 3 THE CURRENT TILE??
	BEQ .TILE3.OFFSCREEN_CHECK

.TILE0.OFFSCREEN_CHECK
	CMP MAP_OBJECTS.X_APPROACH+$1
	BEQ .TILE.OFFSCREEN
	JMP .TILE_ONSCREEN
	
.TILE1.OFFSCREEN_CHECK
	CMP #MAP_OBJECTS.X.LAST_COLUMN
	BEQ .TILE.OFFSCREEN
	JMP .TILE_ONSCREEN

.TILE2.OFFSCREEN_CHECK
	CMP MAP_OBJECTS.X_APPROACH+$1
	BEQ .TILE.OFFSCREEN
	JMP .TILE_ONSCREEN

.TILE3.OFFSCREEN_CHECK
	CMP #MAP_OBJECTS.X.LAST_COLUMN
	BEQ .TILE.OFFSCREEN
	JMP .TILE_ONSCREEN	
	
	
.TILE_ONSCREEN
;IS TILE HIDDEN (DARKNESS)?	
	LDA SCREEN.DARK.DATA,Y			
	CMP #$01
	BEQ .MOB.PREMOVE_LOCATION.NOTVISIBLE2	;IF YES, DON'T DRAW TILE

		LDA #$09							;SET TRACE
		STA CALLED_BY
	JSR DRAW.TILE.SINGLE					;REPLACE MOB TILE WITH UNDERLYING MAP TILE
		LDA #$00							;SET TRACE
		STA CALLED_BY
		
.MOB.PREMOVE_LOCATION.NOTVISIBLE2	
	LDA #$FF
	STA SCREEN.MO_MOB.DATA,Y				;REMOVE MOB FROM MO SCREEN ARRAY
		;***OPT** Memory. Speed. it may be possible to remove .MOB.PREMOVE_LOCATION.NOTVISIBLE. SCREEN.MO_MOB.DATA is init to $FF at start of MO.DRAW. The location of the mob is recorded after the mob moves. Thus, if the pre-move location isn't visible, I'm not sure why we'd need to record that in the array. The erase routine is needed though as the graphic would have scrolled from the mob location prior to the player move. 

.TILE.OFFSCREEN
.EXIT_TEST
	INX
	CPX #$04
	BNE .MT.ERASELOOP
	
	LDA #$01
	STA MOB.MOVE.ERASE_COUNTER				;RECORD THAT TILE WAS ERASED THIS TURN SO IT'S NOT ERASED ON MOB'S SECOND MOVE, IF ITS A DOUBEL MOVER
	
	LDY MOB.MT.TILE_LOCATIONS				;RESTORE TILE0 (UPPER LEFT) TO THE Y-REG
	LDX SAVED.XREG.LOCAL					;CONTAINS MOB RECORD INDEX

	;****FALLS THROUGH***
	
@END
@END
	
.MOB.MOVE.IMPLIMENT
@START				
	LDA MOB.MOVE.CURRENT					;#$00=north, $01=south, $02=east, $03=west,  $04 = NO MOVE

	CMP #$00
	BEQ	MOB.MOVE.NORTH
	CMP #$01
	BEQ MOB.MOVE.SOUTH
	CMP #$02
	BEQ	.MOB.MOVE.EAST_STEP
	CMP #$03
	BEQ .MOB.MOVE.WEST_STEP
	CMP #$04
	BEQ MOB.MOVE.PASS
	JMP ERROR1

.MOB.MOVE.COMPLETE_STEP

	JMP MOB.MOVE.COMPLETE

.MOB.MOVE.EAST_STEP
	JMP MOB.MOVE.EAST
 
.MOB.MOVE.WEST_STEP
	JMP MOB.MOVE.WEST

MOB.MOVE.COMPLETE_STEP
	JMP MOB.MOVE.COMPLETE
@END
	
MOB.MOVE.PASS		
@START
;CHECK TO SEE IF TILE SHOULD BE DRAWN (NORMALLY IT ISN'T ON A PASS)
;					NOTE: THIS BECAUSE THE MOB'S POSITION HASN'T CHANGED. HOWEVER, IF IT'S A DOUBLE MOVER'S SECOND MOVE WHEN THE SLOW PROGRESS/PASS OCCURS, IT'S POSITION HAS CHANGED. 	
;

	LDA MOB.FLAG2
	CMP #$01									;IS DOUBLE MOVER FLAG SET? 
	BNE MOB.MOVE.COMPLETE_STEP					;IF NO, COMPLETE MOVE

	LDA MOB.MOVE.SLOW.PROGRESS 
	CMP #$01									;IS, SLOW PROGRESS FLAG ON ($01)?
	BNE MOB.MOVE.COMPLETE_STEP					;IF NO, COMPLETE MOVE
	
	JMP MOB.DRAWTILE_STEP						;IF YES, DRAW MOB TILE
@END
	
MOB.MOVE.NORTH
@START
;UPDATE MOB X/Y	
	DEC MAP_OBJECTS.MOB+$1,X				;-1 TO Y POSITION (MOVED MOB X,Y NORTH)

;DID SS MOB MOVE ONTO VIEW SCREEN?	
	LDA MAP_OBJECTS.MOB+$1,X				
	CMP #MAP_OBJECTS.Y.LAST_ROW				;IS MOB'S Y AXIS == LAST ROW, NET OF ITS MOVE NORTH?
	BNE .CHECK_OFFSCREEN					;IF NO, PROCEED NORMALLY

	;MAKE SURE IT'S X-AXIS IS ON THE SCREEN
	LDA MAP_OBJECTS.MOB,X
	CMP #MAP_OBJECTS.X_FLAG.LOWER			;IS OBJECT BEYOND LEFT EDGE OF SCREEN?
	BCC	.CHECK_OFFSCREEN					;IF YES, SS DIDN'T MOVE ONTO SCREEN. PROCEED TO NEXT CHECK
	
	CMP #MAP_OBJECTS.X_FLAG.UPPER			;IS OBJECT BEYOND RIGHT EDGE OF SCREEN?
	BCS	.CHECK_OFFSCREEN					;IF YES, SS DIDN'T MOVE ONTO SCREEN. PROCEED TO NEXT CHECK
	
	LDA #$00								;IF NO, SS IS ONSCREEN TURN OFF THE OFFSCREEN SS FLAG
	STA MOB.SCREEN_STATUS.SS
	
	LDA #$10								;IF SS/DOUBLE MOVER MOB MOVES ONTO VIEW SCREEN ON ITS FIRST MOVE, IT FORFEITS ITS 2ND MOVE.
	STA MOB.MOVE.COUNTER

	
.CHECK_OFFSCREEN	
;DID MOB MOVE OFF VIEW SCREEN?
	LDA MAP_OBJECTS.MOB+$1,X
	CMP #MAP_OBJECTS.Y_FLAG.LOWER
	BCC MOB.NOTONSCREEN_STEP


.INCREMENT_SCREEN_TILE	
	TYA
	SEC
	SBC #SCREEN.ARRAY.OFFSET					;MOVE NORTH
	STA MAP_OBJECTS.TILE_LOCATION

; .INCREMENT_MAP_TILE
	LDA MAP_OBJECTS.MAP_LOCATION				;DOUBLE MOVES NEED THIS VALUE UPDATED
;	SEC
	SBC #OFFSET.DOWN
	STA MAP_OBJECTS.MAP_LOCATION

;MAKE FINAL DECISION ON WHETHER TO DRAW MOB'S TILE	
	LDA MOB.SCREEN_STATUS.SS
	CMP #$01 									;IS MOB AN OFFSCREEN SS?
	BNE MOB.DRAWTILE_STEP						;IF NO, DRAWTILE
	JMP MOB.MOVE.COMPLETE							;IF YES, INCREMENT INDEX. CALL IT A DAY.

@END	
	
MOB.MOVE.SOUTH	
@START
.CHECK_ONSCREEN
;UPDATE MOB X/Y	
	INC MAP_OBJECTS.MOB+$1,X				;+1 TO Y POSITION (MOVED MOB X,Y SOUTH)

;DID SS MOB MOVE ONTO VIEW SCREEN?	
	LDA MAP_OBJECTS.MOB+$1,X				
	CMP #MAP_OBJECTS.Y.FIRST_ROW			;IS MOB'S Y AXIS == FIRST ROW, NET OF ITS MOVE SOUTH?
	BNE .CHECK_OFFSCREEN					;IF NO, PROCEED NORMALLY

	;MAKE SURE IT'S X-AXIS IS ON THE SCREEN
	LDA MAP_OBJECTS.MOB,X
	CMP #MAP_OBJECTS.X_FLAG.LOWER			;IS OBJECT BEYOND LEFT EDGE OF SCREEN?
	BCC	.CHECK_OFFSCREEN					;IF YES, SS DIDN'T MOVE ONTO SCREEN. PROCEED TO NEXT CHECK
	
	CMP #MAP_OBJECTS.X_FLAG.UPPER			;IS OBJECT BEYOND RIGHT EDGE OF SCREEN?
	BCS	.CHECK_OFFSCREEN					;IF YES, SS DIDN'T MOVE ONTO SCREEN. PROCEED TO NEXT CHECK
		
	
	LDA #$00								;IF NO, SS IS ONSCREEN TURN OFF THE OFFSCREEN SS FLAG
	STA MOB.SCREEN_STATUS.SS
	
	LDA #$10								;IF SS/DOUBLE MOVER MOB MOVES ONTO VIEW SCREEN ON ITS FIRST MOVE, IT FORFEITS ITS 2ND MOVE.
	STA MOB.MOVE.COUNTER

	
.CHECK_OFFSCREEN	
;DID MOB MOVE OFF VIEW SCREEN?
	LDA MAP_OBJECTS.MOB+$1,X
	CMP #MAP_OBJECTS.Y_FLAG.UPPER
	BCS MOB.NOTONSCREEN_STEP


	
.INCREMENT_SCREEN_TILE
	TYA
	CLC
	ADC #SCREEN.ARRAY.OFFSET				;MOVE SOUTH
	STA MAP_OBJECTS.TILE_LOCATION

; .INCREMENT_MAP_TILE
	LDA MAP_OBJECTS.MAP_LOCATION			;DOUBLE MOVES NEED THIS VALUE UPDATED
	CLC
	ADC #OFFSET.UP
	STA MAP_OBJECTS.MAP_LOCATION

;MAKE FINAL DECISION ON WHETHER TO DRAW MOB'S TILE
	LDA MOB.SCREEN_STATUS.SS
	CMP #$01 									;IS MOB AN OFFSCREEN SS?
	BNE MOB.DRAWTILE_STEP						;IF NO, DRAWTILE
	JMP MOB.MOVE.COMPLETE							;IF YES, INCREMENT INDEX. CALL IT A DAY.


MOB.DRAWTILE_STEP
	JMP MOB.DRAWTILE

MOB.NOTONSCREEN_STEP
	JMP MOB.NOTONSCREEN

@END
	
MOB.MOVE.EAST
@START

;UPDATE MOB X/Y	
	INC MAP_OBJECTS.MOB,X					;+1 TO X POSITION (MOVED MOB X,Y EAST)
				
;DID SS MOB MOVE ONTO VIEW SCREEN?	
	LDA MAP_OBJECTS.MOB,X				
	CMP #MAP_OBJECTS.X.FIRST_COLUMN			;IS MOB'S X AXIS == FIRST COLUMN, NET OF ITS MOVE EAST?
	BNE .CHECK_OFFSCREEN					;IF NO, PROCEED NORMALLY
	
	;MAKE SURE ITS Y-AXIS IS ON THE SCREEN BEFORE TURNING OFF FLAG
	LDA MAP_OBJECTS.MOB+$1,X
	CMP #MAP_OBJECTS.Y_FLAG.LOWER			;IS OBJECT BEYOND LOWER EDGE OF SCREEN?
	BCC	.CHECK_OFFSCREEN					;IF YES, SS DIDN'T MOVE ONTO SCREEN. PROCEED TO NEXT CHECK

	CMP #MAP_OBJECTS.Y_FLAG.UPPER			;IS OBJECT BEYOND UPPER EDGE OF SCREEN?
	BCS	.CHECK_OFFSCREEN					;IF YES, SS DIDN'T MOVE ONTO SCREEN. PROCEED TO NEXT CHECK
	
	LDA #$10								;IF SS/DOUBLE MOVER MOB MOVES ONTO VIEW SCREEN ON ITS FIRST MOVE, IT FORFEITS ITS 2ND MOVE.
	STA MOB.MOVE.COUNTER

	LDA #$00								;IF NO, SS IS ONSCREEN TURN OFF THE OFFSCREEN SS FLAG
	STA MOB.SCREEN_STATUS.SS

.CHECK_OFFSCREEN	
;DID MOB MOVE OFF VIEW SCREEN?
		;**OPT** Memory and Speed. The onscreen check above does this same comparison, maybe if the tests in onscreen were reordered, and the X-FLAG upper check did MOB.NOTONSCREEN, then this section could be eliminated. 
	LDA MAP_OBJECTS.MOB,X
	CMP #MAP_OBJECTS.X_FLAG.UPPER
	BCS MOB.NOTONSCREEN_STEP

.INCREMENT_SCREEN_TILE	
	INY										;MOVE EAST (WE JUST INCREMENTED X AXIS, AND YES THIS IS THE Y-REG, BUT THE Y-REG HOLDS THE SCREEN TILE #)
	STY MAP_OBJECTS.TILE_LOCATION
	
; .INCREMENT_MAP_TILE
	INC MAP_OBJECTS.MAP_LOCATION			;DOUBLE MOVES NEED THIS VALUE UPDATED

;MAKE FINAL DECISION ON WHETHER TO DRAW MOB'S TILE
	LDA MOB.SCREEN_STATUS.SS
	CMP #$01 									;IS MOB AN OFFSCREEN SS?
	BNE MOB.DRAWTILE							;IF NO, DRAWTILE
	JMP MOB.MOVE.COMPLETE							;IF YES, INCREMENT INDEX. CALL IT A DAY.
@END		
		
MOB.MOVE.WEST
@START
;UPDATE MOB X/Y	
	DEC MAP_OBJECTS.MOB,X					;-1 TO X POSITION (MOVED MOB X,Y WEST)

;DID SS MOB MOVE ONTO VIEW SCREEN?	
	LDA MAP_OBJECTS.MOB,X				
	CMP #MAP_OBJECTS.X.LAST_COLUMN			;IS MOB IN LAST COLUMN, NET OF ITS MOVE WEST?
	BNE .CHECK_OFFSCREEN					;IF NO, PROCEED NORMALLY

	;MAKE SURE IT'S X-AXIS IS ON THE SCREEN BEFORE TURNING OFF FLAG
	LDA MAP_OBJECTS.MOB+$1,X
	CMP #MAP_OBJECTS.Y_FLAG.LOWER			;IS OBJECT BEYOND LOWER EDGE OF SCREEN?
	BCC	.CHECK_OFFSCREEN					;IF YES, SS DIDN'T MOVE ONTO SCREEN. PROCEED TO NEXT CHECK
	
	CMP #MAP_OBJECTS.Y_FLAG.UPPER			;IS OBJECT BEYOND UPPER EDGE OF SCREEN?
	BCS	.CHECK_OFFSCREEN					;IF YES, SS DIDN'T MOVE ONTO SCREEN. PROCEED TO NEXT CHECK
	
	LDA #$00								;IF NO, SS IS ONSCREEN TURN OFF THE OFFSCREEN SS FLAG
	STA MOB.SCREEN_STATUS.SS

	LDA #$10								;IF SS/DOUBLE MOVER MOB MOVES ONTO VIEW SCREEN ON ITS FIRST MOVE, IT FORFEITS ITS 2ND MOVE.
	STA MOB.MOVE.COUNTER

.CHECK_OFFSCREEN
;DID MOB MOVE OFF VIEW SCREEN?
	
	LDA MAP_OBJECTS.MOB,X
	CMP #MAP_OBJECTS.X_FLAG.LOWER
	BCC MOB.NOTONSCREEN_STEP
	
.INCREMENT_SCREEN_TILE	
	DEY											;MOVE WEST (WE JUST INCREMENTED X AXIS, AND YES THIS IS THE Y-REG, BUT THE Y-REG HOLDS THE SCREEN TILE #)			
	STY MAP_OBJECTS.TILE_LOCATION

; .INCREMENT_MAP_TILE
	DEC MAP_OBJECTS.MAP_LOCATION				;DOUBLE MOVES NEED THIS VALUE UPDATED

;MAKE FINAL DECISION ON WHETHER TO DRAW MOB'S TILE	
	LDA MOB.SCREEN_STATUS.SS
	CMP #$01 									;IS MOB AN OFFSCREEN SS?
	BNE MOB.DRAWTILE							;IF NO, DRAWTILE
	JMP MOB.MOVE.COMPLETE							;IF YES, INCREMENT INDEX. CALL IT A DAY.
@END
@END
@END
	
COMBAT
@START
;EVENTUALLY JSR OR JMP TO THE COMBAT SUBROUTINE, WHICH MIGHT BE IN B/S MEMORY.
;PROBABLY JMP. RE-ENTRY WILL NEED TO CALL DRAW.SCREEN
	
	LDA #$10
	STA MOB.MOVE.COUNTER
	JSR APPLE_BELL
	;****FALLS THROUGH
@END
	
MOB.DRAWTILE ;
@START
;ERROR CHECKING
	LDY MAP_OBJECTS.TILE_LOCATION
	CPY #SCREEN.ARRAY.LAST_ELEMENT			;IS TILE TO DRAW OFF THE SCREEN?
	BCS .MOB.MOVE.COMPLETE_STEP				;IF YES, THEN COMPLETE MOVE.
											;THERE IS 1 KNOWN CASE WHERE THIS OCCURS: A DOUBLE MOVER SS IS ON HILLS, HE'S BLOCKED IN THE DIRECTION OF THE PLAYER AND HE HIT SLOW PROGRESS ON THE HILLS. 

.START
	LDA MOB.FLAG2
	CMP #$01								;IS IF DOUBLE MOVER FLAG SET? 
	BNE MOB.DRAWTILE.ENTRANCE2				;IF NO, PROCEED WITH TILE DRAW
	LDA MOB.MOVE.COUNTER					
	CMP #$01								;IS THIS THE MOB'S 2ND MOVE? 
	BCC .MOB.MOVE.COMPLETE_STEP				;IF NO, COMPLETE MOVE AND RESTART MOVE LOOP
	JMP	MOB.DRAWTILE.ENTRANCE2				;IF YES, DRAWTILE

.MOB.MOVE.COMPLETE_STEP2
			LDA TEXT
			BRK
	JMP MOB.MOVE.COMPLETE


.MOB.MOVE.COMPLETE_STEP


	JMP MOB.MOVE.COMPLETE
	
MOB.DRAWTILE.ENTRANCE2
;ENTRANCE FOR INITIAL SCREEN DRAW, SO MOB MOVE COUNT CHECK IS SKIPPED

	LDA MOB.FLAG3							;MULT-TILE MOB?
	CMP #$01
	BEQ MOB.DRAWTILE.MT						;IF YES, USE THE MULTI-TILE DRAW ROUTINE

	LDY MAP_OBJECTS.TILE_LOCATION 
	
;IS TILE HIDDEN (DARKNESS)?	
	LDA SCREEN.DARK.DATA,Y			
	CMP #$01
	BEQ .MOB.NOTVISIBLE						;IF YES, DON'T DRAW TILE

;IS MAP TILE TALL GRASS? 
;(ONLY DRAW UPPER HALF OF MOB, SO LOWER HALF IS HIDDEN BY GRASS)	
	LDA SCREEN.TILE.DATA,Y				;LOAD MAP TILE MOB SITS ON
	CMP #TILE_ID.TALL_GRASS_A
	BEQ .TALL_GRASS	
	CMP #TILE_ID.TALL_GRASS_B
    BNE .NOT.TALL_GRASS
.TALL_GRASS
	LDA #TILE.DEPTH.HALF				;ADJUST TILE DEPTH SO ONLY UPPER HALF OF TILE IS DRAWN.	
	STA TILE.DEPTH

	LDA MAP_OBJECTS.MOB+$2,X			;LOAD MOB TILE TYPE
	STA SAVED_TILE_TYPE

		LDA #$0A							;SET TRACE
		STA CALLED_BY
	JSR DRAW.TILE.SINGLE
		LDA #$00							;RESET TRACE
		STA CALLED_BY
		
	LDA #TILE.DEPTH.STANDARD			;RESET TILE DEPTH TO FULL TILE. 		
	STA TILE.DEPTH	
	JMP .UPDATE.SCREEN_ARRAY
	
.NOT.TALL_GRASS	
;IS MOB A CROCODILE?
	LDA MAP_OBJECTS.MOB+$2,X			;LOAD MOB TILE TYPE
	CMP #TILE_ID.CROC_A					;DOES MOB HAVE CROC PRIMARY TILE_ID?
	BNE .DRAW.TILE						;IF NO, DRAW TILE
	LDA SCREEN.TILE.DATA,Y				;LOAD MAP TILE MOB SITS ON
	CMP #TILE_ID.SURF					;IS CROC IN SHALLOW WATER?
	BNE .DRAW.TILE						;IF NO, CALCULATE SHAPE TABLE
	LDA #TILE_ID.CROC_B					;IF YES, SUBSTITUTE ALTERNATE CROC TILE_ID (IN WATER ENVIRONMENT) 
	JMP .DRAW.TILE.ENTRANCE2

.DRAW.TILE
	LDA MAP_OBJECTS.MOB+$2,X			;LOAD MOB TILE TYPE
.DRAW.TILE.ENTRANCE2
	STA SAVED_TILE_TYPE

		LDA #$0B							;SET TRACE
		STA CALLED_BY		
	JSR DRAW.TILE.SINGLE
		LDA #$00							;SET TRACE
		STA CALLED_BY
	;FALLS THROUGH
.UPDATE.SCREEN_ARRAY	
.MOB.NOTVISIBLE
	TXA										;ACC = MAP_OBJECTS.MOB INDEX
	STA SCREEN.MO_MOB.DATA,Y
	JMP MOB.MOVE.COMPLETE
@END	

MOB.DRAWTILE.MT ;
@START
;UPDATE ALL TILE LOCATIONS FOR THE MULTI-TILE MOB
	LDY MAP_OBJECTS.TILE_LOCATION			;LOAD TILE LOCATION CALCUALTED IN MAIN ROUTINE ABOVE
	STY MOB.MT.TILE_LOCATIONS				;SAVE AS TILE #0 (UPPER LEFT) OF MT MOB

	INY
	STY MOB.MT.TILE_LOCATIONS+$1			;SAVE AS TILE #1 (UPPER RIGHT) OF MT MOB
	TYA
	CLC
	ADC #SCREEN.ARRAY.OFFSET
	STA MOB.MT.TILE_LOCATIONS+$3			;SAVE AS TILE #3 (LOWER RIGHT) OF MT MOB
	TAY
	DEY
	STY MOB.MT.TILE_LOCATIONS+$2			;SAVE AS TILE #2 (LOWER LEFT) OF MT MOB

;CALCUALTE THE TILE TYPES FOR EACH TILE OF MT MOB
	LDY MAP_OBJECTS.MOB+$2,X				;LOAD TILE TYPE OF MOB RECORD
	STY MOB.MT.TILE_TYPES
	INY
	STY MOB.MT.TILE_TYPES+$1
	INY
	STY MOB.MT.TILE_TYPES+$2
	INY
	STY MOB.MT.TILE_TYPES+$3
	
	LDA MAP_OBJECTS.MOB,X					;LOAD X-AXIS (COLUMN) OF TILE0 OF MT MOB
	STA MOB.MT.POSITION.X					;SAVE FOR FUTURE USE, WHEN X/Y-REG ARE BOTH BUSY
	
	STX SAVED.XREG.LOCAL					;SAVE X-REG SO WE CAN USE IT AS LOOP COUNTER
	LDX #$00								;INIT LOOP COUNTER
.LOOP	
	LDY MOB.MT.TILE_LOCATIONS,X

;IS TILE ON THE VIEW SCREEN
;(normally this condition indicates an error, but with MT Mobs, it can happen legitimately if the mob is half on/off the screen. In that case, it's legit but the correct process is to not draw the offscreen tiles)	
	;IF TILE IS OFFSCREEN TO NORTH OR SOUTH, THE TILE # WILL EXCEED THE LAST ARRAY ELEMENT

	LDA #SCREEN.ARRAY.LAST_ELEMENT
	CMP MOB.MT.TILE_LOCATIONS,X	
	BCS .CHECK.EAST_WEST
	JMP .TILE.OFFSCREEN
.CHECK.EAST_WEST
	;OFFSCREEN EAST/WEST REQUIRES CHECKING THE COLUMN 
	LDA MOB.MT.POSITION.X					;LOAD X-AXIS (COLUMN) OF TILE0 OF MT MOB. LOADING FROM VARIABLE BECAUSE X/Y-REG ARE BOTH IN USE	

	CPX #$00								;IS TILE 0 THE CURRENT TILE??
	BEQ .TILE0.OFFSCREEN_CHECK
	CPX #$01								;IS TILE 1 THE CURRENT TILE??
	BEQ .TILE1.OFFSCREEN_CHECK
	CPX #$02								;IS TILE 2 THE CURRENT TILE??
	BEQ .TILE2.OFFSCREEN_CHECK
	CPX #$03								;IS TILE 3 THE CURRENT TILE??
	BEQ .TILE3.OFFSCREEN_CHECK

.TILE0.OFFSCREEN_CHECK
	CMP MAP_OBJECTS.X_APPROACH+$1
	BEQ .TILE.OFFSCREEN
	JMP .TILE_ONSCREEN
	
.TILE1.OFFSCREEN_CHECK
	CMP #MAP_OBJECTS.X.LAST_COLUMN
	BEQ .TILE.OFFSCREEN
	JMP .TILE_ONSCREEN

.TILE2.OFFSCREEN_CHECK
	CMP MAP_OBJECTS.X_APPROACH+$1
	BEQ .TILE.OFFSCREEN
	JMP .TILE_ONSCREEN

.TILE3.OFFSCREEN_CHECK

	CMP #MAP_OBJECTS.X.LAST_COLUMN
	BEQ .TILE.OFFSCREEN
	JMP .TILE_ONSCREEN
	
	
.TILE_ONSCREEN	
;IS TILE HIDDEN (DARKNESS)?	
	LDA SCREEN.DARK.DATA,Y			
	CMP #$01
	BEQ .TILE.NOTVISIBLE					;IF YES, DON'T DRAW TILE

	LDA SCREEN.TILE.DATA,Y
	CMP #TILE_ID.TALL_GRASS_A
	BEQ .TALL_GRASS	
	CMP #TILE_ID.TALL_GRASS_B
    BNE .NOT.TALL_GRASS	
	;***FALLS THROUGH***
.TALL_GRASS	
	LDA #TILE_ID.GRASS
	STA SCREEN.TILE.DATA,Y
	
.NOT.TALL_GRASS	
	LDA MOB.MT.TILE_TYPES,X					;LOAD NEXT MT TILE_TYPE
	STA SAVED_TILE_TYPE	

		LDA #$0C							;SET TRACE
		STA CALLED_BY
	JSR DRAW.TILE.SINGLE
		LDA #$00							;RESET TRACE
		STA CALLED_BY

.TILE.NOTVISIBLE
	LDA SAVED.XREG.LOCAL					;LOAD MAP_OBJECTS.MOB INDEX						
	STA SCREEN.MO_MOB.DATA,Y				;SAVE TO SCREEN ARRAY TO MARK MOB'S PRESENCE FOR OTHER ROUTINES LIKE ANIMATION

.TILE.OFFSCREEN
.EXIT_TEST
	INX
	CPX #$04
	BNE .LOOP
	LDX SAVED.XREG.LOCAL	
;****FALLS THROUGH
@END

MOB.MOVE.COMPLETE ;
@START

	LDA MOB.FLAG2
	CMP #$01								;IS IF DOUBLE MOVER FLAG SET? 
	BNE INCREMENT_INDEX						;IF NO, INCREMENT INDEX, NEXT MO RECORD
	INC MOB.MOVE.COUNTER
	
	LDA MOB.MOVE.COUNTER					
	CMP #$02								;IS THIS THE MOB'S 2ND MOVE? (WE'RE USING #$02 THIS TIME BECUASE WE JUST INCREMENTED THE COUNTER)
	BCS INCREMENT_INDEX						;IF YES, INCREMENT INDEX, NEXT MO RECORD
	JMP MOB.MOVEMENT						;IF NO, LET MOB MOVE AGAIN. 

MOB.NOTONSCREEN
	;****FALLS THROUGH
@END
@END





INCREMENT_INDEX
@START
;INCREMENT INDEX TO ALL MAP OBJECT ARRAYS. 
				
	TXA
	CLC
	ADC #MAP_OBJECTS.RECORD_LENGTH			;RECORD LENGTH
	BEQ EXIT								;IF INCREMENT RESULTS IN $00 THEN INDEX FLIPPED OVER, MEANING THE ARRAY IS FULL
	TAX

	JMP PRIMARY_LOOP	

EXIT
@END		
	RTS	

ERROR1
@START
;MO.DRAW DETECTS INVALID VALUE IN MOVE.COMMAND, or .MOB.MOVE.IMPLIMENT detects invalid
;value in MOB.MOVE.CURRENT
	BRK
@END
@END
@END


MOB.GENERATION ;=========MANAGES THE RANDOM GENERATION OF MOBS ON THE MAP======
@START

;=====================*TOP LEVEL* SUBROUTINE DOCUMENTATION====================================
;
;This subroutine is called by GAME.PRIMARY_LOOP while waiting for a keypress.
;This subroutine does an abort-if-key-pressed check several times during it's run-time
;which is to avoid slowing down player movement. 
;
;Normally only one mob generation attempt per player turn is permitted. 
;However, a key feature is that aborts are tallied and this routine will
;run each time it is called from the game loop if there are unprocessed aborts.
;However, when processing aborted attempts, a probability check is still applied
;to determine if a mob should be generated. 
;=================================================================================

;NOTE: MAP X,Y IS NOT THE SAME AS MOB X,Y, THE LATER REFERING TO THE POSITION OF THE MOB RELATIVE TO THE PLAYER

;NOTE2: THERE MIGHT BE AN ISSUE MOBS BEING ASSIGNED A WRONG MOB X,Y IF THE GENERATOR CHOOSES A
;RMAP ON THE EDGE COLUMNS OF THE MAP. THIS IS BECAUSE OF THE GOOFYNES OF THE DATA COMPRESSION WHICH RESULTS IN THE FIRST TILE
;HAVING A RMAP OF $1 INSTEAD OF $0. MY PLAN IS TO IGNORE FOR NOW AND THEN VERIFY IT'S RESOLVED
;AFTER REDOING THE MAP WITH LOADER ZONES. 


;IDEAS:
;	1) BALANCING SPEED WITH TIMELY GENERATION OF MOBS
;					Maybe instead of queuing all keypress aborts, we could pick a few generation zones on the map
;					few simple mob types it could create there. Of course the problem becomes mobs piling up there, unless they are SS. 

;====DETERMINE WHETHER TO ATTEMPT MOB GENERATION====
@START
;=====================CODE SECTION DOCUMENTATION====================================
;The determination is made based on whether a) it is the player's turn (only one mob 
;generation attempt per player move is permitted) and b) a random number probability check 
;=================================================================================

DRIVER1
	; LDA #$01
	; STA	GAME.MOB_GEN.CONTROL

START
	LDA GAME.MOB_GEN.CONTROL
	CMP #$01
	BEQ .GENERATE.DECIDE
	JMP EXIT_FINAL
.GENERATE.DECIDE
;GENERATE MOB THIS TURN?

	; LDA MOB.GEN.QUEUE					;IF ABORTED RUNS OF MOB.GENERATION ARE IN THE QUEUE, BYPASS PROBABILITY CHECK.
	; BEQ .GENERATE.DECIDE.PROB
	; LDA #$01
	; STA MOB.GEN.QUEUE_LOCK				;LOCK THE QUEUE SO IT DOENSN'T INCREASE IF AN ABORT OCCURS WHEN PROCESSING THE QUEUE

	; JMP .GENERATE.START

.GENERATE.DECIDE.PROB
	;USE DEFAULT RANDOM # RANGE
	JSR RANDOM.8

	CMP MOB.GEN.PROBABILITY				;CHANCE THAT GAME WILL ATTEMPT TO GENERATE A MOB
	BCC .GENERATE.START	
	JMP EXIT_FINAL

@END
	
;=====DETERMINE LOCATION OF NEW MOB=====
@START
;=====================CODE SECTION DOCUMENTATION====================================
;If this code section is reached, the random number probability check for deciding
;whether to attempt mob generation passed. 
;
;The regional map location of new mob is determined by a two 8-bit random numbers, 
;the ranges of which are set so that they can be used as the HO/LO byte
;of RMAP. 
;
;Once the new mob's RMAP is calculated, collision checks are applied 
;to determine whether a new mob can be created at the RMAP location.
;
;Since mob locations are tracked using an x,y relative to the player position
;the mob's RMAP is converted to relative x,y. 
;=================================================================================

.GENERATE.START
;Random # range
;Random LO: 01-FF, HO: 00-0F

;INIT VARIABLES		
	LDA #$00
	STA MOB.GEN.SEA_FLAG				;RESET. #$01 TELLS .DECIDE.MOB_TYPE TO CHOOSE A SEA MOB TYPE				

;=====GENERATE RANDOM NUMBERS===========
@START	
.RANDOM0
;RND FOR RMAP LO BYTE	
	;Uses default range ($01-$FF) (RANDOM.8 resets the range to these values on return)
	
	;**OPT**Speed. it's setup to generate a RND # $0-$8. instead use the standard range ($1-$FF) and use conditional logic to associated that with the 9 possible HO address values (0-8)
	
	LDA #$01
	STA RND.ABORT
	JSR RANDOM.8
	STA MOB.CANDIDATE.RMAP

	LDA KB_BUFFER					;LOAD NEXT KEY PRESS FROM BUFFER
    BPL .RANDOM1					;IF NO KEY PRESS, THEN CONTINUE
	JMP EXIT.ABORT					;IF KEY PRESSED, LEAVE IT IN BUFFER AND RETURN TO GAME LOOP FOR KEYPRESS PROCESSING

.RANDOM1	
;RND FOR RMAP HO BYTE	
	LDA #MOB.GEN.RANDOM_HO.START
	STA RND.LO

	LDA #MOB.GEN.RANDOM_HO.END
	STA RND.HI
			
	LDA #$01
	STA RND.ABORT
	JSR RANDOM.8
	STA MOB.CANDIDATE.RMAP+$1

	LDA KB_BUFFER					;LOAD NEXT KEY PRESS FROM BUFFER
    BPL .CALCULATE.MOB.MAP			;IF NO KEY PRESS, THEN CONTINUE
	JMP EXIT.ABORT					;IF KEY PRESSED, LEAVE IT IN BUFFER AND RETURN TO GAME LOOP FOR KEYPRESS PROCESSING

@END

;======CALCULATE MAP X,Y OF MOB'S RMAP======
.CALCULATE.MOB.MAP			
@START

				; LDA #$06
				; STA MOB.CANDIDATE.RMAP
				; LDA #$06
				; STA MOB.CANDIDATE.RMAP+$1

	LDA MOB.CANDIDATE.RMAP
	STA DIVIDEND
	LDA MOB.CANDIDATE.RMAP+$1
	STA DIVIDEND+$1
	LDA	#OFFSET.UP
	STA DIVISOR
	LDA #$00
	STA DIVISOR+$1
	
	JSR DIV.16						;**OPT** Speed. Memory. Replace with in-line code
	
	LDA RESULT 
	STA MOB.CANDIDATE.MAP.Y			;QUOTIENT IS MAP Y-AXIS
	LDA RESULT+$2
	STA MOB.CANDIDATE.MAP.X			;REMAINDER IS MAP X-AXIS

.NO_FLIP
@END

;======COLLISION CHECKS & DETERMINE LAND VS SEA MOB======
@START
;=======INLINE CODE FOR ADC.16========	
;RZONE.ARRAY(2) + RMAP (2)
	
	CLC                          			;ALWAYS BEFORE ADD
	LDA #RZONE.ARRAY						;OP1
	ADC MOB.CANDIDATE.RMAP					;OP2  
	STA RZONE.ARRAY.INDEX_ROW
				 
	LDA /RZONE.ARRAY						;OP1+$1
	ADC MOB.CANDIDATE.RMAP+$1				;OP2+$2 carry flag not cleared via CLC intentionally, it's part of 16-bit adding. 
	STA RZONE.ARRAY.INDEX_ROW+$1
;======================================	

	LDY #$00
	LDA (RZONE.ARRAY.INDEX_ROW),Y

	CMP #MOB.GEN_FLAG.GRE			;IS CANDIDATE LOCATION WATER?
	BCS .WATER_TEST1.PASS			;WATER TEST #1
	JMP .COLLISION.LAND_MOB
.WATER_TEST1.PASS
	CMP #MOB.GEN_FLAG.LT2			;WATER TEST #2	
	BCC .COLLISION.SEA_MOB
	
.COLLISION.LAND_MOB
	
	CMP #MOB.GEN_FLAG.LT1			;ABSOLUTE OBSTACLE?			
	BCC .KEY_CHECK					;IF YES, THEN CHECK FOR KEY PRESS BEFORE REGENERATING RANDOM LOCATION FOR CANDIDATE MOB
	JMP .LAND_MOB.NEXT_TEST
.KEY_CHECK
	LDA KB_BUFFER					;LOAD NEXT KEY PRESS FROM BUFFER
    BPL .GENERATE.START_STEP		;IF NO KEY PRESS, REGENERATE RANDOM LOCATION FOR CANDIDATE MOB
	JMP EXIT.ABORT					;IF KEY PRESSED, LEAVE IT IN BUFFER AND RETURN TO GAME LOOP FOR KEYPRESS PROCESSING
	
.GENERATE.START_STEP
	JMP .GENERATE.START

.LAND_MOB.NEXT_TEST

;OTHER CHECKS (NOT YET IMPLEMENTED)	
				;Player is in the tile, or adjacent to the tile..this is because there is a 1 turn lag between a mob being created and a mob appearing on the screen. the adjacent exclusion prevents a collision detection on the player for an object not drawn on the screen. 
				;A building is in the tile
	JMP .COLLISION.COMMON
	
.COLLISION.SEA_MOB	

	LDA #$01
	STA MOB.GEN.SEA_FLAG				;TELLS .DECIDE.MOB_TYPE TO CHOOSE A SEA MOB TYPE

	;****FALLS THROUGH...SHOULD IT?
@MIDDLE

.COLLISION.COMMON ;COLLISION CHECKS COMMON TO LAND & SEA
;CALCULATE MAP X,Y OF PLAYER RMAP
	;*******THIS MAY BE A GOOD PLACE FOR A KEY CHECK, BEFORE RESTARTING THE GENERATION	

	;**OPT** Memory. Speed. Once GMAP.X and GMAP.Y are in use this may not be necessary
	
	LDA RMAP
	STA DIVIDEND
	LDA RMAP+$1
	STA DIVIDEND+$1
	LDA	#OFFSET.UP
	STA DIVISOR
	LDA #$00
	STA DIVISOR+$1
	
	JSR DIV.16
	
	LDA RESULT 
	STA PLAYER.MAP.Y								;QUOTIENT IS MAP Y-AXIS
	LDA RESULT+$2
	STA PLAYER.MAP.X								;REMAINDER IS MAP X-AXIS

;CALCULATE THE MOB'S RELATIVE X,Y
	LDA MOB.CANDIDATE.MAP.X
	CMP PLAYER.MAP.X
	BCC .MOB.MO_X_LESS
	
	SEC
	SBC PLAYER.MAP.X
	STA MAP_OBJECTS.X_ADJ
	LDA #MAP_OBJECTS.PLAYER_LOCATION
	CLC
	ADC MAP_OBJECTS.X_ADJ
	STA MOB.CANDIDATE.RELATIVE.X

	JMP .MOB.YTEST

.MOB.MO_X_LESS
	LDA PLAYER.MAP.X
	SEC
	SBC MOB.CANDIDATE.MAP.X
	STA MAP_OBJECTS.X_ADJ
	LDA #MAP_OBJECTS.PLAYER_LOCATION
	SEC
	SBC MAP_OBJECTS.X_ADJ
	STA MOB.CANDIDATE.RELATIVE.X

.MOB.YTEST	

	LDA MOB.CANDIDATE.MAP.Y
	CMP PLAYER.MAP.Y
	BCC .MOB.MO_Y_LESS
	
	LDA MOB.CANDIDATE.MAP.Y
	SEC
	SBC PLAYER.MAP.Y
	STA MAP_OBJECTS.Y_ADJ
	
	LDA #MAP_OBJECTS.PLAYER_LOCATION
	CLC
	ADC MAP_OBJECTS.Y_ADJ
	STA MOB.CANDIDATE.RELATIVE.Y
		
	JMP .RELATIVE.X_Y.COMPLETE

.MOB.MO_Y_LESS
	LDA PLAYER.MAP.Y
	SEC
	SBC MOB.CANDIDATE.MAP.Y
	STA MAP_OBJECTS.Y_ADJ
	
	LDA #MAP_OBJECTS.PLAYER_LOCATION
	SEC	
	SBC MAP_OBJECTS.Y_ADJ
	STA MOB.CANDIDATE.RELATIVE.Y

.RELATIVE.X_Y.COMPLETE	
	
;COMMON COLLISION CHECKS
	;Another Mob is in the tile
	;Transport is in the tile
@END
@END
	
;=========	
DECIDE.MOB_TYPE ;
@START
;=====================CODE-SECTION DOCUMENTATION====================================
;If a prospective new mob passes the collision checks, then the last step
;is to decide (via random numbers) the Tile_ID of the mob, it's flags,
;and setup a new map object record. 
;=================================================================================

	;(for now there is only one land mob tile, so skipping calcualtion)

;WAS SEA MOB OR LAND MOB ALREADY DETERMINED (BASED ON RMAP OF MOB)	
	LDA MOB.GEN.SEA_FLAG
					;BNE .DECIDE.SEA_MOB
;.DECIDE.LAND_MOB
	LDA #$97
	STA MOB.CANDIDATE.TYPE	
	JMP DECIDE.MOB_FLAGS
.DECIDE.SEA_MOB
	LDA #$8C
	STA MOB.CANDIDATE.TYPE	
	;***FALLS THROUGH

DECIDE.MOB_FLAGS ;

;4 FLAG_OPTIONS: SPLIT POINTS $3F, $74, $BF
	JSR RANDOM.8
	CMP #$3F
	BCS .FLAG_OPTIONS.NEXT_TEST1
;.OPT0
	LDA #$00	
	JMP .FLAG.SET
.FLAG_OPTIONS.NEXT_TEST1
	CMP #$BF
	BCS .FLAG_OPTIONS.OPT3
;.FLAG_OPTIONS.NEXT_TEST2
	CMP #$74
	BCS .FLAG_OPTIONS.OPT2
;.OPT1
	LDA MOB.GEN.SS_QTY	
	CMP #MOB.GEN.SS_LIMIT
	BCS .SS_AT_MAX_LIMIT
	LDA #$03
	JMP .FLAG.SET
.SS_AT_MAX_LIMIT						;OPT1 IS EITHER FLAG #$03 (aggressive SS) or $00 (non-ss less aggresive), depending on whether the maximum SS in the current region has been reached
	LDA #$00
	JMP .FLAG.SET
.FLAG_OPTIONS.OPT2
	LDA #$01
	JMP .FLAG.SET
.FLAG_OPTIONS.OPT3
	LDA #$05
	JMP .FLAG.SET

.FLAG.SET
				
	STA MOB.CANDIDATE.FLAGS				;SET FLAG BASED ON ACC VALUE LOADED ABOVE

@MIDDLE

RECORD_ENTRANCE	
;RECORD NEW MOB RECORD

;=====================CODE-SECTION DOCUMENTATION====================================
;
;This code section searches the mob map object array for an open record.
;If no open record can be found an existing record is overwritten. However,
;a variable is used as an index to the record to overwrite. This variable
;is incremented each time there is no open records found because always
;overwriting the same record would potentially reduce the variety of
;mobs in the array. And, if the same record was overwritten and the mob
;was on the view screen, the player could observe the mob change it's type
;several time rapidly if there were aborts on the queue. 
;=================================================================================

	LDX #$00
.RECORD_LOOP
	LDA MAP_OBJECTS.MOB+$2,X
	CMP #$00								;#$00 IS THE ARRAY STOP VALUE
	BEQ .OPEN_RECORD_FOUND
	TXA
	CLC
	ADC #MAP_OBJECTS.RECORD_LENGTH
;	BEQ EXIT2								;IF COUNTER FLIPS TO #$00, THEN NO OPEN RECORDS AVAILABLE, EXIT
	BEQ .ARRAY_FULL							;IF COUNTER FLIPS TO #$00, THEN NO OPEN RECORDS AVAILABLE, EXIT

	TAX
	JMP .RECORD_LOOP

.ARRAY_FULL
	LDA MOB.GEN.ARRAY_FULL_COUNTER
	CLC
	ADC #MAP_OBJECTS.RECORD_LENGTH
	STA MOB.GEN.ARRAY_FULL_COUNTER
	TAX
	;**FALLS THROUGH
	
.OPEN_RECORD_FOUND
	LDA MOB.CANDIDATE.RELATIVE.X
	STA MAP_OBJECTS.MOB,X

	LDA MOB.CANDIDATE.RELATIVE.Y
	STA MAP_OBJECTS.MOB+$1,X

	LDA MOB.CANDIDATE.TYPE
	STA MAP_OBJECTS.MOB+$2,X

	LDA MOB.CANDIDATE.FLAGS
	STA MAP_OBJECTS.MOB+$3,X

@END	
EXIT2
@START
	LDA MOB.GEN.QUEUE
	CMP #$00							;**OPT** Memory. Speed. I think all CMP #$00s can be removed becuase BEQ/BNE trigger if the last operation results in 0, including an LDA. Also search for CMP #$01s because they could probably be convertd to test for $00. 
	BEQ .QUEUE_EMPTY							
	DEC	MOB.GEN.QUEUE					;IF THERE ARE ABORTED MOB GENERATIONS IN QUEUE, EXIT WITHOUT SETTING TURN BACK TO PLAYER
	JMP EXIT_FINAL

.QUEUE_EMPTY
	LDA #$00							;SET TURN TO PLAYER
	STA	GAME.MOB_GEN.CONTROL
	;**FALLS THROUGH

EXIT_FINAL

	RTS

EXIT.ABORT								;USED IF PLAYER PRESSES A KEY DURING THIS ROUTINE, KEEPS TURN SET TO MOB FOR GENERATION
	INC MOB.GEN.QUEUE	

	STA RND.HI	
	RTS
@END
@END


;TWO METHODS FOR HANDLING MULTI-TILE FRIGATES THAT WEREN'T USED	
@START

;=================================MAUALLY ADJUST RMAP METHOD==================

; ;IDENTIFY WHICH TILE OF THE SHIP THE PLAYER WAS LOCATED ON WHEN EXECUTING BOARD COMMAND	
; ;	LDA SAVED.ACC.LOCAL							;LOAD TILE TYPE OF OBJECT BEING BOARDED
	; LDA MAP_OBJECTS.TRANSPORT,X					;LOAD X-AXIS
	; CMP #$7F
	; BEQ .X7F
	; CMP #$80
	; BEQ .X80
	
; .ERROR2
; ;FRIGATE X-AXIS IN UNEXPECTED POSITION IN .CENTER_FRIGATE_ONSCREEN
	; TAY
	; LDA TEXT
	; BRK
	

; .X7F
	; LDA MAP_OBJECTS.TRANSPORT+$1,X					;LOAD Y-AXIS
	; CMP #$7F
	; BEQ .X7F.Y7F
	; CMP #$80
	; BEQ .X7F.Y80

; .ERROR3
; ;FRIGATE Y-AXIS IN UNEXPECTED POSITION IN .CENTER_FRIGATE_ONSCREEN
	; LDA TEXT
	; BRK
	
; .X80
	; LDA MAP_OBJECTS.TRANSPORT+$1,X					;LOAD Y-AXIS
	; CMP #$7F
	; BEQ .X80.Y7F
	; CMP #$80
	; BEQ .X80.Y80

; .ERROR4
; ;FRIGATE Y-AXIS IN UNEXPECTED POSITION IN .CENTER_FRIGATE_ONSCREEN
	; LDA TEXT
	; BRK
	

; .X80.Y80
; .NW ; PLAYER IS LOCATED ON THE NORTHWEST TILE OF THE FRIGATE
	; ;ALREADY CENTERED
	; JMP BOARD.EXIT
	
; .X7F.Y80	
; .NE ; PLAYER IS LOCATED ON THE NORTHEAST TILE OF THE FRIGATE
	 
	; DEC RMAP.X							;RMAP.X/Y ARE THE PLAYERS X,Y WITHIN THE REGIONAL MAP, WHICH ARE USED TO TRIGGER ZONE TRANSITION. 

; ;16-BIT SUBTRACT (REQUIRED, PROBLEMS WITH DEC WITH FLIP DETECT)
	; LDA RMAP					;UPDATE POSITION IN REGIONAL MAP ARRAY
	; SEC
	; SBC #$01
	; STA RMAP
	; LDA RMAP+$1
	; SBC #$00
	; STA RMAP+$1
	
; .NOFLIP

; ;=======THE FOLLOWING ARE UPDATES THAT OCCUR DURING A PLAYER MOVE======	
; ;UPDATE SMAP/SMAP.CURRENT
	; LDA RMAP					;LOAD TILE_ID OF CURRENT MAP POSITION (CENTER/PLAYER TILE)
	; STA OP1
	; LDA RMAP+$1
	; STA OP1+$1
	
	; LDA #OFFSET.SCREEN			;CALCULATE TILE_ID OF TILE IN UPPER LEFT CORNER OF SCREEN
	; STA OP2
	; LDA /OFFSET.SCREEN
	; STA OP2+$1
	
	; JSR SBC.16					;RMAP(2) - SCREEN.OFFSET.LO/HO (2)
			
	; LDA RESULT					;SAVE TILE_ID OF UPPER LEFT SCREEN TILE
	; STA SMAP
	; STA SMAP.CURRENT
	; LDA RESULT+$1
	; STA SMAP+$1
	; STA SMAP.CURRENT+$1

; ;UPDATE MOB (SS) REGIONAL MAP FLAGS
	; DEC MAP_OBJECTS.SS.X_FLAG.LOWER		;ADJUST FLAGS USED TO DETERMINE IF AN SS IS LOCATED ON THE REGIONAL MAP. IT CHANGES WITH EACH PLAYER MOVE BECAUSE MOB'S X,Y IS TRACKED RELATIVE TO THE PLAYER
	; INC MAP_OBJECTS.SS.X_FLAG.UPPER
; ;================================END STANDARD PLAYER MOVE UPDATES=========================


; ;UPDATE ALL MAP OBJECTS TO REFLECT ADJUSTMENT TO PLAYER LOCATION 

	; LDX #$00
; .LOOP.UPDATE.MAP_OBJECTS
	; INC MAP_OBJECTS.TRANSPORT,X				;+1 TO X POSITION
	; INC MAP_OBJECTS.MOB,X					;+1 TO X POSITION

; ;NEXT MAP OBJECT RECORD		
	; TXA
	; CLC
	; ADC #MAP_OBJECTS.RECORD_LENGTH			;RECORD LENGTH
	; BEQ .UPDATE.COMPLETE					;IF INCREMENT RESULTS IN $00 THEN INDEX FLIPPED OVER, MEANING THE ARRAY IS FULL
	; TAX	
											
; ;EXIT TEST
; ;(test each map array for $00 in the first field of the current record, if all arrays are at end, then exit)
; ;Note: it doesn't hurt for the x/y records to be updated in empty record (this will happen for the array that is less full), because it is the tile_id (3rd byte) that is used for the stop value
	; LDA MAP_OBJECTS.TRANSPORT+$2,X			;AT END OF ARRAY?
	; CMP #$00	
	; BNE .LOOP.UPDATE.MAP_OBJECTS			;IF NO, CONTINUE LOOP
	; LDA MAP_OBJECTS.MOB+$2,X				;AT END OF ARRAY?
	; CMP #$00	
	; BNE .LOOP.UPDATE.MAP_OBJECTS			;IF NO, CONTINUE LOOP

; .UPDATE.COMPLETE

	; PLA									;REMOVE RTS ADDED TO THE STACK WHEN MO.BOARD WAS CALLED
	; PLA

	; JMP GAME.LAUNCH						;REDRAW SCREEN WITH FRIGATE IN THE CENTER

	
; .X7F.Y7F	
; .SE ; PLAYER IS LOCATED ON THE SOUTHEAST TILE OF THE FRIGATE

	 
	; DEC RMAP.X							;RMAP.X/Y ARE THE PLAYERS X,Y WITHIN THE REGIONAL MAP, WHICH ARE USED TO TRIGGER ZONE TRANSITION. 
	; DEC RMAP.Y							;RMAP.X/Y ARE THE PLAYERS X,Y WITHIN THE REGIONAL MAP, WHICH ARE USED TO TRIGGER ZONE TRANSITION. 
	
; ;16-BIT SUBTRACT (REQUIRED, PROBLEMS WITH DEC WITH FLIP DETECT)
	; LDA RMAP					;UPDATE POSITION IN REGIONAL MAP ARRAY
	; SEC
	; SBC #$01
	; STA RMAP
	; LDA RMAP+$1
	; SBC #$00
	; STA RMAP+$1

	; LDA RMAP					;UPDATE POSITION IN REGIONAL MAP ARRAY
	; SEC
	; SBC #SCREEN.ARRAY.OFFSET
	; STA RMAP
	; LDA RMAP+$1
	; SBC #$00
	; STA RMAP+$1
	
; .NOFLIP

; ;=======THE FOLLOWING ARE UPDATES THAT OCCUR DURING A PLAYER MOVE======	
; ;UPDATE SMAP/SMAP.CURRENT
	; LDA RMAP					;LOAD TILE_ID OF CURRENT MAP POSITION (CENTER/PLAYER TILE)
	; STA OP1
	; LDA RMAP+$1
	; STA OP1+$1
	
	; LDA #OFFSET.SCREEN			;CALCULATE TILE_ID OF TILE IN UPPER LEFT CORNER OF SCREEN
	; STA OP2
	; LDA /OFFSET.SCREEN
	; STA OP2+$1
	
	; JSR SBC.16					;RMAP(2) - SCREEN.OFFSET.LO/HO (2)
			
	; LDA RESULT					;SAVE TILE_ID OF UPPER LEFT SCREEN TILE
	; STA SMAP
	; STA SMAP.CURRENT
	; LDA RESULT+$1
	; STA SMAP+$1
	; STA SMAP.CURRENT+$1

; ;UPDATE MOB (SS) REGIONAL MAP FLAGS
	; DEC MAP_OBJECTS.SS.X_FLAG.LOWER		;ADJUST FLAGS USED TO DETERMINE IF AN SS IS LOCATED ON THE REGIONAL MAP. IT CHANGES WITH EACH PLAYER MOVE BECAUSE MOB'S X,Y IS TRACKED RELATIVE TO THE PLAYER
	; INC MAP_OBJECTS.SS.X_FLAG.UPPER
	
	
; ;================================END STANDARD PLAYER MOVE UPDATES=========================


; ;UPDATE ALL MAP OBJECTS TO REFLECT ADJUSTMENT TO PLAYER LOCATION 

	; LDX #$00
; .LOOP.UPDATE.MAP_OBJECTS
	; INC MAP_OBJECTS.TRANSPORT,X				;+1 TO X POSITION
	; INC MAP_OBJECTS.MOB,X					;+1 TO X POSITION

; ;NEXT MAP OBJECT RECORD		
	; TXA
	; CLC
	; ADC #MAP_OBJECTS.RECORD_LENGTH			;RECORD LENGTH
	; BEQ .UPDATE.COMPLETE					;IF INCREMENT RESULTS IN $00 THEN INDEX FLIPPED OVER, MEANING THE ARRAY IS FULL
	; TAX	
											
; ;EXIT TEST
; ;(test each map array for $00 in the first field of the current record, if all arrays are at end, then exit)
; ;Note: it doesn't hurt for the x/y records to be updated in empty record (this will happen for the array that is less full), because it is the tile_id (3rd byte) that is used for the stop value
	; LDA MAP_OBJECTS.TRANSPORT+$2,X			;AT END OF ARRAY?
	; CMP #$00	
	; BNE .LOOP.UPDATE.MAP_OBJECTS			;IF NO, CONTINUE LOOP
	; LDA MAP_OBJECTS.MOB+$2,X				;AT END OF ARRAY?
	; CMP #$00	
	; BNE .LOOP.UPDATE.MAP_OBJECTS			;IF NO, CONTINUE LOOP

; .UPDATE.COMPLETE

	; PLA									;REMOVE RTS ADDED TO THE STACK WHEN MO.BOARD WAS CALLED
	; PLA

	; JMP GAME.LAUNCH						;REDRAW SCREEN WITH FRIGATE IN THE CENTER

	
; .X80.Y7F
; .SW ; PLAYER IS LOCATED ON THE SOUTHWEST TILE OF THE FRIGATE




;=========================TILE LOCATION IN VARIABLES METHOD===============
	
; .SET.MT.TILE_LOCATIONS
	; ;CALCULATE ALL 4 SCREEN LOCATIONS OF THE FRIGATE AND SAVE FOR USE BY OTHER ROUTINES LIKE DRAW.TILE.PLAYER
	; LDY #SCREEN.ARRAY.PLAYER_LOCATION
	; STY PLAYER.TRANSPORT.MT.TILE_LOCATIONS
	; INY
	; STY PLAYER.TRANSPORT.MT.TILE_LOCATIONS+$1
	; TYA
	; CLC
	; ADC #SCREEN.ARRAY.OFFSET
	; STA PLAYER.TRANSPORT.MT.TILE_LOCATIONS+$2
	; TAY
	; DEY
	; STA PLAYER.TRANSPORT.MT.TILE_LOCATIONS+$3

	
; ;STORE TILE #S ADJACENT TO FRIGATE IN AN ARRAY. USED BY MOVEMENT_MANAGER.ASM TO APPLY COLLISION RULES
; ;
; ;The following Diagram illustrates the MT OBJECTS Tiles ($0-$3) and the adjacent tiles to be 
; ;checked for collision ($0-$7), which are mappe to TRANSPORT.MT.ADJACENT_TILES by the routine below. If any tile in the directional group (i.e. $0-$1 is the north group)
; ;then the move is treated as blocked by MOVEMENT_MANAGER.ASM	
; ;	  01
; ;  6014
; ;	 7235
; ;	  23
; ;
; ;The following routine uses the upper left tile of the MT OBJECTS as the starting point and
; ;uses offsets to calculate the screen tile #s of each of the adjacent tiles. 

	; ;NORTH GROUP
	; LDA	TRANSPORT.MT.TILE_LOCATIONS+$0
	; SEC
	; SBC #SCREEN.ARRAY.OFFSET
	; TAY
	; STY TRANSPORT.MT.ADJACENT_TILES+$0
	; INY
	; STY TRANSPORT.MT.ADJACENT_TILES+$1
	; ;EAST GROUP
	; LDY MOB.MT.TILE_LOCATIONS+$3
	; INY
	; STY TRANSPORT.MT.ADJACENT_TILES+$5
	; TYA
	; SBC #SCREEN.ARRAY.OFFSET
	; TAY
	; STY TRANSPORT.MT.ADJACENT_TILES+$4
	; ;WEST GROUP	
	; LDY	MOB.MT.TILE_LOCATIONS+$2
	; DEY 
	; STY TRANSPORT.MT.ADJACENT_TILES+$7
	; TYA
	; SBC #SCREEN.ARRAY.OFFSET
	; TAY
	; STY TRANSPORT.MT.ADJACENT_TILES+$6	
	; ;SOUTH GROUP					;SOUTH COMES LAST BECAUSE IT CLEARS THE CARRY FLAG. THIS WAY ONLY ONE SEC IS NEEDED ABOVE, SINCE NO UNDERFLOWS ARE EXPECTED
	; LDA	MOB.MT.TILE_LOCATIONS+$2
	; CLC
	; ADC #SCREEN.ARRAY.OFFSET
	; TAY
	; STY MOB.MT.ADJACENT_TILES+$2
	; INY
	; STY MOB.MT.ADJACENT_TILES+$3
	
	; JMP BOARD.EXIT
	
@END
	
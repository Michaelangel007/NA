;************************INCLUDE FILE*****************************
;(do not assemble stand-alone. For a stand-alone version of this routine see examples/rwts2)



DISK.WRITE.AUX		;====WRITES TO DISK FROM AUX MEMORY, 1 PAGE AT A TIME====
@START
;PARAMETERS: TOTAL.SECTORS, DRIVE, TRK.SRT, SEC.SRT, AUX.READ_ADDRESS.START (2), *DISK.IO.BUFFER (2)
;ENTRANCE: DIRECT
;RETURN:	
;*DISK.IO.BUFFER MUST POINT TO THE START OF A 1 PAGE MEMORY BLOCK. 
	;THIS MEMORY BLOCK ISN'T DEFINED BY THIS SUBROUTINE SO THAT OTHER MEMORY BLOCKS IN THE PROGRAM CALLING THIS 
	;SUBROUTINE CAN BE USED FOR DOUBLE DUTY. 
	
;!!!!!WARNING!!!: When writing to a disk image (as opposed to a physical floppy disk), Ciderpress will only 
		;be able to see new data written to a disk image if the disk image is first ejected from the emulator disk drive.
		;It doesn't seem to matter if the disk image is open in CiderPress when the write occurs. 


; ;DRIVER ==TEMPLATE==
		; ;SET DISK.WRITE.AUX PARAMTERES
		; LDA #$0D
		; STA TOTAL.SECTORS
		;;
		; LDA #$01
		; STA DRIVE
		;;
		; LDA #$0B
		; STA TRK.SRT   
		;;
		; LDA #$0B
		; STA SEC.SRT
		;;
		; LDA #$00
		; STA AUX.READ_ADDRESS.START				
		; LDA #$02
		; STA AUX.READ_ADDRESS.START+$1
		;;
		; LDA #ZONE_TOOLS.OUTPUT_BUFFER		;START ADDRESS OF ANY AVAILABLE MEMORY BLOCK 1 PAGE IN SIZE
		; STA DISK.IO.BUFFER
		; LDA /ZONE_TOOLS.OUTPUT_BUFFER
		; STA DISK.IO.BUFFER+$1
		;;
	; JSR DISK.WRITE.AUX
	
;SETUP REQUIRED MY.RWTS VARIABLES NOT PASSED AS PARAMETERS
	LDA #$02
    STA CMD.CODE

;SETUP TRACK/SECTOR COUNTERS		
    LDA TRK.SRT   
	STA TRK.SRT.COUNTER
	STA TRK.END.COUNTER
	STA TRK.END
	
    LDA SEC.SRT
	STA SEC.SRT.COUNTER
	STA SEC.END.COUNTER
	STA SEC.END

	
.LOOP.LOAD.ENTRANCE
;INIT VARIABLES
	LDX #$00						;COUNTER:  TOTAL SECTORS READ. START AT $01 BECAUSE 1ST SECTOR IS GARBAGE DATA)

.LOOP.LOAD

;AUX MOVE SECTION

;INCREMENT AUX_MOVE COUNTERS	
	;AUX_MOVE start & end address zero page memory locations are not persistent and must be setup again before each call to AUX_MOVE
	LDA AUX.READ_ADDRESS.START					
	STA AUX_MOVE.START					;SET START ADDRESS
	LDA AUX.READ_ADDRESS.START+$1
	STA AUX_MOVE.START+$1

;16-BIT ADD	
	LDA AUX.READ_ADDRESS.START
	CLC
	ADC #$FF	
	STA AUX_MOVE.END					;SET END ADDRESS
	LDA AUX.READ_ADDRESS.START+$1
	ADC #$00
	STA AUX_MOVE.END+$1
		
	LDA DISK.IO.BUFFER
	STA AUX_MOVE.DEST
	LDA DISK.IO.BUFFER+$1
	STA AUX_MOVE.DEST+$1
			

;READ NEXT PAGE FROM AUX MEMORY
	CLC								;AUX MEMORY -> MAIN MEMORY 
	JSR AUX_MOVE

	INC AUX.READ_ADDRESS.START+$1

	
;RWTS SECTION

			
;SKIP DOS RESERVED TRACKS/SECTORS
;Note: Applecommander skips track !17 ($11) and track !18, seconds 14 & 15 ($T12,$E & $D)
;I'm almost postive this is becasue AppleCommander is writing data to the disk assuming a DOS format.
;I'm almost postive these tracks/sectors are reserved by DOS. I recall reading somethig about it in Beneath DOS
;and specifically recall the reserve space being near the middle of the disk. It was for catalog information or something. 

;DOS TRACK/SECTOR CHECKS	
	LDA TRK.SRT
	CMP #$11
	BEQ .INCREMENT.TRACK_SECTOR		;SKIP WRITE THIS PASS, BUT INCREMENT TRACK/SECTOR. DON'T INCREMENT SECTOR COUNTER
	CMP #$12
	BNE .CONTINUE
	LDA SEC.SRT
	CMP #$0E
	BEQ .INCREMENT.TRACK_SECTOR
	CMP #$0F
	BEQ .INCREMENT.TRACK_SECTOR
.CONTINUE	

	
	;my.rwts increments dest.addr so it must be set before each call
    LDA DISK.IO.BUFFER
    STA DEST.ADDR					;LO
												
    LDA DISK.IO.BUFFER+$1
    STA DEST.ADDR+$1               	;HO

				
;READ NEXT SECTOR FROM DISK
	LDA #$00						;TURN OFF DOS TRACK/SECTOR OVERRIDE
	JSR MY.RWTS

	INX 							;INCREMENT TOTAL SECTORS READ
									;NOTE: MUST COME BEFORE TRACK/SECTOR INCREMENT SO THAT DOS SKIPPED TRACKS CAN BYPASS THE SECTOR COUNTER INCREMENT, BUT STILL INCREMENT TRACK/SECTOR
	
.INCREMENT.TRACK_SECTOR			
;INCREMENT MY.RWTS COUNTERS	 (DONE AT FRONT END BECAUSE 1ST SECTOR IS GARBAGE DATA)
	INC SEC.SRT.COUNTER
	LDA SEC.SRT.COUNTER
	CMP #$10
	BCC .NO_FLIP1.1
	INC TRK.SRT.COUNTER
	LDA TRK.SRT.COUNTER
	STA TRK.SRT
	LDA #$00
	STA SEC.SRT.COUNTER
.NO_FLIP1.1
	STA SEC.SRT
	INC SEC.END.COUNTER
	LDA SEC.END.COUNTER
	CMP #$10
	BCC .NO_FLIP2.1
	INC TRK.END.COUNTER
	LDA TRK.END.COUNTER
	STA TRK.END	
	LDA #$00
	STA SEC.END.COUNTER	
.NO_FLIP2.1
	STA SEC.END
				

	CPX TOTAL.SECTORS
	BEQ .EXIT
	JMP .LOOP.LOAD

.EXIT

				; ;TROUBLESHOOTING HOOK
				; LDA TEXT
				; ; LDX #ZONE_TOOLS.OUTPUT_BUFFER
				; ; LDY /ZONE_TOOLS.OUTPUT_BUFFER
				; ; LDX #ZONE.LOOKUP.LO2
				; ; LDY /ZONE.LOOKUP.LO2
				; LDA TEXT
				; LDA $C082
				; BRK
	
	RTS
@END


DISK.READ.AUX		;====READS FROM DISK TO AUX MEMORY, 1 PAGE AT A TIME====
@START
;PARAMETERS: ACC**, TOTAL.SECTORS, DRIVE, TRK.SRT, SEC.SRT, AUX.WRITE_ADDRESS.START (2), *DISK.IO.BUFFER (2)
;ENTRANCE: DIRECT
;RETURN:	
;*DISK.IO.BUFFER MUST POINT TO THE START OF A 1 PAGE MEMORY BLOCK. 
	;THIS MEMORY BLOCK ISN'T DEFINED BY THIS SUBROUTINE SO THAT OTHER MEMORY BLOCKS IN THE PROGRAM CALLING THIS 
	;SUBROUTINE CAN BE USED FOR DOUBLE DUTY. 
;**ACC: if ACC > $00, ACC = number of sectors to skip. An example of when sectors are skipped is when reading data written to disk by AppleCommander which writes a header. 

; ;DRIVER ==TEMPLATE==
; ;INITIAL VARIABLES & COUNTERS
	; LDA #DATA.SHAPES.BUILDING.TOTAL.SECTORS
	; STA TOTAL.SECTORS
	; ;
; ;SETUP MY.RWTS VARIABLES
	; LDA #$02
    ; STA DRIVE
	; ;	
    ; LDA #DATA.SHAPES.BUILDING.START.TRACK
    ; STA TRK.SRT   
	; STA TRK.SRT.COUNTER
	; STA TRK.END
	; STA TRK.END.COUNTER
	; ;
    ; LDA #DATA.SHAPES.BUILDING.START.SECTOR
    ; STA SEC.SRT
	; STA SEC.SRT.COUNTER
	; STA SEC.END
    ; STA SEC.END.COUNTER	
	; ;
; ;SETUP AUX MEMORY DESTINATION ADDRESS
	; LDA #SHP.TBL.START.ADDRESS			;SET DESTINATION ADDRESS/LO BYTE
	; STA AUX.WRITE_ADDRESS.START			
	; STA AUX_MOVE.DEST
	; LDA /SHP.TBL.START.ADDRESS			;SET DESTINATION ADDRESS/HO BYTE
	; STA AUX.WRITE_ADDRESS.START+$1
	; STA AUX_MOVE.DEST+$1
	; ;
	; LDA #NEW.SHAPES
	; STA DISK.IO.BUFFER
	; ;
	; LDA /NEW.SHAPES
	; STA DISK.IO.BUFFER+$1
	; ;
	; LDA #$01		;skipping $01 header sector because the data to be read from disk was written to disk by Apple Commander which adds a header. 
	; JSR DISK.READ.AUX	
	
	STA TEMP ;SAVE ACC PARAMETER
	
;SETUP REQUIRED MY.RWTS VARIABLES NOT PASSED AS PARAMETERS
	LDA #$01
    STA CMD.CODE

;SETUP TRACK/SECTOR COUNTERS		
    LDA TRK.SRT   
	STA TRK.SRT.COUNTER
	STA TRK.END.COUNTER
	STA TRK.END
	
    LDA SEC.SRT
	STA SEC.SRT.COUNTER
	STA SEC.END.COUNTER
	STA SEC.END

;SKIP ANY SECTORS?
	LDA TEMP					;LOAD ACC PARAMETER
	BEQ .LOOP.LOAD.ENTRANCE		;ACC PARAMETER DOESN'T APPLY UNLESS >0
	
	;ACC > 0, SO ACC = NUMBER OF SECTORS TO SKIP.
	
	STA SAVED.ACC.LOCAL
	LDX #$00			;LOOP COUNTER
.LOOP.SECTOR.SKIP
	
	INC SEC.SRT.COUNTER
	LDA SEC.SRT.COUNTER
	CMP #$10
	BCC .NO_FLIP1.1a
	INC TRK.SRT.COUNTER
	LDA TRK.SRT.COUNTER
	STA TRK.SRT
	LDA #$00
	STA SEC.SRT.COUNTER
.NO_FLIP1.1a
	STA SEC.SRT
	INC SEC.END.COUNTER
	LDA SEC.END.COUNTER
	CMP #$10
	BCC .NO_FLIP2.1a
	INC TRK.END.COUNTER
	LDA TRK.END.COUNTER
	STA TRK.END	
	LDA #$00
	STA SEC.END.COUNTER	
.NO_FLIP2.1a
	STA SEC.END	
	
;LOOP EXIT TEST	
	INX						;INCREMENT LOOP COUNTER, WHICH IS EQUAL TO THE # OF SECTORS SKIPPED
	CPX SAVED.ACC.LOCAL		;IS THE LOOP COUNTER EQUAL TO THE NUMBER OF SECTORS THE CALLING ROUTINE WANTS SKIPPED? (PASSED IN PARAMETER ACC)
	BNE .LOOP.SECTOR.SKIP	;IF NO, CONTINUE LOOP	
	
	;**FALLS THROUGH
	
.LOOP.LOAD.ENTRANCE
;INIT VARIABLES
	LDX #$00						;COUNTER:  TOTAL SECTORS READ. START AT $01 BECAUSE 1ST SECTOR IS GARBAGE DATA)

	STX COUNTER.RWTS
	STX COUNTER.LOOP
	STX COUNTER.AUX	

.LOOP.LOAD

;RWTS SECTION
	
;SKIP DOS RESERVED TRACKS/SECTORS
;Note: Applecommander skips track !17 ($11) and track !18, seconds 14 & 15 ($T12,$E & $D)
;I'm almost postive this is becasue AppleCommander is writing data to the disk assuming a DOS format.
;I'm almost postive these tracks/sectors are reserved by DOS. I recall reading somethig about it in Beneath DOS
;and specifically recall the reserve space being near the middle of the disk. It was for catalog information or something. 

;MUST INIT FOR EACH ITERATION
	LDA #$00
	STA DOS.SKIP.SECTOR				;LOAD FLAG USED BY RWTS WRAPPER ABOVE WHEN THE CURRENT ITERATION IS A SECTOR THAT DOS SKIPS
	
;DOS TRACK/SECTOR CHECKS	
	LDA TRK.SRT
	CMP #$11
	BEQ .SKIP.SECTOR			;SKIP WRITE THIS PASS, BUT INCREMENT TRACK/SECTOR. DON'T INCREMENT SECTOR COUNTER
	CMP #$12
	BNE .CONTINUE
	LDA SEC.SRT
	CMP #$0E
	BEQ .SKIP.SECTOR
	CMP #$0F
	BEQ .SKIP.SECTOR
	JMP .CONTINUE
	
.SKIP.SECTOR	
	LDA #$01
	STA DOS.SKIP.SECTOR  		;SET FLAG TO NOTIFY THE AUX ROUTINE TO SKIP THE WRITE FOR THIS SECTOR
	JMP .INCREMENT.TRACK_SECTOR
.CONTINUE	

	
	;my.rwts increments dest.addr so it must be set before each call
    LDA DISK.IO.BUFFER
    STA DEST.ADDR					;LO
												
    LDA DISK.IO.BUFFER+$1
    STA DEST.ADDR+$1               	;HO

				
;READ NEXT SECTOR FROM DISK

	INC COUNTER.RWTS
	
	LDA #$00						;TURN OFF DOS TRACK/SECTOR OVERRIDE
	JSR MY.RWTS

	INX 							;INCREMENT TOTAL SECTORS READ
									;NOTE: MUST COME BEFORE TRACK/SECTOR INCREMENT SO THAT DOS SKIPPED TRACKS CAN BYPASS THE SECTOR COUNTER INCREMENT, BUT STILL INCREMENT TRACK/SECTOR
	
.INCREMENT.TRACK_SECTOR			
;INCREMENT MY.RWTS COUNTERS	 (DONE AT FRONT END BECAUSE 1ST SECTOR IS GARBAGE DATA)
	INC SEC.SRT.COUNTER
	LDA SEC.SRT.COUNTER
	CMP #$10
	BCC .NO_FLIP1.1
	INC TRK.SRT.COUNTER
	LDA TRK.SRT.COUNTER
	STA TRK.SRT
	LDA #$00
	STA SEC.SRT.COUNTER
.NO_FLIP1.1
	STA SEC.SRT
	INC SEC.END.COUNTER
	LDA SEC.END.COUNTER
	CMP #$10
	BCC .NO_FLIP2.1
	INC TRK.END.COUNTER
	LDA TRK.END.COUNTER
	STA TRK.END	
	LDA #$00
	STA SEC.END.COUNTER	
.NO_FLIP2.1
	STA SEC.END
				

		
;SKIP AUX_MOVE? 
	LDA DOS.SKIP.SECTOR  		;LOAD FLAG USED BY RWTS WRAPPER ABOVE WHEN THE CURRENT ITERATION IS A SECTOR THAT DOS SKIPS
	CMP #$01					;IS FLAG SET?

				; STA TEMP
				; LDA TROUBLESHOOTING.HOOK
				; CMP #$01
				; BNE .TEMP2
				; LDA TEXT
				; LDA $C082
				; BRK
; .TEMP2
				; LDA TEMP
				; CMP $01						;IS FLAG SET?
				
				
	BNE .AUX_MOVE				;IF NO, PROCEED TO AUX MOVE.
;	JMP .LOOP.LOAD				;IF YES, SKIP AUX MOVE
	JMP .EXIT_TEST				;IF YES, SKIP AUX MOVE

	
;AUX MOVE SECTION

.AUX_MOVE
;INCREMENT AUX_MOVE COUNTERS	
	;AUX_MOVE start & end address zero page memory locations are not persistent and must be setup again before each call to AUX_MOVE
	LDA DISK.IO.BUFFER					
	STA AUX_MOVE.START					;SET START ADDRESS
	LDA DISK.IO.BUFFER+$1
	STA AUX_MOVE.START+$1

;16-BIT ADD	
	LDA DISK.IO.BUFFER
	CLC
	ADC #$FF	
	STA AUX_MOVE.END					;SET END ADDRESS
	LDA DISK.IO.BUFFER+$1
	ADC #$00
	STA AUX_MOVE.END+$1
		
	LDA AUX.WRITE_ADDRESS.START
	STA AUX_MOVE.DEST
	LDA AUX.WRITE_ADDRESS.START+$1
	STA AUX_MOVE.DEST+$1
			

;WRITE NEXT PAGE FROM AUX MEMORY
	INC COUNTER.AUX	
	
	SEC								;MAIN MEMORY -> AUX MEMORY
	JSR AUX_MOVE

	INC AUX.WRITE_ADDRESS.START+$1

		
	

.EXIT_TEST
	INC COUNTER.LOOP

	STA TEMP
	CPX #$4E
	BNE .TEMP
	LDA TROUBLESHOOTING.HOOK
	CMP #$01
	BNE .TEMP
	LDA TEXT
	LDA $C082

	LDA COUNTER.RWTS
	LDX COUNTER.AUX
	LDY COUNTER.LOOP
	; LDX AUX.WRITE_ADDRESS.START
	; LDY AUX.WRITE_ADDRESS.START+$1
	
	BRK
.TEMP
	LDA TEMP

	
	CPX TOTAL.SECTORS
	BEQ .EXIT
	JMP .LOOP.LOAD

.EXIT

		; LDA TEXT
		; LDA $C082
		; BRK
		
				; ;TROUBLESHOOTING HOOK
				; LDA TEXT
				; ; LDX #ZONE_TOOLS.OUTPUT_BUFFER
				; ; LDY /ZONE_TOOLS.OUTPUT_BUFFER
				; ; LDX #ZONE.LOOKUP.LO2
				; ; LDY /ZONE.LOOKUP.LO2
				; LDA TEXT
				; LDA $C082
				; BRK
	
	RTS
	
	
@END


				
;==MY.RWTS===
;See Routines_my.rwts or for Nox Archaist, see
;Custom.Boot1.ASM.


;======DEFINE VARIABLES


AUX.READ_ADDRESS.START 		.BS $2
AUX.WRITE_ADDRESS.START		.EQ AUX.READ_ADDRESS.START
DISK.IO.BUFFER				.BS $2
DOS.SKIP.SECTOR				.BS $1

;USED BY LOOP FOR LOADING IN DATA FILES
SHP.TBL.ADDRESS.COUNTER						.BS $2
TRK.SRT.COUNTER								.BS $1
SEC.SRT.COUNTER								.BS $1

TRK.END.COUNTER								.BS $1
SEC.END.COUNTER								.BS $1
TOTAL.SECTORS								.BS $1 


COUNTER.RWTS		.BS $1
COUNTER.LOOP		.BS $1
COUNTER.AUX			.BS $1

;CMD.CODE	defined in MY.RWTS
;DRIVE		defined in MY.RWTS
;TRK.SRT 	defined in MY.RWTS
;SEC.SRT 	defined in MY.RWTS

;AUX_MOVE.START defined in Routines_General
;AUX_MOVE.END	defined in Routines_General
;AUX_MOVE.DEST	defined in Routines_General
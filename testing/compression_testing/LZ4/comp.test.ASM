				.CR     6502            Use 6502 overlay
				.OR		$2000			**Always put before .TF directive and never use again in program
				.TF     COMP.PROG.BIN,BIN
				.EF		errors
				.LF		C:\MY_CODE\LIST
;				.LI 	OFF				Switches the assembler machine code conversion listing off so errors are easier to see				
;				.IN 	C:\MY_CODE\INCLUDES_LIBS\routines_common

;=====================EXAMPLE DOCUMENTATION====================================
;
;This program demos how to unpack data that was packed using LZ4.EXE on a PC. 
;
;LZ4.EXE (PC PACKER) adds an 11 byte header to front of the packed data and an 8 byte trailer, both of which must be removed
;This is performed by .REMOVE.HEADER below.
;
;The packed data is loaded from disk (.LOAD.PACKED.DATA) from disk using Peter's ProDOS IO driver (he calls it opendir).
;
;The unpack subroutine (written by Peter Ferrie), is at $B000, placed there as a binary
;include of LZ4.BIN, which was build using ACME cross-assembler from L4DSTSRC.S
;
;unpack's parameteres are simple. Just specify the address of the packed data and the destination address for the unpacked data.
;
;===NOTES ON OTHER FILES===
;L4DSTSRC.S is a modified version of the code on Peter's website. He modified it to be compatible with ACME 0.90 for WIN32 as 0.91 (his target platform) is DOS only.
;The only change I had to make was to set paksize = 0 (it was originally $1234, and Peter said to set it to 0 when it's called as a subroutine rather than 
;used as a self-extracting program that ships with packed data, which is what paksize refers to...the packed data that ships with the program)
;
;L4DSTSRC.S is designed for the packed data to reside at a higher address in memory than the unpacked data destination address.
;Peter has a different version (L4SRCDST.S) that supports the opposite, a packed data address lower in memory than the unpacked destination address. 
;However, to use it, I would need to ask him to make it compatible with ACME 0.90. 
;
;LZ4.EXE is a free download online.
;
;-Disk Image Files
;TEST.UNPACKED.D		The unpacked binary file generated by a different SBASM program. This is the file which gets packed by LZ4.EXE on the PC. I added it to the disk image so I could open it with CiderPress and compare it to the unpacked output in memory ($7000) generated by this program. It isn't functionally needed.
;PACKED.DATA 			The packed binary file generated by LZ4.EXE on the PC. This is the file loaded by PRODOS.IO (/aka opendir) to $9000, before the header and trailer are stripped off and it is moved to $8000
;LZ4.BIN				The LZ4 unpacker written by Peter Ferrie (subroutine unpack), which is loaded at $B000 in this program
;COMP.PROG				The main test program (this file)
;NOX.SYSTEM				ProDOS Bootloader
;NOXARCH.MAIN			The file NOX.SYSTEM hands off control to, which is limited in size, so it's job is to load COMP.PROG. 
;
;
;-Source Files (.ASM)
;COMP.PROG				The main test program (this file)
;COMP.TEST.BOOT.ASM		The boot file which loads COMP.PROG. AppleCommander writes it to the disk image as NOXARCH.MAIN. See NOXARCH.MAIN under disk image files for more details.
;=================================================================================

COMP.TEST.START

	
.LOAD.PACKED.DATA
;set command type (READ | WRITE)
;	lda #$81 ;([$1=read drive1, | $2=write drive1], [$81=read drive2 | $82=write drive2])
	lda #$1 ;([$1=read drive1, | $2=write drive1], [$81=read drive2 | $82=write drive2])
	sta reqcmd
	JSR DRIVER.READ


.REMOVE.HEADER
;REMOVE HEADER FROM PACKED DATA
;Note: LZ4.EXE (PC PACKER) adds an !11 byte header to front of the packed data and an 8 byte trailer, both of which must be removed
		; LDA #$0B
		; STA COPY.FROM_START
		; LDA #$90
		; STA COPY.FROM_START+$1
		; LDA #$65
		; STA COPY.FROM_END
		; LDA #$91
		; STA COPY.FROM_END+$1
		; LDA #$00
		; STA COPY.TO
		; LDA #$80
		; STA COPY.TO+$1
		
		;JSR MEMORY.COPY
	
.TEST.UNPACK
	lda     #$02			;lo byte (start_of_packed_data)
	sta     src
	lda     #$90			;ho byte (start_of_packed_data)
	sta     src+1

	lda     #$0E			;lo byte (end_of_packed_data+1) ;i.e. first byte after end of packed data
	sta     end
	lda     #$90			;ho byte (end_of_packed_data+1) ;i.e. first byte after end of packed data
	sta     end+1

	lda     #$00			;lo byte (place_to_unpack_data)
	sta     dst
	lda     #$70			;ho byte (place_to_unpack_data)
	sta     dst+1

	jsr unpack

	
	LDA $C082				;enable ROM, disable BSR	
	LDA STATUS
	LDX #$EE
	LDY #$AA
	BRK
;
;	
DRIVER.READ
;set destination memory address
	lda #$00
	sta ldrlo
	lda #$90
	sta ldrhi

;set read length (bytes)
	lda #$FF				;read length (LO byte). Set to $FFFF to read entire file. It's ok if the read length is > file size
	sta sizelo	
	lda #$FF				;read length (HO byte). Set to $FFFF to read entire file. It's ok if the read length is > file size
	sta sizehi
	
;set filename to read from	
	lda #PACKED.DATA	;load LO address
	sta namlo
	lda /PACKED.DATA		;load HO address
	sta namhi

		LDA #$00	;PARM: $00=main, $01=aux
	JSR PRODOS.IO

	
	RTS


;======(TEST) DEFINE VARIBLES======

; file.to.read  .AZ #$0A,/DUMMY.FILE/	;ascii array, using LO values. Filename is limited to !15 characters. Hex value after .AZ is the char quantity. 
; file.to.write .AZ #$0A,/DUMMY.FILE/	;ascii array, using LO values. Filename is limited to !15 characters. Hex value after .AZ is the char quantity. 
;DATA.SPR.SURF	.AZ #$0D,/DATA.SPR.SURF/	;ascii array, using LO values. Filename is limited to !15 characters. Hex value after .AZ is the char quantity. 
;DATA.SHP.SURF2 	.AZ #$0D,/DATA.SHP.SURF/	;ascii array, using LO values. Filename is limited to !15 characters. Hex value after .AZ is the char quantity. 
PACKED.DATA	.AZ #$0B,/PACKED.DATA/	;ascii array, using LO values. Filename is limited to !15 characters. Hex value after .AZ is the char quantity. 

;TEXT SCREEN VARIABLES 
CLEAR.TEXT.SCREEN	.EQ $FC58
COUT.ADDRESS		.EQ $FDED
;PREP.BRK			.BS $1


;unpacker variables, no need to change these
src	=	$0
dst	=	$2
end	=	$4

unpack	= $B000	;LZ4 unpacker subroutine


animation.update .eq $B000
generate.debug.log .eq $B100
USE.PAGE			 	.BS $1

DRAW.START_BYTE 	.BS $1
DRAW.STOP_BYTE		.BS $1
DRAW.START_LINE		.BS $1
DRAW.STOP_LINE		.BS $1


HRCG.SIZE.MINUS_1		.EQ $2FF	;#CONSTANT. Size of character set data, in bytes, minus 1. The minus 1 is so that is can be used to dynamically calculate the memory address of the last byte of data. 
	
HRCG.AUX.START			.EQ $5900	;#CONSTANT; Starting memory address in aux memory where Hi Res character set is stored until needed to print a character on screen
HRCG.AUX.END			.EQ $5BFF	;#CONSTANT; Starting memory address in aux memory where Hi Res character set is stored until needed to print a character on screen

HRCG.MAIN.START			.EQ $0C00	;#CONSTANT; Starting memory address in main memory where Hi Res character set is swaped in, when a character needs to be printed to screen
HRCG.MAIN.END			.EQ $0EFF	;#CONSTANT; Starting memory address in main memory where Hi Res character set is swaped in, when a character needs to be printed to screen

HRCG.SHAPE.OFFSET		.EQ $E0		;Stores the offset used to calculate the exact starting address of the shape table for a specific character, using the ASCII value of the character
HRCG.SHAPE.SIZE			.EQ $08		;#CONSTANT; the number of bytes in each character's shape table 

HRCG.BUFFER				.BS $8		;Buffere where a single character copies from aux memory is stored. The HRCG controller at $300 looks in this buffer for the bit map graphics data for all characters it is asked to print. 



;FORMAT IS FILENAME LENGTH (BYTES), FILENAME. LENGTH IS RAW HEX NUMBER, NOT ASCII VALUE

;file.to.read .EQ $6100
	
;======INCLUDE FILES======


;				.IN 	C:\MY_CODE\testing\prodos_testing\OpenDir.test.ASM
;				.IN 	C:\MY_CODE\TEMP\OpenDir.TEST.ASM
			
				;My libraries
				.IN 	C:\MY_CODE\INCLUDES_LIBS\routines_graphics				
				.IN 	C:\MY_CODE\INCLUDES_LIBS\routines_text
				.IN 	C:\MY_CODE\INCLUDES_LIBS\routines_math
				.IN 	C:\MY_CODE\INCLUDES_LIBS\routines_general
				.IN 	C:\MY_CODE\INCLUDES_LIBS\ptools.ASM

;LOAD LZ4 DRIVER (unpacker)
		.NO $B000, $00
		
				.BI C:\MY_CODE\COMPRESSION\NPC.SPEECH.TEXT\lz4.b000.bin,BIN	;unpack driver for LZ4 compression
				
				
				
;seperate target files	
				.IN 	C:\MY_CODE\TESTING\COMPRESSION_TESTING\LZ4\COMP.TEST.BOOT.ASM

;************************INCLUDE FILE*****************************
;(do not assemble stand-alone. For a stand-alone version of this routine see examples/rwts2)


;CALC.MAP.INDEX NOP
	
;THIS GOES IN THE DRIVER FOR NOW, LATER IN THE WORLD INIT ROUTINE	

;	LDX #$00
;	LDY #$00
	

;	LDA #GMAP.ROW0
;	STA GMAP.ADDRESS.INDEX
;	LDA /GMAP.ROW0
;	STA GMAP.ADDRESS.INDEX+$1
	
;	LDA #GMAP.ROW1
;	STA GMAP.ADDRESS.INDEX+$2
;	LDA /GMAP.ROW1
;	STA GMAP.ADDRESS.INDEX+$3
	
;	LDA #GMAP.ROW2
;	STA GMAP.ADDRESS.INDEX+$4
;	LDA /GMAP.ROW2
;	STA GMAP.ADDRESS.INDEX+$5




;==================================READ FROM HERE=======================

;the stuff above relates to my original idea on how to create a permenant index for the 
;GMAP.TILE.DATA array. I abandoned the idea for the one described below, but I'm keeping
;the original info around until I've got screen movement working at an acceptable speed. 


;**OPT** NOTE: I think an index can created. Not by the above method. Instead, in the world init routine, loop through the compressed
;map array and build an index of at least the row starting positions. store it in an array in the format 
;<uncompressed position>, <compressed index>.....so when doing the lookup routine, I can loop through the index array to find 
;the uncompressed position I'm looking for, and use the compressed index value to start the loop below at a much more
;advanced location. perhaps for the next row, the iteration in the index array can even pickup where it left off...sinc the next
;row by definition would be forward in the compressed map array, not backward.  
;
;I don't think I need to control the location in memory of the compressed tile data array, because it will be one big array.

;**OPT** (READ FIRST) another option is just to pass a parameter to TILE.LOOKUP.INDEX allowing it to just pick up 
;where it left off, using the values in GMAP.TALLY, GMAP.ADDRESS.INDEX, ETC. (JUST LIKE TILE.LOOKING.SINGLE DOES)
;SINCE A SCREEN DRAW INVOLES ROWS WHERE THE NEXT ROW IS ALWAYS FURTHER INTO THE ARRAY THAN THE LAST ROW, THIS REALLY
;SEEMS LIKE IT WOULD BE ALMOST AS EFFECTIVE IF NOT AS EFFECTIVE AS A INDEX OF THE STARTING POINT FOR EACH MAP ROW. 



;TESTED STATUS OF THIS VERSION: 16-BIT UPGRADE COMPLETE. 
;COMPLETE (/w 8-bit and 16-bit gmap.lookup value): LOAD ROW0 /w 4 scenario test, LOAD ROW1 with 4 scenario test. 
;
;the 4 scenarios are: 1) no overflow starting position, no overflow ending position, 2) overflow start, no overflow end 3) no overflow start, overflow end 4) overflow start, overflow end


TILE.LOOKUP.SCREEN		;===========LOAD ENTIRE SCREEN OF TILES===========
;PARAMETERS: GMAP
;RETURN: SCREEN.TILE.DATA
;ENTRANCE: DIRECT


.INIT.MAP
	LDA GMAP					;LOAD TILE_ID OF CURRENT MAP POSITION (CENTER/PLAYER TILE)
	STA OP1
	LDA GMAP+$1
	STA OP1+$1
	
	LDA #OFFSET.SCREEN			;CALCULATE TILE_ID OF TILE IN UPPER LEFT CORNER OF SCREEN
	STA OP2
	LDA /OFFSET.SCREEN
	STA OP2+$1
	
	JSR SBC.16					;GMAP(2) - SCREEN.OFFSET.LO/HO (2)
			
	LDA RESULT					;SAVE TILE_ID OF UPPER LEFT SCREEN TILE
	STA SMAP
	STA SMAP.CURRENT
	LDA RESULT+$1
	STA SMAP+$1
	STA SMAP.CURRENT+$1

	
;	LDA GMAP					;LOAD TILE_ID OF CURRENT MAP POSITION (CENTER/PLAYER TILE)
;	STA OP1
;	LDA GMAP+$1
;	STA OP1+$1
	
;	LDA #OFFSET.SCREEN.LR			;CALCULATE TILE_ID OF TILE IN UPPER LEFT CORNER OF SCREEN
;	STA OP2
;	LDA /OFFSET.SCREEN.LR
;	STA OP2+$1
	
;	JSR ADC.16					;GMAP(2) - SCREEN.OFFSET.LO/HO (2)
			
;	LDA RESULT					;SAVE TILE_ID OF LOWER RIGHT SCREEN TILE
;	STA SCREEN.LAST.TILE
;	LDA RESULT+$1
;	STA SCREEN.LAST.TILE+$1
	
;INIT COUNTERS
	LDX #$00					;ALWAYS INIT X-REG TO $00 BEFORE CALLING TILE.LOOKUP.INDEX
	LDA #$00
	STA SCREEN.TILE.COUNTER		
.LOAD.LOOP	
	LDA SMAP.CURRENT			;LOAD UPPER LEFT SCREEN TILE AS START OF ROW
	STA	GMAP.LOOKUP
	LDA SMAP.CURRENT+$1
	STA GMAP.LOOKUP+$1
	
	JSR TILE.LOOKUP.INDEX		;LOAD NEXT ROW
	JSR TILE.LOOKUP.ROW
			

;INCREMENT COUNTERS
	
	LDA SMAP.CURRENT					
	STA OP1
	LDA SMAP.CURRENT+$1
	STA OP1+$1
	
	LDA #OFFSET.DOWN			;CALCULATE TILE_ID OF TILE IN UPPER LEFT CORNER OF SCREEN
	STA OP2
	LDA #$00
	STA OP2+$1
	
	JSR ADC.16					;GMAP(2) - SCREEN.OFFSET.LO/HO (2)
			
	LDA RESULT					;SAVE TILE_ID OF UPPER LEFT SCREEN TILE
	STA SMAP.CURRENT
	LDA RESULT+$1
	STA SMAP.CURRENT+$1
	
	INC SCREEN.TILE.COUNTER		;COUNTS THE # OF ROWS LOADED
	
	LDA SCREEN.TILE.COUNTER		;# OF TILES IN A COLUMN == # OF ROWS ON THE SCREEN
	CMP #SCREEN.COLUMN.SIZE		;LAST ROW? 
	BNE .LOAD.LOOP				;IF NO, LOAD NEXT ROW
	
	RTS							;IF YES, EXIT
	

TILE.LOOKUP.INDEX		;=============????============
;PARAMETERS: GMAP.LOOKUP(2)
;RETURN: GMAP.INDEX, GMAP.OVERFLOW (these are used by related routines such as TILE.LOOKUP.ROW, TILE.LOOKUP.SINGLE)
;REQUIREMENTS: X-REG MUST BE INIT TO #$00 BEFORE CALL TO TILE.LOOKUP.INDEX	 	
;ENTRANCE: DIRECT

;WARNING: GMAP.LOOKUP is a 16-bit number. If using this routine via a driver with an 8 bit number make sure to init
;GMAP.LOOKUP+$1 to $00.

;TROUBLESHOOTING:
;
;Use TROUBLESHOOTING HOOK 1 (search for this text in this file), which uses
;GMAP.LOOKUP to trigger a BRK. Y-REG can also be a useful secondary trigger. 
;
;Resources mentioned are in the in the Game map development spreadsheet
;Also see data reference c:\mycode\load_reference_tool, I had forgotten 
;about it when originally writing this documentation. 
;
;The tile qty numbers to use as the basis for the GMAP.LOOKUP are in Global Tile # Map.
;remember for tile_qty, use 1 less than the tile # you want to lookup. 
;
;GMAP.INDEX.LO/HO will correspond to the element of the array that 
;TILE.LOOKUP.ROW would have loaded if the BRK wasn't inserted. 
;Use the Test Map Index worksheet to verify the gmap.index.lo/ho value for any given tile_qty, or vice versa.   
;
;X-REG isn't re-initialized unless the calling routine (such as TILE.LOOKUP.SCREEN) does so. 
;Accordingly, X-REG refers to the tile # on the view screen, as documented in Matrix Map worksheet 
;(the array map is on top, scroll down to find the SCREEN.TILE.ARRAY map)
;
;Y-REG is initalized on each call to TILE.LOOKUP.ROW, and is incremented two in each .copy.loop as it tracks the tile_qty/tile_type pairs.
;
;GMAP.ADDRESS.INDEX will point to the memory address that TILE.LOOKUP.ROW is reading from. Y-REG is the index added to this base address that enables
;TILE.LOOKUP.ROW to iterate through the GMAP.TILE.DATA array. 
;
;SCREEN.TILE.ARRAY is mapped to each screen row on the Screen Map chart in the Map Matrix worksheet. 
;Check the definition of SCREEN.TILE.ARRAY to see if it is still in the memory address range described. If not, redefine 
;it to the start of any super page to most easily use the chart. 




;**OPT** SPEED. MAKE TILE.LOOKUP.INDEX AND TILE.LOOKUP.ROW ONE ROUTINE, WITH TWO ENTRY POINTS (I.E. IF TILE.LOOKUP.INDEX)
;IS CALLED, IT AUTOMATICALLY FALLS THROUGH TO TILE.LOOKUP.ROW. THIS WOULD SAVE A SEPERATE JSR TO TILE.LOOKUP.ROW 
;OR MAYBE THE TOP LEVEL ROUTINE SHOULD BE CALLED TILE.LOOKUP.ROW, I'M NOT SURE THERE WOULD EVER BE A POINT
;TO DOING THE ROW LOOKUP WITHOUT THE INDEX LOOKUP FIRST. 



;SAVE REGISTERES
	TYA
	PHA
	
;init variables
	
	LDA #$00
	TAY
	STA GMAP.TALLY
	STA GMAP.TALLY+$1

	STA GMAP.INDEX.HO
	STA GMAP.INDEX.OVERFLOW
	
	LDA #GMAP.TILE.DATA
	STA GMAP.ADDRESS.INDEX
	LDA /GMAP.TILE.DATA
	STA GMAP.ADDRESS.INDEX+$1
	


;Identify the position in the compressed data associated with the uncompressed position lookup	
.LOOP.LOOKUP
	LDA (GMAP.ADDRESS.INDEX),Y				;**OPT** TO OPTIMIZE FOR SPEED, MAY BE ABLE TO SETUP A BRANCH SO THAT THE 16-BIT ADD IS ONLY DONE WHEN A 16-BIT VALUE IS PRESENT IN OP1 OR OP2. 
	STA OP1
	LDA GMAP.TALLY
	STA OP2
	
	LDA GMAP.TALLY+$1
	STA OP2+$1
	LDA #$00
	STA OP1+$1
	
	JSR ADC.16					;GMAP.TILE.DATA,X + GMAP.TALLY(2)

		
.TEMP2
	
	LDA RESULT
	STA GMAP.TALLY
	STA OP1
	LDA RESULT+$1
	STA GMAP.TALLY+$1
	STA OP1+$1
	
	
	LDA GMAP.LOOKUP
	STA OP2
	LDA GMAP.LOOKUP+$1
	STA OP2+$1
	JSR IGRE.16					;GMAP.TALLY(2) IGRE GMAP.LOOKUP(2)		
	

.TEMP
		
	BCS .SAVE.INDEX

.TEMP5

	INY							;ADVANCE TO NEXT TILE PAIR. X-REG IS THE LO BYTE OF GMAP.INDEX FOR THE DURATION OF THIS LOOP
	INY							;EVEN THOUGH IT'S A 2 BYTE INX, IT WILL ADVANCE FROM !254 TO 0, THUS BNE WILL DETECT THE FLIP. 
	BNE .NO.FLIP
	INC GMAP.ADDRESS.INDEX+$1
	INC GMAP.INDEX.HO			;**OPT** (a counter to help troubleshooting, comment out this line at least. If removed, also remove the definition for GMAP.INDEX.HO and GMAP.INDEX.LO. There are 3 lines like this in the program, two for HO and one for LO. 
.NO.FLIP
		 
		
	JMP .LOOP.LOOKUP	
	
.SAVE.INDEX
			;CPX #$11
			;BNE .TEMP6
			;LDA TEXT
			;LDA PAGE1
			;BRK
.TEMP6
	
	JSR SBC.16						;GMAP.TALLY(2) - GMAP.LOOKUP(2)

	
	LDA RESULT	
	CMP #$00						;USING 16-BIT BECAUSE PRIOR SBC.16 CALCULATION SHOULD ALWAYS RESULT IN AN 8-BIT VALUE

	BEQ	.NO.INDEX.OVERFLOW			;OVERFLOW? 
		
		
	LDA RESULT
	STA TEMP						;# OF TILES COMPRESSED AT GMAP.INDEX BEYOND WHAT IS NEEDED FOR GMAP.LOOKUP
	
	LDA (GMAP.ADDRESS.INDEX),Y
	SEC								;**OPT** remove if I'm not going to check for overflow error?
	SBC TEMP
	STA GMAP.INDEX.OVERFLOW			;# OF TILES MORE THAN WHAT SHOULD BE USED IN INDEX POSITION	
			
	JMP .EXIT						;IF INDEX OVERFLOW, EXIT (leave X index as-is so TILE.LOOKUP.ROW can parse out overflow tiles)

.NO.INDEX.OVERFLOW
	
	STA GMAP.INDEX.OVERFLOW			;SET INDEX OVERFLOW TO $00 ($00 SHOULD BE IN ACC ALREADY SINCE BRANCH TO GET HERE WAS BEQ)
	
	INY								;IF NO INDEX OVERFLOW, INCREMENT X INDEX TO NEXT TILE DATA PAIR (tile qty, tile type)
	INY								;ADVANCE TO NEXT TILE PAIR. X-REG IS THE LO BYTE OF GMAP.INDEX FOR THE DURATION OF THIS LOOP. ;EVEN THOUGH IT'S A 2 BYTE INX, IT WILL ADVANCE FROM !254 TO 0, THUS BNE WILL DETECT THE FLIP. 
    BNE .NO.FLIP2
	INC GMAP.ADDRESS.INDEX+$1
	INC GMAP.INDEX.HO			;**OPT** (a counter to help troubleshooting, comment out this line at least. If removed, also remove the definition for GMAP.INDEX.HO and GMAP.INDEX.LO. There are 3 lines like this in the program, two for HO and one for LO. 
.NO.FLIP2
	
	
.EXIT	
	STY GMAP.INDEX.LO					;**OPT** (a counter to help troubleshooting, comment out this line at least. If removed, also remove the definition for GMAP.INDEX.HO and GMAP.INDEX.LO. There are 3 lines like this in the program, two for HO and one for LO. 


	LDA	GMAP.ADDRESS.INDEX	
	STA OP1			
	LDA	GMAP.ADDRESS.INDEX+$1	
	STA OP1+$1							
	
	STY OP2								;Y-REG WAS THE LO BYTE COUNTER OF GMAP.ADDRESS.INDEX. GMAP.ADDRESS.INDEX+$1 (HO) IS INCREMENTED AS Y-REG FLIPS TO $00 DURING THIS ROUTINE. 
	LDA #$00
	STA OP2+$1
	JSR ADC.16							;GMAP.ADDRESS.INDEX (2) + Y-REG (1)
	
	LDA RESULT
	STA GMAP.ADDRESS.INDEX				;THIS WILL BE USED AS THE STARTING POINT FOR ITERATING THROUGH THE GMAP.TILE.DATA ARRAY IN TILES.LOOKUP.ROW FOR COPYING TILES TO THE SCREEN.TILE.DATA ARRAY
	LDA RESULT+$1
	STA GMAP.ADDRESS.INDEX+$1

;RESTORE REGISTERES
	PLA
	TAY
			
	RTS


	
TILE.LOOKUP.ROW 		 ;=============????============
;PARAMETERS
;REQUIREMENTS: MUST BE PRECEDED BY TILE.LOOKUP, BUT THEN CAN BE REPEATED TO 
;				OBTAIN ROWS IN SEQUENCE. 
;			 	X-REG MUST BE INIT TO #$00 BEFORE CALL TO TILE.LOOKUP
;ENTRANCE: DIRECT, WITH IMMEDIATE PREREQUISTE CALL TO TILE.LOOKUP.INDEX

;SAVE REGISTERS
	TYA
	PHA
	
;init counters	
	LDA #$00		
 	STA GMAP.EXPAND.TALLY
	STA TILE.COUNTER
	TAY
	
;get a compressed tile type pair
.GET.PAIR	

	
	LDA (GMAP.ADDRESS.INDEX),Y			;# OF TILES
	STA GMAP.INDEX.QUANTITY
	SEC
	SBC GMAP.INDEX.OVERFLOW			;IF THERE WAS AN INDEX OVERFLOW WHEN CALCULATING THE INDEX, SUBTRACT IT FROM THE TILE QTY.
	STA GMAP.INDEX.QUANTITY
	PHA						;push GMAP.INDEX.QUANTITY to the stack
	LDA #$00				
	STA GMAP.INDEX.OVERFLOW	
	PLA						;pull GMAP.INDEX.QUANTITY from the stack
	JMP .FIRST.ENTRY.ONLY
	
.GET.PAIR.LOOP
	LDA (GMAP.ADDRESS.INDEX),Y			;LOAD # OF TILES
	STA GMAP.INDEX.QUANTITY
.FIRST.ENTRY.ONLY	
	CLC
	ADC GMAP.EXPAND.TALLY			;KEEP A TALLY OF THE NUMBER OF TILES READ IN FROM THE COMPRESSED DATA. WE DON'T WANT TO COPY TOO MANY TO THE SCREEN.TILE.DATA ARRAY
	STA	GMAP.EXPAND.TALLY
	BCS .ERROR						;Exit to .ERROR if result of ADC is > 255
		
	LDA #SCREEN.ROW.SIZE
	CMP GMAP.EXPAND.TALLY 			;DO WE HAVE MORE THAN A FULL ROW OF TILES THIS CYCLE? (I.E. OVERFLOW)
	BCS .COPY						;IF NO, PROCEED TO COPY TILES TO SCREEN.TILE.DATA 	

	LDA GMAP.EXPAND.TALLY			;IF YES, DECREASE GMAP.INDEX.QUANTITY SO WE ONLY GET A FULL ROW OF TILES
	SEC
	SBC #SCREEN.ROW.SIZE
	STA TEMP
	LDA GMAP.INDEX.QUANTITY	
	SEC								;**OPT** ARE THESE SEC'S REALLY NEEDED IF I'M CONFIDENT THERE WILL BE NO SUBTRACTION UNDERFLOW?
	SBC TEMP
	STA GMAP.INDEX.QUANTITY
	STA GMAP.INDEX.OVERFLOW			;THE # OF TILES FOR THE LAST COPY FOR THIS ROW == THE NUMBER OF TILES TO SKIP IN THIS INDEX POSITION WHEN READING IN THE NEXT ROW
			
			
.COPY				
			;TROUBLESHOOTING HOOK 1
			;LDA GMAP.LOOKUP
			;CMP #$80
			;BNE .TEMP2
			;CPY #$00
			;BNE .TEMP2
			;LDA TEXT
			;LDA PAGE1
			;BRK
.TEMP2
	INY									;TEMPORARILY INCREMENT Y SO WE CAN ACCESS TILE TYPE
	LDA (GMAP.ADDRESS.INDEX),Y			;TILE TYPE
	DEY									;RETURN Y TO ORIGINAL VALUE FOR THIS ITERATION
.COPY.LOOP
;	INY									;TEMPORARILY INCREMENT Y SO WE CAN ACCESS TILE TYPE
;	LDA (GMAP.ADDRESS.INDEX),Y			;TILE TYPE
;	DEY	
	STA SCREEN.TILE.DATA,X

			
.TEMP

	INX
	INC TILE.COUNTER
		
	DEC GMAP.INDEX.QUANTITY
	BNE .COPY.LOOP

	
	LDA TILE.COUNTER
	CMP #SCREEN.ROW.SIZE			;HAVE A FULL ROW OF TILES BEEN COPIED?
	BCS .EXIT						;IF YES, EXIT (BCS: is Y-reg >= CPY operand)
	

	INY								;IF NO, ADVANCE TO NEXT TILE PAIR AND REPEAT
	INY
	JMP .GET.PAIR.LOOP
	
.EXIT
		
		
	LDA GMAP.INDEX.OVERFLOW			;IS THERE AN INDEX OVERFLOW IN THE LAST ELEMENT OF THE ARRAY LOADED
	BNE .INDEX.OVERFLOW			;IF YES, EXIT WITH INDEX COUNTER AS-IS SO THE OVERFLOW IS PROCESSED IN NEXT CALL OF THIS ROUTINE 
	INY								;IF NO, INCREMENT INDEX BY TWO TO GET NEXT TILE PAIR IF THIS ROUTINE IS CALLED AGAIN
	INY								
.INDEX.OVERFLOW	
	
	;**OPT** I JUST REMEMBERED THAT THE ARRAY ELEMENTS ARE ONLY SEQUENTIAL HORIZONTALLY, NOT VERTICALLY
	;THUS WE CAN'T CALL THIS ROUTINE OVER AND OVER TO GET THE ROWS OF TILES FOR THE SCREEN. EACH ROW
	;MUST BE OBTAINED VIA A CALL TO TILE.LOOKUP AND THEN TO THIS ROUTINE (TILE.LOOKUP.NEXT, PROBABLY TO
	;BE RENAMED TILE.LOOKUP.ROW IN THE FUTURE). THIS, WE DON'T NEED TO WORRY ABOUT PASSING ON AN OVERFLOW
	;TO THE NEXT ITERATION. THUS, THE CODE CAN PROBABLY JUST HAVE .EXIT AND THEN RTS. 
	
	
	;NOTE: ORIGINAL PLAN FOR UPDATING INDEX SO THIS ROUTINE COULD BE CALLED AGAIN TO GET THE NEXT ROW. 
	;I THINK WHAT IS NEEDED HERE IS A REVERSE OF THE INITIAL CALC FOR BASE ADDRESS
	;ADD THE LO TO THE GMAP.ADDRESS.INDEX AND IF THERE IS AN OVERFLOW, INC GMAP.ADDRESS.INDEX+$1. 
	;THE VALUES SHOULD END UP IN GMAP.INDEX SO THEY CAN GET LOADED IN ON NEXT CALL TO THIS ROUTINE.
	;I CAN PROBABLY ALSO REMOVE THE "STA GMAP.INDEX.OVERFLOW" IN .GET.PAIR.LOOP SINCE WE DON'T CARE
	;ABOUT THE OVERFLOW FOR THE ITERATION. 
	;
	;I DID WRITE SOME 8-BIT CODE TO HANDLE AN OVERLFOW AT THE END, SEE TEST3.4STABLE FOR THAT CODE. 

;RESTORE REGISTERS
	PLA
	TAY
	
	RTS
	
.ERROR
	;.GET.PAIR had an ADC overflow
	
	BRK


TILE.LOOKUP.COLUMN	;======================LOOKUP TILE_TYPE FOR A COLUMN OF TILES=================
;PARAMETERS: GMAP.LOOKUP(2)
;RETURN: NONE	
;ENTRANCE: DIRECT

;WARNING: THERE COULD BE PROBLEMS CALLING THIS ROUTINE MORE THAN ONCE UNLESS GMAP.LOOKUP VALUE IS
;SET DIRECTLY (I.E. VIA LDA/STA, NOT INCREMENTED) PRIOR TO THE SUBSEQUENT CALLS. OTHERWISE THE 1 TILE ADJUSMENT
;TO GMAP.LOOKUP BEING DONE IN THE NEXT FEW LINES OF CODE WOULD END UP BECOMING CUMMULATIVE. 
	
	LDX #$00

	;LDA #OFFSET.DOWN	
	
	INC GMAP.LOOKUP		;THIS IS TO ADJUST FOR A DIFFERENCE IN HOW TILE.LOOKUP.SINGLE TREATS THE GMAP.TALLY.LOOKUP VALUE, VS. HOW THE TILE.LOOKUP.INDEX ROUTINE DOES IT. IT'S POSSIBLE TO GET THE TWO ROUTINE TO CONFORM, BUT THAT WOULD TAKE MANY MORE INSTRUCTIONS THEN JUST THE ONE "INC" ON THIS LINE.  
	BNE .NOFLIP
	INC GMAP.LOOKUP+$1
.NOFLIP

	LDA #$01 			;**OPT** LEAVE UNTIL FINAL, THIS CAN BE REMOVED IF ACC > $00 BEFORE ENTERING .LOOP. LDA = #$01 SO FIRST ITERATION OF TILE.LOOKUP.SINGLE WILL CALCULATE THE INDEX TO GMAP.TILE.DATA
	
	
.LOOP	
	JSR TILE.LOOKUP.SINGLE	
	STA SCREEN.TILE.DATA,X		;*CLARITY* RENAME THIS VARIABLE TO SCREEN.TILE.DATA SO IT DOESN'T IMPLY ROW OR COLUMN

	INX							;INCREMENT COUNTER FOR WRITING TO SCREEN.TILE.DATA ARRAY

	CPX #SCREEN.COLUMN.SIZE 
	BEQ .EXIT
	
.TEMP
			
	LDA GMAP.LOOKUP
	STA OP1
	LDA GMAP.LOOKUP+$1
	STA OP1+$1

	LDA #OFFSET.DOWN
	STA OP2						
	LDA #$00				
	STA OP2+$1					
	
	JSR ADC.16					;GMAP.LOOKUP(2) + OFFSET.DOWN(1)
	
	LDA RESULT					;SAVE RESULT OF ADC.16
	STA GMAP.LOOKUP				
	LDA RESULT+$1
	STA GMAP.LOOKUP+$1
	
	LDA #$00
;!!!!WARNING: THIS LOOP MUST END WITH ACC == #$00 OR TILE.LOOKUP.SINGLE WILL CALCULATE A NEW INDEX ON EACH ITERATION	
				
	JMP .LOOP	

.EXIT


	RTS
	
	
TILE.LOOKUP.SINGLE		;=============LOOKUP SINGLE TILE_TYPE (STAND-ALONE)=======
;PARAMETERS: GMAP.LOOKUP(2), ACC (#$00 use existing index, default calcualte new index)
;RETURN: tile_type
;ENTRANCE: DIRECT (TILE.LOOKUP.INDEX DOESN'T NEED TO BE CALLED FIRST)

;NOTE: Return Value is different than TILE.LOOKUP.ROW   **CLARITY*** opportunity to clarify code
;
;			the return value from this routine is affected bya differce in how it treats GMAP.LOOKUP vs. how TILE.LOOKUP.INDEX does. 
;	 		TILE.LOOKUP.INDEX has overflow calculations. So, once the tile qty specified in GMAP.LOOKUP is found, if there is no overflow, 
;			the INDEX is set to the tile pair following the tile pair where GMAP.LOOKUP was found. 
;			
;			In this routine, the index is set to the tile pair where GMAP.LOOKUP is found.
;			Said another way, TILE.LOOKUP.INDEX assumes you want it to return tile_type values starting with the
;			the tile after GMAP.LOOKUP and this routine assumes you want the tile_type associated with GMAP.LOOKUP
;
;			The vaue of the offsets constants were calculated using the TILE.LOOKUP.INDEX assumption.
;			Currently this different is handled with a single INC OP2 in the TILE.LOOKUP.COLUMN routine
;			It may be possible to eliminte this different by adjusting the way the overflow is calcualted
;			in TILE.LOOKUP.INDEX. Maybe if the final overflow value (/aka pickup value) is increased by one
;			and if the initial trigger for determining an overflow was based on GMAP.LOOKUP -1. 
;			The key would be is that when GMAP.TALLY >= GMAP.LOOKUP, 1 tile needs to be treated as a pickup value in 
;			in the TILE.LOOKUP.ROW routine. The easiest way to do that is probably to check for GMAP.TALLY >= GMAP.LOOKUP-1


;WARNING: GMAP.LOOKUP is a 16-bit number. If using this routine via a driver with an 8 bit number make sure to init
;GMAP.LOOKUP+$1 to $00.


;init variables

	CMP #$00						;use existing index?
	BEQ	.START						

	LDA #$00
	STA GMAP.TALLY
	STA GMAP.TALLY+$1
	
	LDA #GMAP.TILE.DATA				;START INDEX AT FIRST ELEMENT OF GMAP.TILE.DATA
	STA GMAP.ADDRESS.INDEX
	LDA /GMAP.TILE.DATA
	STA GMAP.ADDRESS.INDEX+$1
	
	LDY #$00
			

.START								;USE EXISTING INDEX (PICKUP WHERE THIS ROUTINE LEFT OFF INTERATING THROUGH THE GMAP.TILE.DATA ARRAY

;init variables

;NONE: If #$00 is passed via X-REG, then the routine will use the preexisting GMAP.TALLY, GMAP.ADDRESS.INDEX and 
;Y-REG values to pickup up where it left off. 


		

	

;Identify the position in the compressed data associated with the uncompressed position lookup	
.LOOP.LOOKUP
	LDA (GMAP.ADDRESS.INDEX),Y				;**OPT** TO OPTIMIZE FOR SPEED, MAY BE ABLE TO SETUP A BRANCH SO THAT THE 16-BIT ADD IS ONLY DONE WHEN A 16-BIT VALUE IS PRESENT IN OP1 OR OP2. 
	STA OP1
	LDA GMAP.TALLY
	STA OP2
	
	LDA GMAP.TALLY+$1
	STA OP2+$1
	LDA #$00
	STA OP1+$1
	
	JSR ADC.16					;GMAP.TILE.DATA,X + GMAP.TALLY(2)

		
.TEMP2
	
	LDA RESULT
	STA GMAP.TALLY
	STA OP1
	LDA RESULT+$1
	STA GMAP.TALLY+$1
	STA OP1+$1
	
	
	LDA GMAP.LOOKUP
	STA OP2
	LDA GMAP.LOOKUP+$1
	STA OP2+$1
	JSR IGRE.16					;GMAP.TALLY(2) IGRE GMAP.LOOKUP(2)		
	

.TEMP
		
	BCS .TILE.FOUND


	INY							;ADVANCE TO NEXT TILE PAIR. Y-REG IS THE LO BYTE OF GMAP.INDEX FOR THE DURATION OF THIS LOOP
	INY							;EVEN THOUGH IT'S A 2 BYTE INY, IT WILL ADVANCE FROM !254 TO 0, THUS BNE WILL DETECT THE FLIP. 
	BNE .NO.FLIP
	INC GMAP.ADDRESS.INDEX+$1
	INC GMAP.INDEX.HO			;**OPT** (a counter to help troubleshooting, comment out this line at least. If removed, also remove the definition for GMAP.INDEX.HO and GMAP.INDEX.LO. There are 3 lines like this in the program, two for HO and one for LO. 
.NO.FLIP
		 
		
	JMP .LOOP.LOOKUP	
	
.TILE.FOUND	


;******THIS STUFF CAN BE DELETED ONCE MAP MOVEMENT IN ALL DIRECTIONS IS WORKING

;UPDATE GMAP.ADDRESS.INDEX WITH Y-REG SO THIS ROUTINE CAN BE CALLED AGAIN AND START WITH THE LAST ELEMENT OF THE ARRAY EXAMINED

;	LDA	GMAP.ADDRESS.INDEX			STA OP1			
;	LDA	GMAP.ADDRESS.INDEX+$1	
;	STA OP1+$1							
	
;	STY OP2								;Y-REG WAS THE LO BYTE COUNTER OF GMAP.ADDRESS.INDEX. GMAP.ADDRESS.INDEX+$1 (HO) IS INCREMENTED AS Y-REG FLIPS TO $00 DURING THIS ROUTINE. 
;	LDA #$00
;	STA OP2+$1
;	JSR ADC.16							;GMAP.ADDRESS.INDEX (2) + Y-REG (1)
	
;	LDA RESULT
;	STA GMAP.ADDRESS.INDEX				;THIS WILL BE USED AS THE STARTING POINT FOR ITERATING THROUGH THE GMAP.TILE.DATA ARRAY IN TILES.LOOKUP.ROW FOR COPYING TILES TO THE SCREEN.TILE.DATA ARRAY
;	LDA RESULT+$1
;	STA GMAP.ADDRESS.INDEX+$1
	
;LOAD TILE_TYLE	
;	LDY #$01					
	
	
	INY							;ADVANCE ONE ELEMENT BECAUSE TILE_TYPE COMES IMMEDIATELY AFTER TILE_QUANTITY
	LDA (GMAP.ADDRESS.INDEX),Y	;LOAD TILE_TYPE
	DEY							;RETURN Y TO PREVIOUS VALUE SO THAT Y IS ALIGNED WITH TILE_QTY IN NEXT ITERATION 
	
	RTS


;======INCLUDE FILES======

;NONE
	

				
;==========================DEFINE VARIABLES======================

;this array was modified to convert the $0A values to $09 for compatability with the spreadsheet analysis tool. Thus, it's not precicesly a 64x64 array. that could be tweaked in the speadsheet and copied back to the source code if useful to have the production array also match the spreadsheet analysis tool.
;lookup value			       10  	 x	    	 	        +17 (overfllow 2)                 ??+17 (extra 1)
;tile qty				 q	   q	 q     q     q     q     q    q     q      q     q     q     q     q  																																																																																																																																																																												?									         
;GMAP.TILE.DATA 		.HS	05.00.05.01.01.08.05.00.05.00.05.00.01.08.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.03.03.09.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.03.00
;array elements			00.01.02.03.04.05.06.07.08.09.0A.0B.0C.0D.0E.0F.10.11.12.13.14.15.16.17.18.19.1A.1B.1C.1D.1E.1F.20.21.22.23.24.25.26.27.28.29.2A.2B.2C.2D.2E.2F.30.31.32.33.34.35.36.37.38.39.3A.3B.3C.3D.3E.3F.40.41.42.43.44.45.46.47.48.49.4A.4B.4C.4D.4E.4F.50.51.52.53.54.55.56.57.58.59.5A.5B.5C.5D.5E.5F.60.61.62.63.64.65.66.67.68.69.6A.6B.6C.6D.6E.6F.70.71.72.73.74.75.76.77.78.79.7A.7B.7C.7D.7E.7F.80.81.82.83.84.85.86.87.88.89.8A.8B.8C.8D.8E.8F.90.91.92.93.94.95.96.97.98.99.9A.9B.9C.9D.9E.9F.A0.A1.A2.A3.A4.A5.A6.A7.A8.A9.AA.AB.AC.AD.AE.AF.B0.B1.B2.B3.B4.B5.B6.B7.B8.B9.BA.BB.BC.BD.BE.BF.C0.C1.C2.C3.C4.C5.C6.C7.C8.C9.CA.CB.CC.CD.CE.CF.D0.D1.D2.D3.D4.D5.D6.D7.D8.D9.DA.DB.DC.DD.DE.DF.E0.E1.E2.E3.E4.E5.E6.E7.E8.E9.EA.EB.EC.ED.EE.EF.F0.F1.F2.F3.F4.F5.F6.F7.F8.F9.FA.FB.FC.FD.FE.FF.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01
;																																																																																																																																																																																																						00.01.02.03.04.05.06.07.08.09.0A.0B.0C.0D.0E.0F.10.11.12.13.14.15.16.17.18.19.1A.1B.1C.1D.1E.1F.20.21.22.23.24.25.26.27.28.29.2A.2B.2C.   								

;use for testing movement, this is 64x64 tiles. But, before using, use replace to convert the 0A values to 09 so it's compatible with the analyis spreadsheet
;GMAP.TILE.DATA 		.HS	05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.00
;


GMAP.TALLY					.EQ $8300					;2byt	(16-BIT)
GMAP.LOOKUP					.EQ	$8302					;2byt   (16-BIT)

GMAP.INDEX.LO				.EQ $8304					;2byt	(16-BIT)
GMAP.INDEX.HO				.EQ $8305					;paired with preceding
GMAP.ADDRESS.INDEX			.EQ	$FC						;2byt   (used as a pointer to GMAP.TILE.DATA to accomidate it's >256 byte size)
;

SCREEN.ROW.SIZE				.EQ $11						;#CONSTANT  (!17)
SCREEN.COLUMN.SIZE			.EQ	$0B						;#CONSTANT	(!11)
;SCREEN.LAST.TILE			.BS $2						;2byt	(16-BIT)	used by TILE.LOOKUP.SCREEN as the loop stop value. 
SCREEN.TILE.QTY				.EQ	$BB						;#CONSTANT (!187)					
SCREEN.TILE.COUNTER			.BS $1						;1byt
TILE.COUNTER				.BS $1						;1byt

SCREEN.TILE.DATA 			.EQ	$8000					;replace with .BS $BA byts	;HOLDS TILE_TYPE DATAT FOR EACH TILE ON VIEW SCREEN
SCREEN.TILE.HOPPER			.EQ	$80BC					;replace with .BS $11. 		;HOLDS ONE COLUMN OR ROW OF TILE_TYPE DATA ON DECK FOR SCREEN DRAWING (USED AFTER SCREEN SCROLLING)
GMAP.EXPAND.TALLY			.BS	$1		
GMAP.INDEX.OVERFLOW			.BS	$1						;1byt
GMAP.INDEX.QUANTITY			.BS	$1						;1byt
TEMP						.BS $1						;1byt




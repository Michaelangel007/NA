;************************INCLUDE FILE*****************************
;(do not assemble stand-alone. For a stand-alone version of this routine see examples/rwts2)

;**OPT** MEMORY. I THINK IT'S POSSIBLE TO CONDENSE ALL OF THIS INTO ONE ROUTINE THAT HANDLES
;ALL FOUR DIRECTIONS WITH MATERIALLY LESS CODE. MIGHT REDUCE SPEED BUT I DON'T THINK BY MUCH. 
;
;NOTES ON **OPT** THIS TOPIC: IF THE .SCROLL ROUTINES LOADING THE BASE ADDRESSES BOTH LDX TILE.LINE AND TILE.LINE.CPY, THEN FURTHER UPSTREAM EITHER DIFFERENT OR THE SAME VALUES COULD BE PLACED DEPENDING ON WHETHER IT'S ROW OR COLUMN COPY.
;I INITIALLY GOT CONCERNED ABOUT DOING WHEN ROUTINE WHEN I SAW THAT THE ROW SCROLLING HAD INC SCREEN.BYTE TWICE, THINKIN IT WAS MOVING OVER TWO TILES. BUT THAT ISN'T THE CASE, 2 SCREEN BYTES = 1 TILE. THE TILES ARE BEING COPIED TO THE BACKGROUND PAGE SO THAT IS WHY TILES DON'T GET OVERWRITTEN AS THE COPY IS BEING DONE. 

SCROLL.ROWS	;=============SCROLLS ONSCREEN ROW TILES=========
;PARAMTERS: MOVE.CURRENT
;RETURN: NONE
		
.INIT.SCREEN					;SETUP BYTE, LINE, DEPTH
	LDA	#SCREEN.START.BYTE											;**OPT** THIS IS DUPLICATE
	STA SCREEN.BYTE				;SET STARTING SCREEN BYTE			;**OPT** THIS IS DUPLICATE
	LDA #SCREEN.START.LINE										
	STA TILE.LINE				;SET CURRENT LINE TO PLOT WITHIN TILE	
	STA TILE.LINE.START			;SET STARTING LINE FOR TILES IN ROW 0

			
.LOOP
	LDA #SCREEN.START.BYTE		;RESET SCREEN.BYTE TO THE FIRST TILE COLUMN
	STA SCREEN.BYTE
	
	JSR SCROLL.ROW.TILES	

	LDA TILE.LINE.START				;ADVANCE LINE TO NEXT ROW OF TILES
	CLC
	ADC #TILE.DEPTH
	STA TILE.LINE.START
	STA TILE.LINE
	CMP	#SCREEN.STOP.LINE			;READY TO SWITCH TILE COLUMNS? (TILE.LINE should already be in ACC at end of DRAW.TILE) 
	BCS .EXIT						;IF YES, EXIT (BCS: is ACC >= CMP value)

	JMP .LOOP

.EXIT
	RTS




SCROLL.ROW.TILES		
;PARAMTERS: MOVE.CURRENT
;RETURN: NONE	
;ENTRANCE: VIA SCROLL.ROWS

;.SAVE.REGISTERS
;	TXA
;	PHA

.MAINLOOP

	JSR .SCROLL
	
	LDA TILE.LINE.START
	STA TILE.LINE					;PREPARE FOR NEW TILE: RESET CURRENT LINE IN TILE TO DRAW TO THE STARTIN LINE

	LDA #SCROLL.STOP.BYTE			;AT RIGHT SIDE SCREEN YET?
	CMP SCREEN.BYTE
	BCS .MAINLOOP						;IF NO, SWITCH OVER TO NEXT ROW (BCS: is ACC >= CMP value)
	
	RTS

	;**OPT** SPEED. IT MAYBE POSSIBLE TO GAIN SPEED BY EXAMINING THE MEMORY ADDRESS LAYOUT ON THE GRAPHICS SCREEN
	;and writing a more direct copy routine. basically, all lines get copied except a few at top and bottom. If I
	;can figure out how to exclude those, the routine can copy the rest of the lines seqentially even though that
	;isn't how they appear on-screen. handling the horizonal part should be easy as that's just and offset to the
	;line base address. I should be able to manage it through the existing screen byte variables. 
	


.SCROLL

	LDA TILE.LINE.START		;THE STARTING LINE OF THE TILES IN THE CURRENT ROW
	CLC
	ADC #TILE.DEPTH			;ADD DEPTH OF SHAPE TO STARTING LINE IN HEX (# of lines, not the position of last line....so line positions $0-$F is $10 (!16) total lines)
	STA TILE.LINE.STOP		;SET THE LAST LINE TO DRAW BASED ON THE DEPTH OF THE TILE

.COPY.LOOP.ROW

	LDX TILE.LINE			;LOAD LINE IN X REGISTER
	
	
	LDA PAGE.ACTIVE			;SPECIFY PAGE TO GET ADDRESS FOR (SHOULD BE BACKGROUND PAGE)
	JSR GET.LINE.ADDRESS1	;GET LINE ADDRESS (TO LOAD DATA)
	
	LDA PAGE.OPPOSITE		;SPECIFY PAGE TO GET ADDRESS FOR (SHOULD BE BACKGROUND PAGE)
	JSR GET.LINE.ADDRESS2	;GET LINE ADDRESS (TO COPY DATA)
	
	LDA MOVE.CURRENT		;#$00=north, $01=south, $02=east, $03=west
	CMP #$03
	BEQ	.MOVE.WEST.SCROLL.RIGHT
	CMP #$02
	BEQ	.MOVE.EAST.SCROLL.LEFT
	JMP .ERROR
	
.MOVE.WEST.SCROLL.RIGHT
	LDY SCREEN.BYTE			;SCREEN BYTE INDEX IN Y REGISTER	
	LDA (LINE.BASE.ADDR1),Y	;LOAD TILE DATA	
	
	INY						;MOVE Y TWO SCREEN BYTES RIGHT
	INY
	STA (LINE.BASE.ADDR2),Y	;COPY TILE DATA
	DEY
	DEY

;**OPT** SPEED. MAYBE INSTEAD OF INC TO SCREEN.BYTE WE COULD JUST DO INY USE SCREEN.BYTE TO INIT Y AT THE START OF THIS ROUTINE (I THINK WE ALREADY DO). WOULD NEED TO REVIW HOW THE EXIT FROM THIS ROUTINE WORKS, ADJUST IT TO Y IF ITS BASED ON SCREEN.BYTE. ALSO CONSIDER THE IMPLICATIONS IN THE ROUTINE THAT CALLS THIS ONE. MAY NEED TO SAVE Y TO SCREEN.BYTE AT END OF THIS ROUTINE, OR CONTINUE THE CONVERSION HIGHER UP. 	
	INC SCREEN.BYTE			;SWITCH TO 2ND SCREEN BYTE IN THE TILE
	
	LDY SCREEN.BYTE			;SCREEN BYTE INDEX IN Y REGISTER	
	LDA (LINE.BASE.ADDR1),Y	;LOAD TILE DATA
	
	INY						;MOVE Y TWO SCREEN BYTES RIGHT
	INY
	STA (LINE.BASE.ADDR2),Y	;COPY TILE DATA
	DEY
	DEY
	
	DEC SCREEN.BYTE			;SWITCH BACK TO 1ST SCREEN BYTE IN THE TILE	;**OPT** if the counters are updated after the CMP/branch it might save 1 INC SCREEN.BYTE instruction in the main loop because SCREEN.BYTE will be in 2nd position when this loop ends. 
	JMP .ALL.ROW.MOVES
	
.MOVE.EAST.SCROLL.LEFT
		
	LDY SCREEN.BYTE			;SCREEN BYTE INDEX IN Y REGISTER	
	INY						;MOVE AHEAD 1 COLUMN
	INY
	LDA (LINE.BASE.ADDR1),Y	;LOAD TILE DATA	
	
	DEY						;MOVE BACK 1 COLUMN
	DEY
	STA (LINE.BASE.ADDR2),Y	;COPY TILE DATA
;	INY						;MOVE AHEAD 1 COLUMN (ORIGINAL COLUMN AT START OF ITERATION)
;	INY

;**OPT** SPEED. MAYBE INSTEAD OF INC TO SCREEN.BYTE WE COULD JUST DO INY USE SCREEN.BYTE TO INIT Y AT THE START OF THIS ROUTINE (I THINK WE ALREADY DO). WOULD NEED TO REVIW HOW THE EXIT FROM THIS ROUTINE WORKS, ADJUST IT TO Y IF ITS BASED ON SCREEN.BYTE. ALSO CONSIDER THE IMPLICATIONS IN THE ROUTINE THAT CALLS THIS ONE. MAY NEED TO SAVE Y TO SCREEN.BYTE AT END OF THIS ROUTINE, OR CONTINUE THE CONVERSION HIGHER UP. 	
	INC SCREEN.BYTE			;SWITCH TO 2ND SCREEN BYTE IN THE TILE
	
	LDY SCREEN.BYTE			;LOAD UPDATED SCREEN.BYTE INDEX INTO Y-REG
	
	INY						;MOVE AHEAD 1 COLUMN
	INY
	LDA (LINE.BASE.ADDR1),Y	;LOAD TILE DATA
	
	DEY						;MOVE BACK 1 COLUMN
	DEY
	STA (LINE.BASE.ADDR2),Y	;COPY TILE DATA
;	INY
;	INY						;MOVE AHEAD 1 COLUMN (ORIGINAL COLUMN AT START OF ITERATION)
	
	DEC SCREEN.BYTE			;SWITCH BACK TO 1ST SCREEN BYTE IN THE TILE	;**OPT** if the counters are updated after the CMP/branch it might save 1 INC SCREEN.BYTE instruction in the main loop because SCREEN.BYTE will be in 2nd position when this loop ends. 
	
.ALL.ROW.MOVES
	INC TILE.LINE			;NEXT TILE LINE
	
	LDA TILE.LINE				
	CMP TILE.LINE.STOP		;IS TILE DONE?							
	BCC .COPY.LOOP.ROW			;IF NO, DRAW NEXT LINE (BCC: is ACC < CMP value)
	
	INC SCREEN.BYTE			;IF YES, NEXT TILE
    INC SCREEN.BYTE		

;.RESTORE.REGISTERS
;	PLA
;	TAX
	
	RTS	

.ERROR
	;;SCOLL.COLUMN.ROWS REPORTS INVALID VALUE IN MOVE.CURRENT 
	BRK
	
SCROLL.COLUMNS	;=============SCROLLS ONSCREEN COLUMN TILES=========
;PARAMTERS: MOVE.CURRENT
;RETURN: NONE
		
.INIT.SCREEN					;SETUP BYTE, LINE, DEPTH
;	LDA	#SCREEN.START.BYTE											;**OPT** THIS IS DUPLICATE
;	STA SCREEN.BYTE				;SET STARTING SCREEN BYTE			;**OPT** THIS IS DUPLICATE
	LDA #SCREEN.START.LINE										
	STA TILE.LINE				;SET CURRENT LINE TO PLOT WITHIN TILE	
	STA TILE.LINE.START			;SET STARTING LINE FOR TILES IN ROW 0							
	CLC
	ADC #TILE.DEPTH
	STA TILE.LINE.COPY
			
.LOOP
	LDA #SCREEN.START.BYTE		;RESET SCREEN.BYTE TO THE FIRST TILE COLUMN
	STA SCREEN.BYTE
	
	JSR SCROLL.COLUMN.TILES	

	LDA TILE.LINE.START				;ADVANCE LINE TO NEXT ROW OF TILES
	CLC
	ADC #TILE.DEPTH
	STA TILE.LINE.START
	STA TILE.LINE
	CLC
	ADC #TILE.DEPTH
	STA TILE.LINE.COPY				;START LINE OF TILE 1 ROW DOWN
	CMP	#SCREEN.STOP.LINE			;READY TO SWITCH TILE COLUMNS? (TILE.LINE should already be in ACC at end of DRAW.TILE) 
	BCS .EXIT						;IF YES, EXIT (BCS: is ACC >= CMP value)
		
	JMP .LOOP

.EXIT
	RTS

SCROLL.COLUMN.TILES		
;PARAMTERS: MOVE.CURRENT
;RETURN: NONE	
;ENTRANCE: VIA SCROLL.ROWS

;.SAVE.REGISTERS
;	TXA
;	PHA

.MAINLOOP

	JSR .SCROLL

	
	LDA TILE.LINE.START
	STA TILE.LINE					;PREPARE FOR NEW TILE: RESET CURRENT LINE IN TILE TO DRAW TO THE STARTIN LINE
	CLC
	ADC #TILE.DEPTH
	STA TILE.LINE.COPY
	
	LDA #SCREEN.STOP.BYTE			;AT RIGHT SIDE SCREEN YET?
	CMP SCREEN.BYTE
	BCS .MAINLOOP					;IF NO, SWITCH OVER TO NEXT ROW (BCS: is ACC >= CMP value)
	
	RTS

	;**OPT** SPEED. IT MAYBE POSSIBLE TO GAIN SPEED BY EXAMINING THE MEMORY ADDRESS LAYOUT ON THE GRAPHICS SCREEN
	;and writing a more direct copy routine. basically, all lines get copied except a few at top and bottom. If I
	;can figure out how to exclude those, the routine can copy the rest of the lines seqentially even though that
	;isn't how they appear on-screen. handling the horizonal part should be easy as that's just and offset to the
	;line base address. I should be able to manage it through the existing screen byte variables. 
	


.SCROLL

	LDA TILE.LINE.START		;THE STARTING LINE OF THE TILES IN THE CURRENT ROW
	CLC
	ADC #TILE.DEPTH			;ADD DEPTH OF SHAPE TO STARTING LINE IN HEX (# of lines, not the position of last line....so line positions $0-$F is $10 (!16) total lines)
	STA TILE.LINE.STOP		;SET THE LAST LINE TO DRAW BASED ON THE DEPTH OF THE TILE

.COPY.LOOP.COLUMN
	
	LDA MOVE.CURRENT		;#$00=north, $01=south, $02=east, $03=west
	CMP #$00
	BEQ	.MOVE.NORTH.SCROLL.DOWN
	CMP #$01
	BEQ	.MOVE.SOUTH.SCROLL.UP
	JMP .ERROR
	
.MOVE.NORTH.SCROLL.DOWN

	LDX TILE.LINE			;LOAD LINE IN X REGISTER		
	LDA PAGE.ACTIVE			;SPECIFY PAGE TO GET ADDRESS FOR (SHOULD BE BACKGROUND PAGE)
	JSR GET.LINE.ADDRESS1	;GET LINE ADDRESS (TO LOAD DATA)
	
	LDX TILE.LINE.COPY
	LDA PAGE.OPPOSITE		;SPECIFY PAGE TO GET ADDRESS FOR (SHOULD BE BACKGROUND PAGE)
	JSR GET.LINE.ADDRESS2	;GET LINE ADDRESS (TO COPY DATA)
	
	LDY SCREEN.BYTE			;SCREEN BYTE INDEX IN Y REGISTER	
	LDA (LINE.BASE.ADDR1),Y	;LOAD TILE DATA	
	STA (LINE.BASE.ADDR2),Y	;COPY TILE DATA

;**OPT** SPEED. MAYBE INSTEAD OF INC TO SCREEN.BYTE WE COULD JUST DO INY USE SCREEN.BYTE TO INIT Y AT THE START OF THIS ROUTINE (I THINK WE ALREADY DO). WOULD NEED TO REVIW HOW THE EXIT FROM THIS ROUTINE WORKS, ADJUST IT TO Y IF ITS BASED ON SCREEN.BYTE. ALSO CONSIDER THE IMPLICATIONS IN THE ROUTINE THAT CALLS THIS ONE. MAY NEED TO SAVE Y TO SCREEN.BYTE AT END OF THIS ROUTINE, OR CONTINUE THE CONVERSION HIGHER UP. 	
	INC SCREEN.BYTE			;SWITCH TO 2ND SCREEN BYTE IN THE TILE
	
	LDY SCREEN.BYTE			;SCREEN BYTE INDEX IN Y REGISTER	
	LDA (LINE.BASE.ADDR1),Y	;LOAD TILE DATA
	STA (LINE.BASE.ADDR2),Y	;COPY TILE DATA
	
	DEC SCREEN.BYTE			;SWITCH BACK TO 1ST SCREEN BYTE IN THE TILE	;**OPT** if the counters are updated after the CMP/branch it might save 1 INC SCREEN.BYTE instruction in the main loop because SCREEN.BYTE will be in 2nd position when this loop ends. 
	JMP .ALL.MOVES
	
.MOVE.SOUTH.SCROLL.UP

	LDX TILE.LINE.COPY		;LOAD LINE IN X REGISTER		
	LDA PAGE.ACTIVE			;SPECIFY PAGE TO GET ADDRESS FOR (SHOULD BE BACKGROUND PAGE)
	JSR GET.LINE.ADDRESS1	;GET LINE ADDRESS (TO LOAD DATA)
	
	LDX TILE.LINE
	LDA PAGE.OPPOSITE		;SPECIFY PAGE TO GET ADDRESS FOR (SHOULD BE BACKGROUND PAGE)
	JSR GET.LINE.ADDRESS2	;GET LINE ADDRESS (TO COPY DATA)
	
	LDY SCREEN.BYTE			;SCREEN BYTE INDEX IN Y REGISTER	

	LDA (LINE.BASE.ADDR1),Y	;LOAD TILE DATA	
	STA (LINE.BASE.ADDR2),Y	;COPY TILE DATA

;**OPT** SPEED. MAYBE INSTEAD OF INC TO SCREEN.BYTE WE COULD JUST DO INY USE SCREEN.BYTE TO INIT Y AT THE START OF THIS ROUTINE (I THINK WE ALREADY DO). WOULD NEED TO REVIW HOW THE EXIT FROM THIS ROUTINE WORKS, ADJUST IT TO Y IF ITS BASED ON SCREEN.BYTE. ALSO CONSIDER THE IMPLICATIONS IN THE ROUTINE THAT CALLS THIS ONE. MAY NEED TO SAVE Y TO SCREEN.BYTE AT END OF THIS ROUTINE, OR CONTINUE THE CONVERSION HIGHER UP. 	
	INC SCREEN.BYTE			;SWITCH TO 2ND SCREEN BYTE IN THE TILE
	
	LDY SCREEN.BYTE			;LOAD UPDATED SCREEN.BYTE INDEX INTO Y-REG
	LDA (LINE.BASE.ADDR1),Y	;LOAD TILE DATA
	STA (LINE.BASE.ADDR2),Y	;COPY TILE DATA
	
	DEC SCREEN.BYTE			;SWITCH BACK TO 1ST SCREEN BYTE IN THE TILE	;**OPT** if the counters are updated after the CMP/branch it might save 1 INC SCREEN.BYTE instruction in the main loop because SCREEN.BYTE will be in 2nd position when this loop ends. 

	
	;no JMP needed
	
.ALL.MOVES
	INC TILE.LINE			;NEXT TILE LINE
	INC	TILE.LINE.COPY
	
	LDA TILE.LINE				
	CMP TILE.LINE.STOP		;IS TILE DONE?							
	BCC .COPY.LOOP.COLUMN			;IF NO, DRAW NEXT LINE (BCC: is ACC < CMP value)
	
	INC SCREEN.BYTE			;IF YES, NEXT TILE
    INC SCREEN.BYTE		
							

;.RESTORE.REGISTERS
;	PLA
;	TAX
	
	RTS	

.ERROR
	;SCOLL.COLUMN.TILES REPORTS INVALID VALUE IN MOVE.CURRENT
	BRK	
	

	
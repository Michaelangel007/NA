                .CR     6502            Use 6502 overlay
				.OR		$6000			**Always put before .TF directive and never use again in program
				.TF     TEST.BIN,BIN
				.EF		errors
				;.LI 	OFF				Switches the assembler machine code conversion listing off so errors are easier to see				
				.LF		C:\MY_CODE\LIST
				;				***For include files, look at end of program, before variable definitions. 

;
;
;EXAMPLE PURPOSE: 
;
;
;Hi-Res screen is !40 (!0-!39) ($0 - $27) screen bytes wide and !192 (!0-!192) ($0 - $BF) lines deep. 
;
;
;DRAW-DRAW vs. EOR (see HGUA p. 52-53 )
;							EOR		Draw-Draw	
;Speed						slower	faster
;Memory/Disk				same	same*		
;Flicker					some	none
;Draw over backgrounds		yes		no
;Collision detection		yes		difficult
;
;*unless the shape will move reappear at top of screen after reaching the bottom (or vice-versa). This is because and EOR erase routine is required to erase the shape at the screen edge.
;
;Conclusion: Draw-Draw seems the best choice for tiles graphics RPG animation. EOR (Draw-Ease) appears most useful in arcade game development. 
;
;DRAW-DRAW Concept
;
;By placing a border byte of #$00 at the top of the shape (if shape is moving down), the need for an special erase routine
;is eliminated. Because, after incementing the line, the shape bytes are redrawing over the top of the old shape.
;the only byte that wouldn't normally be replaced in this process is the top byte of the shape. Adding the border
;ensures that the top byte of the shape is erased by the redraw of the border shape byte.
;
;Exception: if a shape is moving looping from bottom of screen to top (& vice-versa), then an EOR erase is needed
;when the shape reaches the top/bottom of the screen. 
;
;The border is always place on the side (top/bottom) of the shape opposite of the diretion of movement. For example, if the shape is moving down, the border would be on the top of the shape.
;The border should be equal to the maximum number of lines the shape will move at a time. 
;
;
;
;GRAPHICS QUESTIONS (General)
;
;(EXPLAINED)*why does the upper part of the stick mans leg (2 dots) in the 2nd book example not appear on screen?
;			.The upper part of the legs were ommited in my code by mistake. However, when added, it just extends the torso with a green or violet
;			line. This is because for whatever reason, #$14 (two pixels on, with one off pixel between them) show up as 3 pixels on. 
;			The color appears to be determined based on what should plot (no adjacent ON pixels), which results in colored pixels, either
;			green or violet depending on whether the pixels are on odd or even columns. 
;			
;			Update: I observed with a different shape where two color dots were plotted in AppleWIN (full screen and regular, with 
;			a 1 dot HEX value), that only one dot was plotted on a physical Apple IIe. 
;			In looking at some games in an emaultor and physical Apple IIe, it looks like colors act really wierd in AppleWIN
;			Mountains look most purple, whereas they look white on the IIe, for example. There is a little "color bleed" on the 
;			physical IIe but it's much worse in the emualtor. It looks to me like games were just designed so that the bleed wasn't
;           a distraction. (I checked in the Virtual II Mac emulator and it seems to behave the same as AppleWIN as it relates
;			to color)


;=======PROGRAM START======

;	JMP DRIVER		;don't turn graphics mode on, so register output is visible from monitor prompt on BRK (testing)	

;Turn Hi-RES ON
	
PGM	NOP
	
;	LDA #$00		;SPECIFY BOTH PAGES FOR CLEAR SCREEN
;	JSR SCLEAR		;CLEAR SCREEN BEFORE TURNING ON GRAPHICS (AVOIDS UNSIGHTLY FLASH OF RANDOM DOTS) 
		
	LDA GRAPHICS	;TURN ON GRAPHICS MODE
	LDA HIRES		;SELECT HI-RES MODE
	LDA	PAGE1		;SELECT PAGE 1
	LDA MIXOFF		;SELECT FULL SCREEN GRAPHICS (PAGE 1)
	
	JMP DRIVER		;skip testing area

;===============TESTING AREA======

	LDA #$00		;SPECIFY BOTH PAGES FOR CLEAR SCREEN
	JSR SCLEAR		;CLEAR SCREEN BEFORE TURNING ON GRAPHICS (AVOIDS UNSIGHTLY FLASH OF RANDOM DOTS) 


	LDA	PAGE1
	
	
	
	
	LDX #$BF
	LDY #$00
	
	LDA #$01
	JSR GET.LINE.ADDRESS	;Get Line Address	
	LDA #$7F
	STA (LINE.BASE.ADDR),Y	;PLOT
	
	BRK
	
	
	LDX #$BF
	LDY #$00


	
	LDA LINE.HO.P1,X
	STA $77
	LDA LINE.LO,X
	STA $76
	LDA #$7F
	STA ($76),Y	;PLOT
	
	INY
		
	LDA LINE.HO.P1,X
	STA $77
	LDA LINE.LO,X
	STA $76
	LDA #$7F
	STA ($76),Y	;PLOT			
	
	


;	BRK
	
;====================MAIN PROGRAM============

DRIVER
	

;NOT SURE WHERE THIS SHOULD GO, PROBABLY AT VERY START OF GAME LAUNCH, PROBABLY FROM THERE IT IS ALL CALLS TO FLIP.PAGE
	LDA #$01						;
	STA PAGE.ACTIVE					;DRAW.TILE WILL DRAW THE OPPOSITE PAGE FROM THAT SPECIFED BY THIS VARIABLE
	LDA #$02
	STA PAGE.OPPOSITE
	LDA	PAGE1
	
;SETUP STARTING POSITION ON THE MAP
	LDA #$48
	STA GMAP
	LDA #$01
	STA GMAP+$1
	
	JSR DRAW.SCREEN
	JSR FLIP.PAGE
			

.KEYIN  

	LDA $C000
    BPL .KEYIN
    STA $C010                  	;CLR LAST KEY

		
;MOVE EAST (RIGHT)
	INC GMAP.Y					;INC LONGITUTE 1 POSITION EAST (RIGHT)
	INC GMAP
	BNE .NOFLIP
	INC GMAP+$1
	
	;FUTURE: LOGIC FOR REACHING MAP EDGE...EITHER STOP PLAYER FROM DOING SO, TRIGGER AN EVENT OR IMPLEMENT 
	;LOGIC FOR A ROUND WORLD.
	
.NOFLIP
	
	;LDA #$03
	;JSR SCLEAR					;CLEAR BACKGROUND PAGE
	
	JSR DRAW.SCREEN
	JSR FLIP.PAGE
	
	JMP .KEYIN


DRAW.SCREEN		;=============DRAWS SCREEN FROM TILE DATA, ANYWHERE ON THE MAP=========
;PARAMTERS: GMAP, PAGE.ACTIVE, PAGE.OPPOSITE
;RETURN: NONE


.INIT.MAP
	;**OPT** MAYBE WE CAN JUST TRACK SMAP, AND DROP GMAP. ANY CALCULATION WE NEED TO DO WILL BE RELATIVE OT THE UPPER LEFT OF THE SCREEN. SEEMS LIKE THAT SHOULD WORK. 
	LDA GMAP					;LOAD TILE_ID OF CURRENT MAP POSITION
	STA OP1
	LDA GMAP+$1
	STA OP1+$1
	
	LDA #OFFSET.SCREEN			;CALCULATE TILE_ID OF TILE IN UPPER LEFT CORNER OF SCREEN
	STA OP2
	LDA /OFFSET.SCREEN
	STA OP2+$1
	
	JSR SBC.16					;GMAP(2) - SCREEN.OFFSET.LO/HO (2)
			
	LDA RESULT					;SAVE TILE_ID OF UPPER LEFT SCREEN TILE
	STA SMAP
	STA SMAP.CURRENT
	LDA RESULT+$1
	STA SMAP+$1
	STA SMAP.CURRENT+$1
		

.INIT.SCREEN					;SETUP BYTE, LINE, DEPTH
	LDA	#SCREEN.START.BYTE											;**OPT** THIS IS DUPLICATE
	STA SCREEN.BYTE				;SET STARTING SCREEN BYTE			;**OPT** THIS IS DUPLICATE
	LDA #SCREEN.START.LINE										
	STA TILE.LINE				;SET CURRENT LINE TO PLOT WITHIN TILE	
	STA TILE.LINE.START			;SET STARTING LINE FOR TILES IN ROW 0

	
;**OPT** when this is used for drawing the screen at game start or first entering a map, this is 
;probably fine. we shouldn't need to clear the entire screen for movement, but that will not flow
;through draw.screen so it will probably get setup correctly to begin with. This is a reminder
;note to thing about if screen clears are being handled most efficiently in general.
	
.CLEAR.SCREEN					;CLEAR BACKGROUND PAGE (WHERE DRAW.TILE WILL PLOT TO)
;	LDA #$03
;	JSR SCLEAR					;CLEAR BACKGROUND PAGE
			
.LOOP
	LDA #SCREEN.START.BYTE		;RESET SCREEN.BYTE TO THE FIRST TILE COLUMN
	STA SCREEN.BYTE
	
	JSR DRAW.ROW	

	LDA SMAP.CURRENT			;ADVANCE TO NEXT ROW ON THE SCREEN
	STA OP1
	LDA SMAP.CURRENT+$1
	STA OP1+$1
	LDA #OFFSET.DOWN
	STA OP2
	LDA #$00
	STA OP2+$1
	
	JSR ADC.16					;SMAP.CURRENT(2) + #OFFSET.DOWN(1)
	

	LDA TILE.LINE.START				;ADVANCE LINE TO NEXT ROW OF TILES
	CLC
	ADC #$10
	STA TILE.LINE.START
	STA TILE.LINE
	CMP	#SCREEN.STOP.LINE			;READY TO SWITCH TILE COLUMNS? (TILE.LINE should already be in ACC at end of DRAW.TILE) 
	BCS .EXIT						;IF YES, EXIT (BCS: is ACC >= CMP value)

	JMP .LOOP

.EXIT
	RTS




DRAW.ROW		;=============DRAWS ROW FROM TILE DATA, ANYWHERE ON THE SCREEN=========
;PARAMTERS: SMAP.CURRENT, #SCREEN.BYTE.START, SCREEN.START.LINE, TILE_LINE_START, TILE_LINE
;	NOTE: SET TILE_LINE == TO TILE_LINE_START before calling this routine. This saves an LDA instruction versus doing an init of TILE_LINE in this routine. 
;RETURN: NONE


;LOAD TILES
	LDA SMAP.CURRENT				;THE TILE_ID OF THE FIRST TILE IN THE CURRENT ROW
	STA GMAP.LOOKUP
	LDA SMAP.CURRENT+$1
	STA GMAP.LOOKUP+$1
			
	JSR TILE.LOOKUP.INDEX			;LOOKUP THE INDEX (ELEMENT OF THE GMAP.TILE.DATA.ARRAY THAT CONTAINS THE TILE TYPE FOR THE FIRST TILE IN THE CURRENT ROW).
	JSR TILE.LOOKUP.ROW				;USING THE INDEX, LOAD THE TILE_TYPE FOR EACH TILE IN THE CURRENT ROW 
			
	LDX #$00						;INIT X COUNTER FOR 1ST TILE IN ROW	
;
.LOOP

					
	LDA SCREEN.TILE.ROW,X			;LOAD TILE_TYPE OF THE NEXT TILE IN CURRENT ROW AND CALCUALTE THE 
	
				STA $7500,X			;LOG OF ALL TILES PLOTTED TO SCREEN
				STX $7400
;			CPX #$01
;			BNE .TEMP
;			BRK

.TEMP
	INX								;INCREMENT COUNTER SO WE GET THE NEXT TILE_TYPE ON THE NEXT INTERATION OF .LOOP
	
	ASL ;X2							;	OFFSET TO THE SHAPE TABLE FOR THAT TILE. ALL TILE SHAPE TABLES
	ASL ;X4							;	 ARE 32byts, SO THE OFFSET IS (TILE_TYPE * 32)
	ASL ;X8							;	 THE OFFSET IS ADDED TO THE ADDRESS OF THE FIRST TILE SHAPE TABLE
	ASL ;X16						;	 TO CALCUALTE THE ADDRESS OF THE SHAPE TABLE FOR THE CURRENT TILE.
	ASL ;X32
				
	STA OP1							;SAVE RESULT OF MULTIPLCATION (ASLs) ABOVE				
	LDA #$00
	STA OP1+$1						;X-REG ALREADY == #$00
				
	LDA #GRASS						;GRASS IS THE FIRST SHAPE TABLE. 
	STA OP2
	LDA /GRASS
	STA OP2+$1
					
	JSR ADC.16						;CURRENT TILE SHAPE OFFSET + ADDRESS OF FIRST TILE SHAPE TABLE (GRASS)
	
	LDA RESULT
	STA SHAPE
	LDA RESULT+$1
	STA SHAPE+$1
	
	
			
;NEW CODE TEST: I VERIFIED THAT CONTENTS OF OP1,OP2,RESULT AT THIS LOCATION, CONFRIMING THE CORRECT
;SHAPE TABLE ADDRESS WAS CALCUALTED FOR TILE TYPES 0-3.
	
	
	;2 load the tile type of the 1st tile into ACC
	;			INIT X-REG TO $00
	;			LDA SCREEN.TILE.ROW,X
	;
	;
	;**OPT** SPEED. TRY ADDING A BEQ TO STKIP THE ASLS, AS TYPE TYPE $00 WOULD REFER TO THE FIRST TILE SHAPE TABLE ANYWAY. BEQ COSTS 2 CYCLES. ASL COSTS 2*5 CYCLES (10). IT COMES DOWN TO WHETHER ADDING AN EXTRA 2 CYCLES FOR ALL NON-GRASS TILES IS WORTH SAVING 8 (net) CYCLES ON GRASS TILES 
	;ASL X2
	;ASL X4
	;ASL X8
	;ASL X16
	;ASL X32
	;the acc should now have the offset to the first shape table, to calc the base address of the shape table associated with the tile type
	;
	;PROBLEM: this will only work for tiles 0-7 because acc is 256bytes. (8*32 = 256). 
	;to support tiles beyond that the options I've thought of are 
	;	a) do 16-bit multiplication with ACC as op1 and #$32 as op2 (I might be able to write 
	;	a simpler routine with ASLs than the 16 bit routine I currently have)
	;	b) store the tile shape table addresses in a zero page table and access them via indirect
	;	index by X. Even if I used the entire zero page I'd be limited to 128 tile types. 
	;	and there would be a lot of non-looping code to store all those addresses. By gut says
	;	do try the 16-bit multiply first or think of a 3rd option. 
	;3 16-bit add: grass shape table address and the offset. store result in SHAPE (which is already 16-bit)
	;
	;4


	JSR DRAW.TILE					;DRAW SHAPE
			
	LDA TILE.LINE.START
	STA TILE.LINE					;PREPARE FOR NEW TILE: RESET CURRENT LINE IN TILE TO DRAW TO THE STARTIN LINE

	LDA #SCREEN.STOP.BYTE			;AT RIGHT SIDE SCREEN EACH?
	CMP SCREEN.BYTE
	BCS .LOOP						;IF NO, SWITCH OVER TO NEXT ROW (BCS: is ACC >= CMP value)
	
	RTS
	
	
;	LDA DELAY
;	JSR WAIT


;===================SUBROUTINES===============

DRAW.TILE	NOP

.SAVE.REGISTERS
	TXA
	PHA

.START
	
	LDA #$00
	STA SHP.TBL.CNTR		;START DRAWING AT BEGINNING OF SHAPE TABLE

	LDA TILE.LINE.START		;THE STARTING LINE OF THE TILES IN THE CURRENT ROW
	CLC
	ADC #TILE.DEPTH			;ADD DEPTH OF SHAPE TO STARTING LINE IN HEX (# of lines, not the position of last line....so line positions $0-$F is $10 (!16) total lines)
	STA TILE.LINE.STOP		;SET THE LAST LINE TO DRAW BASED ON THE DEPTH OF THE TILE

.DRAW.LOOP	NOP

	LDX TILE.LINE			;LOAD LINE IN X REGISTER
	
	LDA PAGE.OPPOSITE		;SPECIFY PAGE TO GET ADDRESS FOR (SHOULD BE BACKGROUND PAGE)
	JSR GET.LINE.ADDRESS	;GET LINE ADDRESS
							
	LDY SHP.TBL.CNTR		;LOAD Y WITH SHAPE TABLE COUNTER
	LDA (SHAPE),Y			;LOAD SHAPE BYTE (1st screen byte of the tile)
					
					STA $8000,Y		;LOG BYTES PLOTTED TO SCREEN
	LDY SCREEN.BYTE			;SCREEN BYTE INDEX IN Y REGISTER	
	STA (LINE.BASE.ADDR),Y	;PLOT (1st screen byte)
	
	INC SHP.TBL.CNTR		;NEXT SHAPE BYTE, NEXT TILE LINE
	INC SCREEN.BYTE			;SWITCH TO 2ND SCREEN BYTE IN THE TILE
	
	LDY SHP.TBL.CNTR		;LOAD Y WITH SHAPE TABLE COUNTER
	LDA (SHAPE),Y			;LOAD SHAPE BYTE (2nd screen byte of the tile)
	LDY SCREEN.BYTE			;SCREEN BYTE INDEX IN Y REGISTER	
	STA (LINE.BASE.ADDR),Y				;PLOT (2st screen byte)
	
	DEC SCREEN.BYTE			;SWITCH BACK TO 1ST SCREEN BYTE IN THE TILE	;**OPT** if the counters are updated after the CMP/branch it might save 1 INC SCREEN.BYTE instruction in the main loop because SCREEN.BYTE will be in 2nd position when this loop ends. 
	INC TILE.LINE			;NEXT TILE LINE
	INC SHP.TBL.CNTR		;NEXT SHAPE BYTE
	
	LDA TILE.LINE				
	CMP TILE.LINE.STOP		;IS TILE DONE?							
	BCC .DRAW.LOOP			;IF NO, DRAW NEXT LINE (BCC: is ACC < CMP value)
	
	INC SCREEN.BYTE			;IF YES, NEXT TILE
    INC SCREEN.BYTE		

	
.RESTORE.REGISTERS
	PLA
	TAX
	
	RTS						

	
	
;======INCLUDE FILES======

				.IN 	C:\MY_CODE\INCLUDES_LIBS\routines_graphics
				.IN 	C:\MY_CODE\INCLUDES_LIBS\tile_functions
				.IN 	C:\MY_CODE\INCLUDES_LIBS\routines_math	
;				.IN 	C:\MY_CODE\INCLUDES_LIBS\routines_common
				
;======DEFINE VARIBLES======
GRAPHICS 			.EQ	$C050
HIRES				.EQ	$C057
PAGE1				.EQ	$C054
MIXOFF				.EQ	$C052
PAGE2				.EQ	$C055

WAIT				.EQ	$FCA8
DELAY				.EQ	$41				;#CONSTANT


LINE.BASE.ADDR		.EQ	$EA				;2byt
SHAPE				.EQ	$EC				;2byt			;Used by DRAW.TILE. Holds the pointer to the active shape table to be drawn. 	



;SHAPE	.HS	7F.7F.7F.7F.7F.7F.7F.7F.7F.7F.7F.7F.7F.7F.7F.7F.7F.7F.7F.7F.7F.7F.7F.7F.7F.7F.7F.7F.7F.7F.7F.7F																						


;TDATA	.HS																						
GRASS			.HS 08.40.02.01.00.00.00.04.00.00.00.10.20.00.00.00.02.41.00.00.20.04.00.00.00.41.02.00.08.10.00.00
TREES			.HS	00.00.20.01.28.05.2A.15.2A.15.2A.15.2A.15.28.05.20.01.18.03.18.03.18.03.18.03.18.03.1C.07.0E.0E																					
TREES2			.HS	00.00.20.01.28.05.2A.15.2A.15.2A.15.2A.15.28.05.20.01.18.03.18.03.18.03.18.03.18.03.1C.07.0E.0E																					
A				.HS	40.01.40.01.30.06.30.06.30.06.18.0C.18.0C.18.0C.0C.18.7C.1F.7C.1F.06.30.06.30.06.30.03.60.03.60

;GRASS			.HS	00.00.20.01.28.05.2A.15.2A.15.2A.15.2A.15.28.05.20.01.18.03.18.03.18.03.18.03.18.03.1C.07.0E.0E																					
;GRASS2			.HS	00.00.20.01.28.05.2A.15.2A.15.2A.15.2A.15.28.05.20.01.18.03.18.03.18.03.18.03.18.03.1C.07.0E.0E																					
;GRASS3			.HS	00.00.20.01.28.05.2A.15.2A.15.2A.15.2A.15.28.05.20.01.18.03.18.03.18.03.18.03.18.03.1C.07.0E.0E																					
;GRASS4			.HS	00.00.20.01.28.05.2A.15.2A.15.2A.15.2A.15.28.05.20.01.18.03.18.03.18.03.18.03.18.03.1C.07.0E.0E																					


;BLANK			.HS	00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00
;BLANK2			.HS	00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00

;GMAP.TILE.DATA	.HS 01.01.00.01.00.00.01.00.00.01.00.00.00.00.01.01.01.00.00.00.01.01.00.00.00.00.00.01.00.01.00.00.00.01.01.00.00.01.00.01.00.00.00.01.00.01.00.00.00.01.00.00.01.01.01.00.00.01.00.01.01.01.01.01.00.01.01.01.01.01.00.00.00.00.01.00.00.00.01.01.01.01.00.00.01.00.01.00.01.00.00.01.01.00.00.01.01.00.00.01.00.01.01.01.01.00.01.01.00.00.00.01.00.00.01.01.00.00.01.00.00.00.00.01.01.00.01.00.01.01.00.00.00.00.01.00.01.00.01.00.01.01.00.01.00.00.01.00.00.01.00.00.00.00.01.01.00.00.00.01.01.00.01.01.00.01.00.00.01.00.01.01.01.01.00.01.01.00.01.00.00.01.01.00.01.01.01.00.01.00.00.01.01.00.01.00.00.00.00.00.01.01.01.00.00.00.01.00.00.01.01.01.00.01.01.01.00.01.00.01.00.01.00.01.01.00.01.01.00.01.00.00.00.01.01.00.01.01.00.01.00.00.01.00.01.00.01.01.01.00.01.01.00.00.01.00.01.00.00.00.01.01.00.01.01.00.00.01.00.00.00.00.01.01.00.00.01.01.00.00.01.01.01.00.00.00.00.01.01.01.00.01.01.01.00.00.00.01.01.01.00.00.00.00.00.00.00.01.00.00.01.01.01.01.01.00.01.01.00.01.00.01.01.00.01.00.00.00.00.01.01.00.00.00.01.00.00.00.00.01.01.01.01.00.01.00.00.01.01.01.00.01.00.00.01.00.01.01.00.01.00.01.01.00.01.00.01.01.00.00.01.00.00.01.00.00.01.01.00.01.00.01.00.01.00.00.00.00.01.01.00.00.01.00.01.01.01.00.00.01.01.01.01.01.01.01.01.01.01.00.01.00.00.01.00.01.00.01.00.01.00.00.00.00.00.00.00.01.00.00.00.01.01.01.00.00.01.01.01.01.00

;test 64x65 array, doesn't match spreadsheet lookup tool. Had to do with the $0A values. 
;GMAP.TILE.DATA 	.HS	05.01.05.02.05.01.02.02.02.01.05.00.05.01.05.02.0A.01.05.01.02.02.05.02.05.02.03.01.05.02.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.00
GMAP.TILE.DATA 	.HS	05.03.05.01.05.00.02.01.02.01.05.02.05.03.05.00.0A.01.05.01.02.03.05.00.05.01.03.02.05.01.05.01.05.01.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.00.05.01.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.02.03.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.00.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.01.05.02.03.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.0A.00.05.01.02.00.05.02.05.01.03.00


;Line Lokup Tables. LINE.LO is used for Hi-Res Page 1 and Page 2. 
LINE.HO.P2 		.HS 40.44.48.4C.50.54.58.5C.40.44.48.4C.50.54.58.5C.41.45.49.4D.51.55.59.5D.41.45.49.4D.51.55.59.5D.42.46.4A.4E.52.56.5A.5E.42.46.4A.4E.52.56.5A.5E.43.47.4B.4F.53.57.5B.5F.43.47.4B.4F.53.57.5B.5F.40.44.48.4C.50.54.58.5C.40.44.48.4C.50.54.58.5C.41.45.49.4D.51.55.59.5D.41.45.49.4D.51.55.59.5D.42.46.4A.4E.52.56.5A.5E.42.46.4A.4E.52.56.5A.5E.43.47.4B.4F.53.57.5B.5F.43.47.4B.4F.53.57.5B.5F.40.44.48.4C.50.54.58.5C.40.44.48.4C.50.54.58.5C.41.45.49.4D.51.55.59.5D.41.45.49.4D.51.55.59.5D.42.46.4A.4E.52.56.5A.5E.42.46.4A.4E.52.56.5A.5E.43.47.4B.4F.53.57.5B.5F.43.47.4B.4F.53.57.5B.5F
LINE.HO.P1 		.HS 20.24.28.2C.30.34.38.3C.20.24.28.2C.30.34.38.3C.21.25.29.2D.31.35.39.3D.21.25.29.2D.31.35.39.3D.22.26.2A.2E.32.36.3A.3E.22.26.2A.2E.32.36.3A.3E.23.27.2B.2F.33.37.3B.3F.23.27.2B.2F.33.37.3B.3F.20.24.28.2C.30.34.38.3C.20.24.28.2C.30.34.38.3C.21.25.29.2D.31.35.39.3D.21.25.29.2D.31.35.39.3D.22.26.2A.2E.32.36.3A.3E.22.26.2A.2E.32.36.3A.3E.23.27.2B.2F.33.37.3B.3F.23.27.2B.2F.33.37.3B.3F.20.24.28.2C.30.34.38.3C.20.24.28.2C.30.34.38.3C.21.25.29.2D.31.35.39.3D.21.25.29.2D.31.35.39.3D.22.26.2A.2E.32.36.3A.3E.22.26.2A.2E.32.36.3A.3E.23.27.2B.2F.33.37.3B.3F.23.27.2B.2F.33.37.3B.3F
LINE.LO			.HS 00.00.00.00.00.00.00.00.80.80.80.80.80.80.80.80.00.00.00.00.00.00.00.00.80.80.80.80.80.80.80.80.00.00.00.00.00.00.00.00.80.80.80.80.80.80.80.80.00.00.00.00.00.00.00.00.80.80.80.80.80.80.80.80.28.28.28.28.28.28.28.28.A8.A8.A8.A8.A8.A8.A8.A8.28.28.28.28.28.28.28.28.A8.A8.A8.A8.A8.A8.A8.A8.28.28.28.28.28.28.28.28.A8.A8.A8.A8.A8.A8.A8.A8.28.28.28.28.28.28.28.28.A8.A8.A8.A8.A8.A8.A8.A8.50.50.50.50.50.50.50.50.D0.D0.D0.D0.D0.D0.D0.D0.50.50.50.50.50.50.50.50.D0.D0.D0.D0.D0.D0.D0.D0.50.50.50.50.50.50.50.50.D0.D0.D0.D0.D0.D0.D0.D0.50.50.50.50.50.50.50.50.D0.D0.D0.D0.D0.D0.D0.D0





;Screen/Tile Draw Variables
SCREEN.START.BYTE		.EQ $02					;#CONSTANT		STARTING SCREEN BYTE OF FIRST TILE
SCREEN.START.LINE		.EQ	$08					;#CONSTANT		STARTING LINE OF FIRST TILE
SCREEN.STOP.BYTE		.EQ $22					;#CONSTANT		STOP SCREEN BYTE ON RIGHT SIDE
SCREEN.STOP.LINE		.EQ	$B7					;#CONSTANT		STOP LINE AT SCREEN BOTTOM
SCREEN.BYTE				.BS	$1					;1byt
TILE.LINE				.BS	$1					;1byt
TILE.DEPTH				.EQ $10					;#CONSTANT
TILE.LINE.START			.BS	$1					;1byt
TILE.LINE.STOP			.BS	$1					;1byt
SHP.TBL.CNTR			.BS	$1					;1byt


;MAP POSITION VARIABLES
;
;TILE ID number							not a variable, but is term used to describe the value stored in GMAP, from which other variables such as SMAP, SMAP.CURRENT, and GMAP.LOOKUP are dervied. The tile ID is a unique reference number to a specific tile on the map (from a human perspective). To the computer it is meaningful because the value of Tile ID is also equal to the quantity of tiles on the map in GMAP.TILE.DATA up to and including the tile assocaited with Tile ID. 
GMAP					.BS $2			;Tracks the position on the map in computer terms. Specifically, it is the tile ID number of the tile at the center of the screen where the player stands. 
GMAP.X					.BS	$1			;Future use. compass tracking, longitude. 
GMAP.Y					.BS $1			;Future use. compass tracking, latitude. 
SMAP					.EQ $7200
SMAP.CURRENT			.EQ $7202


;MAP MOVEMENT OFFSETS
OFFSET.UP				.EQ $40		;#CONSTANT (negative offset)
OFFSET.DOWN				.EQ $40		;#CONSTANT
OFFSET.LEFT				.EQ $01		;#CONSTANT (negative offset)
OFFSET.RIGHT			.EQ $01		;#CONSTANT 
OFFSET.SCREEN			.EQ	$148		;#CONSTANT (negative offset)



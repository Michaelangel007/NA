                .CR     6502            Use 6502 overlay
				.OR		$6300			**Always put before .TF directive and never use again in program
				.TF     TEST.BIN,BIN
				.EF		errors
				;.LI 	OFF				Switches the assembler machine code conversion listing off so errors are easier to see				
				.LF		C:\MY_CODE\LIST
				;				***For include files, look at end of program, before variable definitions. 


;STATUS NOTES, V20151212.12.35
;
;This version features fully functioning movement, and hi-res character generation.
;
;Technical notes:
;Methodology
;	*Screen is drawn in full at first launch, then screen scrolling is used for movement
;	*DRAW.SCREEN & all movement routines now uses SCREEN.TILE.DATA (contains a full screen of tiles)
;	*move routines still to a call to tile.lookup.screen rather than scrolling the tile data
;	*no master indexing of GMAP.TILE.DATA is being done.
;	*TILE.LOOKUP.INDEX has no capability to use the last index
;
;Bug Fixes
;	*location of center tile fixed (GMAP & OFFSET.SCREEN)



;=======PROGRAM START======

;	JMP DRIVER		;don't turn graphics mode on, so register output is visible from monitor prompt on BRK (testing)	

;Turn Hi-RES ON
	
PGM	NOP
	
;	LDA #$00		;SPECIFY BOTH PAGES FOR CLEAR SCREEN
;	JSR SCLEAR		;CLEAR SCREEN BEFORE TURNING ON GRAPHICS (AVOIDS UNSIGHTLY FLASH OF RANDOM DOTS) 
		
	LDA GRAPHICS	;TURN ON GRAPHICS MODE
	LDA HIRES		;SELECT HI-RES MODE
	LDA	PAGE1		;SELECT PAGE 1
	LDA MIXOFF		;SELECT FULL SCREEN GRAPHICS (PAGE 1)

;====================MAIN PROGRAM============

DRIVER

;**OPT** THIS CAN BE REMOVED	
	LDA #$00		;SPECIFY BOTH PAGES FOR CLEAR SCREEN
	JSR SCLEAR		;CLEAR SCREEN BEFORE TURNING ON GRAPHICS (AVOIDS UNSIGHTLY FLASH OF RANDOM DOTS) 
	
	
;NOT SURE WHERE THIS SHOULD GO, PROBABLY AT VERY START OF GAME LAUNCH, PROBABLY FROM THERE IT IS ALL CALLS TO FLIP.PAGE
	LDA #$01						;
	STA PAGE.FOREGROUND		;DRAW.TILE WILL DRAW THE OPPOSITE PAGE FROM THAT SPECIFED BY THIS VARIABLE
	LDA #$02
	STA PAGE.BACKGROUND	
	LDA	PAGE1
	
;SETUP STARTING POSITION ON THE MAP
	;$01 50 is the position I'm troubleshooting. move 1 west and there is grass where there couldn't be at bottom of new column (left side of screen)
	LDA #$49				;$49 is upper left corner. $2B is one row up, 5 rows left of the lower right corner. 
	STA GMAP				;$08,0D IS ANOTHER GOOD LOCATION
	LDA #$01				;$01 is upper left corner. $0D is one row up, 5 rows left of the lower right corner. 
	STA GMAP+$1
	
;init arrays to test darkness: scolling dark data & before
	LDY #$00
.LOOP
	LDA #$00
	STA SCREEN.DARK.DATA, Y
	STA SCREEN.DARK.DATA_BEFORE, Y	
	#$BA
	BEQ .DONE
	INY
	JMP .LOOP
.DONE

	
			;LDA GMAP					;LOAD TILE_ID OF CURRENT MAP POSITION
			;STA OP1
			;LDA GMAP+$1
			;STA OP1+$1
						
			;LDA #OFFSET.SCREEN			;CALCULATE TILE_ID OF TILE IN UPPER LEFT CORNER OF SCREEN
			;STA OP2
			;LDA /OFFSET.SCREEN
			;STA OP2+$1
						
			;JSR SBC.16					;GMAP(2) - SCREEN.OFFSET.LO/HO (2)
					
			;LDA RESULT					;SAVE TILE_ID OF UPPER LEFT SCREEN TILE
			;STA SMAP
			;STA SMAP.CURRENT
			;LDA RESULT+$1
			;STA SMAP+$1
			;STA SMAP.CURRENT+$1
			
			
			;LDX #$11
			;JSR DRAW.COLUMN.SINGLE
		
			;LDA #$07
			;STA GMAP.LOOKUP
			;LDA #$02
			;STA GMAP.LOOKUP+$1
			;LDA #$01
			;JSR TILE.LOOKUP.SINGLE
			;LDA #$01
			;STA GMAP.LOOKUP
			;LDA #$01
			;STA GMAP.LOOKUP+$1
			;LDA #$01
			;JSR TILE.LOOKUP.SINGLE
			;LDA #$06
			;STA GMAP.LOOKUP
			;LDA #$01
			;STA GMAP.LOOKUP+$1
			;LDA #$00
			;JSR TILE.LOOKUP.SINGLE
			;***GET RETURN VALUE FROM SAVED.ACC ($80BB)
			;LDA TEXT
			;LDA PAGE1
			;BRK
;	JSR DRIVER.DARKNESS
;		BRK




	;LDY #$12
	;LDA #$00
	;STA SCREEN.TILE.DATA+$12
	
	;JSR DRAW.TILE.SINGLE
	
	;LDY #$AA
	;LDA #$01
	;STA SCREEN.TILE.DATA+$AA
	
	;JSR DRAW.TILE.SINGLE
	
	;LDY #$12
	;JSR ERASE.TILE
	
	

				
	JSR DRAW.SCREEN
	JSR DRAW.TILE.PLAYER
	JSR FLIP.PAGE
	JSR PAGE.MIRROR
	
	;LDA PAGE.BACKGROUND
	;STA PAGE.BACKGROUND.SAVE
	
.KEYIN  	
	
	LDA #$04
	STA SCREEN.TILE.DATA+$B2
	
	LDY #$B2
	JSR DRAW.TILE.SINGLE
	JSR FLIP.PAGE
			
	LDA #$05
	STA SCREEN.TILE.DATA+$B2
	
	LDY #$B2
	JSR DRAW.TILE.SINGLE
	JSR FLIP.PAGE
		
	LDA $C000	
    BPL .KEYIN
    STA $C010               ;CLR LAST KEY
		
	CMP #$A4			;UP ARROW
	BEQ .NORTH
	CMP #$8A			;DOWN ARROW
	BEQ	.SOUTH
	CMP #$95			;RIGHT ARROW
	BEQ .EAST
	CMP #$88			;LEFT ARROW
	BEQ	.WEST
	CMP #$D1			;LEFT ARROW
	BEQ	.QUIT
	
;ANY OTHER KEY PRESSED RESULTS IN NORTH	
.NORTH
	JSR MOVE.NORTH
	JMP .KEYIN
	
.SOUTH
	JSR MOVE.SOUTH
	JMP .KEYIN

.EAST
	JSR MOVE.EAST
	JMP .KEYIN

.WEST 
	JSR MOVE.WEST	
	JMP .KEYIN

.QUIT
	LDA TEXT
	LDA PAGE1
	BRK
	;JSR STOP


DRAW.SCREEN		;=============DRAWS SCREEN FROM TILE DATA, ANYWHERE ON THE MAP=========
;PARAMTERS: GMAP, PAGE.FOREGROUND, PAGE.BACKGROUND
;RETURN: NONE


.INIT.MAP

	JSR TILE.LOOKUP.SCREEN
	
	LDA SMAP
	STA SMAP.CURRENT
	LDA SMAP+$1
	STA SMAP.CURRENT+$1

.INIT.SCREEN					;SETUP BYTE, LINE, DEPTH
	LDY #$00					;Y-REG IS THE INDEX FOR SCREEN.TILE.DATA, AND REFERS AND REFERS TO THE TILE #

	LDA	#SCREEN.DRAW.START_BYTE											;**OPT** THIS IS DUPLICATE
	STA SCREEN.DRAW.CURRENT_BYTE				;SET STARTING SCREEN BYTE			;**OPT** THIS IS DUPLICATE
	LDA #SCREEN.DRAW.START_LINE										
	STA TILE.LINE				;SET CURRENT LINE TO PLOT WITHIN TILE	
	STA TILE.LINE.START			;SET STARTING LINE FOR TILES IN ROW 0

	
;**OPT** when this is used for drawing the screen at game start or first entering a map, this is 
;probably fine. we shouldn't need to clear the entire screen for movement, but that will not flow
;through draw.screen so it will probably get setup correctly to begin with. This is a reminder
;note to thing about if screen clears are being handled most efficiently in general.
	
.CLEAR.SCREEN					;CLEAR BACKGROUND PAGE (WHERE DRAW.TILE WILL PLOT TO)
	LDA #$03
	JSR SCLEAR					
			

.LOOP
	LDA #SCREEN.DRAW.START_BYTE		;RESET SCREEN.DRAW.CURRENT_BYTE TO THE FIRST TILE COLUMN
	STA SCREEN.DRAW.CURRENT_BYTE
	
	JSR DRAW.ROW
				

	LDA SMAP.CURRENT			;ADVANCE TO NEXT ROW ON THE SCREEN
	STA OP1
	LDA SMAP.CURRENT+$1
	STA OP1+$1
	LDA #OFFSET.DOWN
	STA OP2
	LDA #$00
	STA OP2+$1
	
	JSR ADC.16						;SMAP.CURRENT(2) + #OFFSET.DOWN(1)
	
	LDA RESULT
	STA SMAP.CURRENT
	LDA RESULT+$1
	STA SMAP.CURRENT+$1

	LDA TILE.LINE.START				;ADVANCE LINE TO NEXT ROW OF TILES
	CLC
	ADC #TILE.DEPTH
	STA TILE.LINE.START
	STA TILE.LINE
	CMP	#SCREEN.DRAW.STOP_LINE		;READY TO SWITCH TILE COLUMNS? (TILE.LINE should already be in ACC at end of DRAW.TILE) 
	BCS .DRAW.COMPLETE				;IF YES, EXIT (BCS: is ACC >= CMP value)

	JMP .LOOP
	
	
.DRAW.COMPLETE

	LDA #$AA					;THIS VALUE IS USED TO THAT CERTAIN ROUTINES (LIKE DRAW.MISC IN DARKNESS.REVIEW KNOW THAT THEY WERE ENTERED VIA DRAW.SCREEN AND NOT A MOVE ROUTINE)
	STA MOVE.CURRENT
				
	JSR DARKNESS.REVIEW				;UPDATE THE HIDDEN (DARKNESS) TILES ON THE SCREEN BASED ON THE TILE_TYPE VALUES IN SCREEN.TILE.DATA 

;DRAW TEXT
	JMP .SKIP
	JSR HCG.ON
	
	LDA #$24
	STA HTAB	
	LDA #$1
	STA VTAB
	JSR	UPDATE.CHAR.POS
	LDA #$C7
	JSR COUT
	
		
	LDA #$25
	STA HTAB	
	LDA #$1
	STA VTAB
	JSR	UPDATE.CHAR.POS
	LDA #$EF
	JSR COUT
	
	LDA #$26
	STA HTAB	
	LDA #$1
	STA VTAB
	JSR	UPDATE.CHAR.POS
	LDA #$EC
	JSR COUT
	
	LDA #$27
	STA HTAB	
	LDA #$1
	STA VTAB
	JSR	UPDATE.CHAR.POS
	LDA #$E4
	JSR COUT
	
	LDA #$24
	STA HTAB	
	LDA #$2
	STA VTAB
	JSR	UPDATE.CHAR.POS
	LDA #$B9
	JSR COUT
	
		
	LDA #$25
	STA HTAB	
	LDA #$2
	STA VTAB
	JSR	UPDATE.CHAR.POS
	LDA #$B9
	JSR COUT
	
	LDA #$26
	STA HTAB	
	LDA #$2
	STA VTAB
	JSR	UPDATE.CHAR.POS
	LDA #$B9
	JSR COUT
	
	LDA #$27
	STA HTAB	
	LDA #$2
	STA VTAB
	JSR	UPDATE.CHAR.POS
	LDA #$B9
	JSR COUT
.SKIP	
	RTS

DRAW.ROW.SINGLE ;=========DRAWS A SINGLE TILE ROW AT SPECIFIED LOCATION==========
;PARAMETERS: SMAP, X-REG (TILE ROW # TO DRAW)
;RETURN: NONE	
;ENTRANCE: DIRECT

.INIT.MAP

	LDA SMAP					;**OPT** speed memory. calling as a precaution until after most map development is done, I'm not sure if it will be needed. 
	STA SMAP.CURRENT
	STA GMAP.LOOKUP				;SET GMAP.LOOKUP FOR CASE: DEFAULT ROW
	LDA SMAP+$1
	STA SMAP.CURRENT+$1
	STA GMAP.LOOKUP+$1				;SET GMAP.LOOKUP+$1 FOR CASE: DEFAULT ROW
				
.INIT.SCREEN					;SETUP BYTE, LINE, DEPTH

;DETERMINE ROW TO DRAW BASED ON X-REG VALUE	
	CPX #$0A
	BEQ .ROW0A

;DEFAULT TO ROW0
	LDY #$00					;INDEX FOR SCREEN.TILE.DATA USED IN SCREEN.DRAW.ROW
	LDX #$00					;INDEX FOR SCREEN.TILE.DATA USED IN TILE.LOOKUP.ROW
	;GMAP.LOOKUP FOR THIS CASE WAS SET ABOVE IN INIT.MAP
	
	LDA	#SCREEN.DRAW.START_LINE										
	STA TILE.LINE.START			;SET STARTING LINE TO DRAW ON
	STA TILE.LINE
	
	
	JMP .COMMON
	
.ROW0A
	LDY #SCREEN.ARRAY.LAST_ROW_START	;INDEX FOR SCREEN.TILE.DATA	USED IN SCREEN.DRAW.ROW
	LDX #SCREEN.ARRAY.LAST_ROW_START	;INDEX FOR SCREEN.TILE.DATA USED IN TILE.LOOKUP.ROW
	
	LDA #SCREEN.DRAW.STOP_LINE2		;THIS ALTERNATE VALUE IS +1 IS THE FIRST LINE IN THE LAST TILE ROW, WHICH IS WHERE WE WANT TO START TO DRAW TILES IN THE LAST ROW	
	CLC								;	I'M NOT SURE REALLY WHY IT'S +1, I DIDN'T CALCUALTE IT OUT, I JUST ADDED +1 TO SEE IF IT WOULD FIX A SLIGHT GLITCH WHEN MOVING SOUTH (SCROLLING UP), AND IT DID.
	ADC #$01	
	STA TILE.LINE.START				;SET STARTING LINE TO DRAW ON
	STA TILE.LINE

;ADJUST SMAP.CURRENT TO FIRST TILE IN LAST ROW
	LDA GMAP
	STA OP1
	LDA GMAP+$1
	STA OP1+$1
	
	LDA #OFFSET.SCREEN.LL
	STA OP2
	LDA /OFFSET.SCREEN.LL
	STA OP2+$1
	
	JSR ADC.16				;GMAP(2) + OFFSET.SCREEN.LL(1)
;**OPT** Speed. Put the code for 16-bit math functions, in graphics routinee, in-line, instead of JSR

	LDA RESULT
	STA GMAP.LOOKUP
	LDA RESULT+$1
	STA GMAP.LOOKUP+$1
	
	
.COMMON
	
	JSR TILE.LOOKUP.INDEX
	JSR TILE.LOOKUP.ROW
		
	LDA	#SCREEN.DRAW.START_BYTE									
	STA SCREEN.DRAW.CURRENT_BYTE				;SET STARTING SCREEN BYTE		
	
	JSR DRAW.ROW

	RTS

DRAW.ROW		;=============DRAWS ROW FROM TILE DATA, AT SPECIFIED LOCATION=========
;PARAMTERS: SMAP.CURRENT, #SCREEN.BYTE.START, SCREEN.DRAW.START_LINE, TILE_LINE_START, TILE_LINE
;	NOTE: SET TILE_LINE == TO TILE_LINE_START before calling this routine. This saves an LDA instruction versus doing an init of TILE_LINE in this routine. 
;RETURN: NONE
;ENTRANCE: DRAW.SCREEN, DRAW.ROW.SINGLE

.LOOP					

	LDA SCREEN.TILE.DATA,Y			;LOAD TILE_TYPE OF THE NEXT TILE IN CURRENT ROW AND CALCUALTE THE 
	
	LDX SCREEN.DARK.DATA,Y
	CPX #$01
	BEQ .SKIPDRAW

	
	ASL ;X2							;	OFFSET TO THE SHAPE TABLE FOR THAT TILE. ALL TILE SHAPE TABLES
	ASL ;X4							;	 ARE 32byts, SO THE OFFSET IS (TILE_TYPE * 32)
	ASL ;X8							;	 THE OFFSET IS ADDED TO THE ADDRESS OF THE FIRST TILE SHAPE TABLE
	ASL ;X16						;	 TO CALCUALTE THE ADDRESS OF THE SHAPE TABLE FOR THE CURRENT TILE.
	ASL ;X32
				
	STA OP1							;SAVE RESULT OF MULTIPLCATION (ASLs) ABOVE				
	LDA #$00
	STA OP1+$1						
				
	LDA #GRASS						;GRASS IS THE FIRST SHAPE TABLE. 
	STA OP2
	LDA /GRASS
	STA OP2+$1
					
	JSR ADC.16						;CURRENT TILE SHAPE OFFSET + ADDRESS OF FIRST TILE SHAPE TABLE (GRASS)
	
	LDA RESULT
	STA SHAPE
	LDA RESULT+$1
	STA SHAPE+$1

	JSR DRAW.TILE					;DRAW SHAPE
	
	
	LDA TILE.LINE.START
	STA TILE.LINE					; RESET CURRENT LINE IN TILE TO DRAW TO THE STARTING LINE

.SKIPDRAW
	INY								;INCREMENT COUNTER SO WE GET THE NEXT TILE_TYPE ON THE NEXT INTERATION OF .LOOP

	INC SCREEN.DRAW.CURRENT_BYTE					;NEXT TILE
    INC SCREEN.DRAW.CURRENT_BYTE	

	LDA #SCREEN.DRAW.STOP_BYTE			;AT RIGHT SIDE SCREEN EACH?
	CMP SCREEN.DRAW.CURRENT_BYTE
	BCS .LOOP						;IF NO, SWITCH OVER TO NEXT ROW (BCS: is ACC >= CMP value)


.EXIT	
	RTS

DRAW.COLUMN.SINGLE ;=========DRAWS A SINGLE TILE COLUMN AT SPECIFIED LOCATION==========
;PARAMETERS: SMAP, X-REG (TILE COLUMN # TO DRAW)
;RETURN: NONE	
;ENTRANCE: DIRECT

.INIT.MAP
	
	LDA SMAP					;**OPT** speed memory. calling as a precaution until after most map development is done, I'm not sure if it will be needed. 
	STA SMAP.CURRENT
	LDA SMAP+$1
	STA SMAP.CURRENT+$1
	
.INIT.SCREEN					;SETUP BYTE, LINE, DEPTH

;DETERMINE COLUMN TO DRAW BASED ON X-REG VALUE	
	CPX #$11
	BEQ .COLUMN11 

;DEFAULT TO COLUMN0
	LDX #$00									;ARRAY ELEMENT OF FIRST TILE IN THE COLUMN, USED IN TILE.LOOKUP.COLUMN
	LDA #$BB
	STA SCREEN.ARRAY.STOP_VALUE					;LAST TILE IN COLUMN, USED TO DETECT END OF DATA
	
	LDA	#SCREEN.DRAW.START_BYTE											
	STA SCREEN.DRAW.CURRENT_BYTE				;SET STARTING SCREEN BYTE			

;LOAD NEW COLUMN OF TILES	
	LDA SMAP.CURRENT							;SET SMAP.CURRENT AS THE STARTING TILE FOR THE NEW COLUMN
	STA GMAP.LOOKUP
;	DEC GMAP.LOOKUP
	LDA SMAP.CURRENT+$1
	STA GMAP.LOOKUP+$1
				
	JSR TILE.LOOKUP.COLUMN						;LOAD NEW COLUMN OF TILES INTO SCREEN.TILE.DATA

	JMP .COMMON
	
.COLUMN11
	LDX #SCREEN.ARRAY.LAST_COLUMN_START			;ARRAY ELEMENT OF LAST TILE IN THE COLUMN, TILE.LOOKUP.COLUMN
	LDA #$CB
	STA SCREEN.ARRAY.STOP_VALUE					;LAST TILE IN COLUMN, USED TO DETECT END OF DATA

	LDA	#SCREEN.DRAW.STOP_BYTE									
	STA SCREEN.DRAW.CURRENT_BYTE				;SET STARTING SCREEN BYTE	
	
	;LOAD NEW COLUMN OF TILES	
	LDA SMAP.CURRENT							;ADJUST SMAP.CURRENT TO THE 1ST TILE OF THE LAST COLUMN
	STA OP1
	LDA SMAP.CURRENT+$1
	STA OP1+$1
	LDA #SCREEN.ROW.SIZE		;CALCULATE TILE_ID OF TILE IN UPPER LEFT CORNER OF SCREEN
	STA OP2
	LDA #$00
	STA OP2+$1
				
	JSR ADC.16					;SMAP.CURRENT(2) - #SCREEN.ROW.SIZE(1)
			
	LDA RESULT					;SAVE TILE_ID OF UPPER RIGHT SCREEN TILE
	STA SMAP.CURRENT
	STA GMAP.LOOKUP				;SET SMAP.CURRENT AS THE STARTING TILE FOR THE NEW COLUMN
	DEC GMAP.LOOKUP				;#SCREEN.ROW.SIZE, USED ABOVE, IS 1 TOO MANY, THIS DEC CORRECTS THAT. 
	
	LDA RESULT+$1
	STA SMAP.CURRENT+$1
	STA GMAP.LOOKUP+$1
				
	JSR TILE.LOOKUP.COLUMN						;LOAD NEW COLUMN OF TILES INTO SCREEN.TILE.DATA
	

.COMMON


	LDA #SCREEN.DRAW.START_LINE										
	STA TILE.LINE				;SET CURRENT LINE TO PLOT WITHIN TILE	
	STA TILE.LINE.START			;SET STARTING LINE FOR TILES IN ROW 0
	

	JSR DRAW.COLUMN	
	RTS
	

DRAW.COLUMN		;=============DRAWS COLUMN FROM TILE DATA, AT SPECIFIED LOCATION=========
;PARAMETERS: SMAP.CURRENT(2)
;RETURN: NONE	
;ENTRANCE: DRAW.COLUMN.SINGLE, (FUTURE)

;FUTURE: if it were useful at some point to draw multiple columns in a row, I think this
;routine could be called from a loop which did two INCs to SCREEN.DRAW.CURRENT_BYTE after the call. HORSE MOVEMENT?
;In this scenario, TILE.LINE.START would need to be rest to the top of the screen. OR, don't increment tile.line.start, 
;at all in this routine and just increment TILE.LINE. I think if one line is added to TILE.LINE at each iteration of TIEL.DRAW, that will
;sync TILE.LINE up with the next tile.

	
;**OPT** MEMORY. MAYBE THIS ROUTINE COULD BE COMBINED WITH THE DRAW.ROW AND ROW OR COLULMN IS
;REQUESTED VIA THE CALLING ROUTINE BY A PARAMETER. 	
		
	LDY #$00						;START WITH 1ST ELEMENT IN SCREEN.TILE.HOPPER ARRAY.
.LOOP					
	LDA SCREEN.TILE.HOPPER,Y			;LOAD TILE_TYPE OF THE NEXT TILE IN CURRENT COLUMN
			
	LDX SCREEN.DARK.HOPPER,Y

	CPX #$01
	BEQ .SKIPDRAW
;			STA TEMP
;			LDA GMAP
;			CMP #$54
;			BNE .TEMP
;			CPY #$08
;			BNE .TEMP
;			LDA TEXT
;			LDA PAGE1
;			BRK
;.TEMP
;	LDA TEMP
	
	ASL ;X2							;	OFFSET TO THE SHAPE TABLE FOR THAT TILE. ALL TILE SHAPE TABLES
	ASL ;X4							;	 ARE 32byts, SO THE OFFSET IS (TILE_TYPE * 32)
	ASL ;X8							;	 THE OFFSET IS ADDED TO THE ADDRESS OF THE FIRST TILE SHAPE TABLE
	ASL ;X16						;	 TO CALCUALTE THE ADDRESS OF THE SHAPE TABLE FOR THE CURRENT TILE.
	ASL ;X32
				
	STA OP1							;SAVE RESULT OF MULTIPLCATION (ASLs) ABOVE				
	LDA #$00
	STA OP1+$1						
				
	LDA #GRASS						;GRASS IS THE FIRST SHAPE TABLE. 
	STA OP2
	LDA /GRASS
	STA OP2+$1
					
	JSR ADC.16						;CURRENT TILE SHAPE OFFSET + ADDRESS OF FIRST TILE SHAPE TABLE (GRASS)
	
	LDA RESULT
	STA SHAPE
	LDA RESULT+$1
	STA SHAPE+$1

				;JSR FLIP.PAGE
				;JSR STOP
				;LDX SCREEN.DRAW.CURRENT_BYTE
				;LDY TILE.LINE.START
				;LDA TEXT
				;LDA PAGE1
				;BRK
	JSR DRAW.TILE					;DRAW SHAPE
	

;**OPT** SPEED/MEMORY. TILE.LINE IS IN ACC AT END OF DRAW.TILE. I MAY BE ABLE TO INCREMENT IT A LINE TO REACH THE START OF THE NEXT TILE INSTEAD OF LOADING TILE.START LINE
;EACH TIME. GIVE EXTRA THOUGHT TO THINKING THIS THROUGH IF THIS ROUTINE ENDS UP BEING CALLED IN A LOOP TO DRAW MULTIPLE COLUMNS. HORSE MOVEMENT?
;

.SKIPDRAW
	INY								;INCREMENT COUNTER SO WE GET THE NEXT TILE_TYPE ON THE NEXT INTERATION OF .LOOP
	
	LDA TILE.LINE.START				;ADVANCE LINE TO NEXT ROW OF TILES
	CLC
	ADC #TILE.DEPTH
	STA TILE.LINE.START
	STA TILE.LINE		
	CMP	#SCREEN.DRAW.STOP_LINE			;READY TO SWITCH TILE COLUMNS?
	BCS .EXIT						;IF YES, EXIT (BCS: is ACC >= CMP value)

	JMP .LOOP

.EXIT
	RTS

DRAW.TILE.SINGLE
;PARAMTERS: Y-REG (SCREEN POSITION AS MAPPED TO ELEMENT OF SCREEN.TILE.DATA)
;RETURN: NONE
;ENTRANCE: DIRECT

;			JMP .EXIT


;			STA TEMP
;			LDA GMAP
;			CMP #$54
;			BNE .TEMP
;			CPY #$88
;			BNE .TEMP
;			LDA TEXT
;			LDA PAGE1
;			BRK
;.TEMP
	
	STY TEMP
	LDA #SCREEN.ARRAY.LAST_ELEMENT
	CMP TEMP
	BCS .START
	JMP .ERROR
	
.START		
	LDA SCREEN.TILE.DATA,Y			;LOAD TILE_TYPE OF THE NEXT TILE IN CURRENT ROW AND CALCUALTE THE 

;	LDX SCREEN.DARK.DATA,Y
;	CPX #$01
;	BEQ .SKIPDRAW
	
	ASL ;X2							;	OFFSET TO THE SHAPE TABLE FOR THAT TILE. ALL TILE SHAPE TABLES
	ASL ;X4							;	 ARE 32byts, SO THE OFFSET IS (TILE_TYPE * 32)
	ASL ;X8							;	 THE OFFSET IS ADDED TO THE ADDRESS OF THE FIRST TILE SHAPE TABLE
	ASL ;X16						;	 TO CALCUALTE THE ADDRESS OF THE SHAPE TABLE FOR THE CURRENT TILE.
	ASL ;X32
				
	STA OP1							;SAVE RESULT OF MULTIPLCATION (ASLs) ABOVE				
	LDA #$00
	STA OP1+$1						
				
	LDA #GRASS						;GRASS IS THE FIRST SHAPE TABLE. 
	STA OP2
	LDA /GRASS
	STA OP2+$1
					
	JSR ADC.16						;CURRENT TILE SHAPE OFFSET + ADDRESS OF FIRST TILE SHAPE TABLE (GRASS)
	
	LDA RESULT
	STA SHAPE
	LDA RESULT+$1
	STA SHAPE+$1
	
	LDA SCREEN.INDEX.TILE_SBYTE,Y
	STA	SCREEN.DRAW.CURRENT_BYTE
	
	LDA SCREEN.INDEX.TILE_LINE,Y
	STA TILE.LINE.START
	STA TILE.LINE
				
	JSR DRAW.TILE
	
.EXIT
	RTS
	
.ERROR
;ERROR REPORTED BY DRAW.TILE.SINGLE Y-REG VALUE > LAST ELEMENT OF SCREEN.TILE.DATA, WHICH
;IN EFFECT REFERED TO A TILE NOT ON THE SCREEN VIEW. 
	LDA TEXT
	LDA PAGE1
	BRK	

DRAW.TILE.PLAYER
;PARAMTERS:  NONE
;RETURN: NONE
;ENTRANCE: DIRECT

	LDY #$5D
						
	LDA #PLAYER_ICON					
	STA SHAPE
	LDA /PLAYER_ICON
	STA SHAPE+$1
	
	LDA SCREEN.INDEX.TILE_SBYTE,Y
	STA	SCREEN.DRAW.CURRENT_BYTE
	
	LDA SCREEN.INDEX.TILE_LINE,Y
	STA TILE.LINE.START
	STA TILE.LINE
				
	JSR DRAW.TILE
	RTS
	

	
DRAW.TILE
;**OPT** Speed. Make simular optimizations as was done with the scrolling routines.
;		 such as, avoid JSRs (like get line address), avoid INC/DEC (use index registeres wherever possible), etc.
;		 This will help with movement speed, in addition to draw.screen, because there is always 1 column/row drawn
;		 with each move after the screen scrolls.
.SAVE.REGISTERS
	TXA
	PHA
	TYA
	PHA

.START
	
	LDA #$00
	STA SHP.TBL.CNTR		;START DRAWING AT BEGINNING OF SHAPE TABLE

	LDA TILE.LINE.START		;THE STARTING LINE OF THE TILES IN THE CURRENT ROW
	CLC						;*OPT* I I THINK ALL CLS CAN BE REMOVED WHEN I'M NOT EXPECTING AN OVERFLOW
	ADC #TILE.DEPTH			;ADD DEPTH OF SHAPE TO STARTING LINE IN HEX (# of lines, not the position of last line....so line positions $0-$F is $10 (!16) total lines)
	STA TILE.LINE.STOP		;SET THE LAST LINE TO DRAW BASED ON THE DEPTH OF THE TILE

.DRAW.LOOP

	LDX TILE.LINE			;LOAD LINE IN X REGISTER
	
	LDA PAGE.BACKGROUND		;SPECIFY PAGE TO GET ADDRESS FOR (SHOULD BE BACKGROUND PAGE)
	JSR GET.LINE.ADDRESS1	;GET LINE ADDRESS
							
	LDY SHP.TBL.CNTR		;LOAD Y WITH SHAPE TABLE COUNTER
	LDA (SHAPE),Y			;LOAD SHAPE BYTE (1st screen byte of the tile)

	LDY SCREEN.DRAW.CURRENT_BYTE			;SCREEN BYTE INDEX IN Y REGISTER	
	STA (LINE.BASE.ADDR1),Y	;PLOT (1st screen byte)
	
	INC SHP.TBL.CNTR		;NEXT SHAPE BYTE, NEXT TILE LINE
	INC SCREEN.DRAW.CURRENT_BYTE			;SWITCH TO 2ND SCREEN BYTE IN THE TILE
	
	LDY SHP.TBL.CNTR		;LOAD Y WITH SHAPE TABLE COUNTER
	LDA (SHAPE),Y			;LOAD SHAPE BYTE (2nd screen byte of the tile)
	LDY SCREEN.DRAW.CURRENT_BYTE			;SCREEN BYTE INDEX IN Y REGISTER	
	STA (LINE.BASE.ADDR1),Y				;PLOT (2st screen byte)
	
	DEC SCREEN.DRAW.CURRENT_BYTE			;SWITCH BACK TO 1ST SCREEN BYTE IN THE TILE	;**OPT** if the counters are updated after the CMP/branch it might save 1 INC SCREEN.DRAW.CURRENT_BYTE instruction in the main loop because SCREEN.DRAW.CURRENT_BYTE will be in 2nd position when this loop ends. 
	INC TILE.LINE			;NEXT TILE LINE
	INC SHP.TBL.CNTR		;NEXT SHAPE BYTE
	
	LDA TILE.LINE				
	CMP TILE.LINE.STOP		;IS TILE DONE?							
	BCC .DRAW.LOOP			;IF NO, DRAW NEXT LINE (BCC: is ACC < CMP value)	

	
.RESTORE.REGISTERS
	PLA
	TAY
	PLA
	TAX
	
	RTS						
	
ERASE.TILE
;PARAMTERS: X-REG (SCREEN POSITION TO ERASE, AS MAPPED TO ELEMENT OF SCREEN.TILE.DATA)
;RETURN: NONE
;ENTRANCE: DIRECT

;NOTE: IN THE CALLING ROUTINE (DARKNESS.CALCULATE), AT THE TIME THIS ROUTINE IS CALLED, Y-REG CONTAINS THE SCREEN POSITION OF THE OBSCURING TILE AND X-REG CONTAINS THE POSITION OF THE CURRENT TILE WHICH HAS BEEN FLAGGED AS DARK

;		**OPT** Speed. This code could be place in-line with each of the 7 "TYPE" subroutines in darkness_functions. so far that is the only place it's used. this would elimiate a JSR/RTS

;			JMP .EXIT


;			LDA GMAP
;			CMP #$54
;			BNE .TEMP
;			CPX #$88			; SHOUD HAVE BEEN SET DARK BY $68 VIA TYPE2
;			BNE .TEMP
			;JSR FLIP.PAGE
			;JSR KEYIN
;			LDA TEXT
;			LDA PAGE1
;			BRK
;.TEMP

.SAVE.REGISTERS
	TXA
	PHA
	TYA
	PHA
	
	;TROUBLESHOOTING HOOK #1
		;CPX #$9D
		;BNE .TEMP
		;LDX #$AA
		;LDY #$AA
		;BRK

	STX TEMP
	LDA #SCREEN.ARRAY.LAST_ELEMENT
	CMP TEMP
	BCS .START
	JMP .ERROR
	
.START		
	LDA SCREEN.INDEX.TILE_SBYTE,X
	TAY
	LDA SCREEN.INDEX.TILE_LINE,X
	TAX

	
	TXA
	CLC						;*OPT* I I THINK ALL CLS CAN BE REMOVED WHEN I'M NOT EXPECTING AN OVERFLOW
	ADC #TILE.DEPTH			;ADD DEPTH OF SHAPE TO STARTING LINE IN HEX (# of lines, not the position of last line....so line positions $0-$F is $10 (!16) total lines)
	STA TILE.LINE.STOP		;SET THE LAST LINE TO DRAW BASED ON THE DEPTH OF THE TILE
	
.DRAW.LOOP

.GET.LINE.ADDRESS
	LDA PAGE.BACKGROUND		;SPECIFY PAGE TO GET ADDRESS FOR (SHOULD BE BACKGROUND PAGE)
	CMP #$02
	BEQ .ADDR.LOOKUP.PAGE2
	
.ADDR.LOOKUP.PAGE1	
	LDA LINE.HO.P1,X			;GET LINE ADDRESS
	STA LINE.BASE.ADDR1+$1
	LDA LINE.LO,X
	STA LINE.BASE.ADDR1
	JMP .LOOKUP_COMPLETE

.ADDR.LOOKUP.PAGE2
	LDA LINE.HO.P2,X			;GET LINE ADDRESS
	STA LINE.BASE.ADDR1+$1
	LDA LINE.LO,X
	STA LINE.BASE.ADDR1	
.LOOKUP_COMPLETE

	LDA #$00
	STA (LINE.BASE.ADDR1),Y		;ERASE (1st screen byte)		
	INY
	STA (LINE.BASE.ADDR1),Y		;ERASE (2st screen byte)
	
	DEY							;SWITCH BACK TO 1ST SCREEN BYTE IN THE TILE	
	INX							;NEXT TILE LINE		

	CPX TILE.LINE.STOP		;IS TILE DONE?							
	BCC .DRAW.LOOP			;IF NO, DRAW NEXT LINE (BCC: is ACC < CMP value)	

	
.RESTORE.REGISTERS
	PLA
	TAY
	PLA
	TAX

.EXIT	
	RTS	

.ERROR
;ERROR REPORTED BY ERASE.TILE. X-REG VALUE > LAST ELEMENT OF SCREEN.TILE.DATA, WHICH
;IN EFFECT REFERED TO A TILE NOT ON THE SCREEN VIEW. 
	LDA TEXT
	LDA PAGE1
	BRK
	
;======INCLUDE FILES======

				.IN 	C:\MY_CODE\INCLUDES_LIBS\routines_graphics
				.IN 	C:\MY_CODE\INCLUDES_LIBS\movement_manager
				.IN 	C:\MY_CODE\INCLUDES_LIBS\graphics_scrolling
				.IN 	C:\MY_CODE\INCLUDES_LIBS\tile_functions

				.IN 	C:\MY_CODE\INCLUDES_LIBS\routines_text
				.IN 	C:\MY_CODE\INCLUDES_LIBS\routines_math
				.IN 	C:\MY_CODE\INCLUDES_LIBS\routines_general
				
;======DEFINE VARIBLES======
GRAPHICS 			.EQ	$C050
HIRES				.EQ	$C057
PAGE1				.EQ	$C054
MIXOFF				.EQ	$C052
PAGE2				.EQ	$C055

WAIT				.EQ	$FCA8
DELAY				.EQ	$41				;#CONSTANT



SHAPE				.EQ	$FA				;2byt			;Used by DRAW.TILE. Holds the pointer to the active shape table to be drawn. 	


PLAYER_ICON		.HS AA.D5.AA.D5.CA.D4.AA.D5.A8.C5.A8.C5.A2.D1.8A.D4.8A.D4.8A.D4.8A.D4.A2.D1.A2.D1.A2.D1.A2.D1.A8.C5


;AA.D5.8A.D4.AA.D5.AA.D5.A8.C5.A8.C5.A2.D1.8A.D4.8A.D4.8A.D4.8A.D4.A2.D1.A2.D1.A2.D1.A2.D1.A8.C5


;AA.D5.AA.D5.AA.D5.AA.D5.AA.D5.AA.D5.AA.D5.AA.D5.AA.D5.AA.D5.AA.D5.AA.D5.AA.D5.AA.D5.AA.D5.AA.D5

;TILE0
GRASS			.HS 00.00.02.40.00.01.00.00.08.04.20.10.00.00.00.01.02.40.00.00.20.04.00.00.00.41.02.00.00.10.08.00
;TILE1
TREES			.HS	00.00.20.01.28.05.2A.15.2A.15.2A.15.2A.15.28.05.20.01.18.03.18.03.18.03.18.03.18.03.1C.07.0E.0E																					
;TILE2
TREES2			.HS	00.00.20.01.28.05.2A.15.2A.15.2A.15.2A.15.28.05.28.05.78.03.78.03.78.03.78.03.78.03.7C.07.7E.0F
;TILE3
MOUNTAINS1		.HS 40.01.40.01.30.06.30.06.30.06.18.0C.18.0C.18.0C.0C.1C.0C.1E.0C.33.06.33.06.63.46.61.43.61.63.60

;TILE4
FLAG1.1			.HS 00.00.18.11.58.1B.78.0E.38.04.18.00.18.00.18.00.18.00.18.00.18.00.18.00.18.00.18.00.7E.00.7E.00
;TILE5
FLAG1.2			.HS 00.00.18.00.18.00.18.00.38.04.78.0E.58.1B.18.11.18.00.18.00.18.00.18.00.18.00.18.00.7E.00.7E.00


;MOUNTAINS		.HS 40.01.40.01.30.06.30.06.30.06.18.0C.18.0C.18.0C.0C.1C.0C.1C.0C.36.06.33.06.63.46.61.43.61.63.60
;A				.HS	40.01.40.01.30.06.30.06.30.06.18.0C.18.0C.18.0C.0C.18.7C.1F.7C.1F.06.30.06.30.06.30.03.60.03.60

;GRASS			.HS	00.00.20.01.28.05.2A.15.2A.15.2A.15.2A.15.28.05.20.01.18.03.18.03.18.03.18.03.18.03.1C.07.0E.0E																					
;GRASS2			.HS	00.00.20.01.28.05.2A.15.2A.15.2A.15.2A.15.28.05.20.01.18.03.18.03.18.03.18.03.18.03.1C.07.0E.0E																					
;GRASS3			.HS	00.00.20.01.28.05.2A.15.2A.15.2A.15.2A.15.28.05.20.01.18.03.18.03.18.03.18.03.18.03.1C.07.0E.0E																					
;GRASS4			.HS	00.00.20.01.28.05.2A.15.2A.15.2A.15.2A.15.28.05.20.01.18.03.18.03.18.03.18.03.18.03.1C.07.0E.0E																					


;BLANK			.HS	00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00
;BLANK2			.HS	00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00.00

;GMAP.TILE.DATA	.HS 01.01.00.01.00.00.01.00.00.01.00.00.00.00.01.01.01.00.00.00.01.01.00.00.00.00.00.01.00.01.00.00.00.01.01.00.00.01.00.01.00.00.00.01.00.01.00.00.00.01.00.00.01.01.01.00.00.01.00.01.01.01.01.01.00.01.01.01.01.01.00.00.00.00.01.00.00.00.01.01.01.01.00.00.01.00.01.00.01.00.00.01.01.00.00.01.01.00.00.01.00.01.01.01.01.00.01.01.00.00.00.01.00.00.01.01.00.00.01.00.00.00.00.01.01.00.01.00.01.01.00.00.00.00.01.00.01.00.01.00.01.01.00.01.00.00.01.00.00.01.00.00.00.00.01.01.00.00.00.01.01.00.01.01.00.01.00.00.01.00.01.01.01.01.00.01.01.00.01.00.00.01.01.00.01.01.01.00.01.00.00.01.01.00.01.00.00.00.00.00.01.01.01.00.00.00.01.00.00.01.01.01.00.01.01.01.00.01.00.01.00.01.00.01.01.00.01.01.00.01.00.00.00.01.01.00.01.01.00.01.00.00.01.00.01.00.01.01.01.00.01.01.00.00.01.00.01.00.00.00.01.01.00.01.01.00.00.01.00.00.00.00.01.01.00.00.01.01.00.00.01.01.01.00.00.00.00.01.01.01.00.01.01.01.00.00.00.01.01.01.00.00.00.00.00.00.00.01.00.00.01.01.01.01.01.00.01.01.00.01.00.01.01.00.01.00.00.00.00.01.01.00.00.00.01.00.00.00.00.01.01.01.01.00.01.00.00.01.01.01.00.01.00.00.01.00.01.01.00.01.00.01.01.00.01.00.01.01.00.00.01.00.00.01.00.00.01.01.00.01.00.01.00.01.00.00.00.00.01.01.00.00.01.00.01.01.01.00.00.01.01.01.01.01.01.01.01.01.01.00.01.00.00.01.00.01.00.01.00.01.00.00.00.00.00.00.00.01.00.00.00.01.01.01.00.00.01.01.01.01.00

;test 64x64 array, doesn't match spreadsheet lookup tool. Had to do with the $0A values. 
GMAP.TILE.DATA 	.HS	05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.03.05.01.02.00.05.02.05.00.04.00.05.01.05.01.05.03.02.00.02.01.05.01.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.02.05.00.05.02.05.03.02.00.02.01.05.02.05.00.05.03.09.00.05.01.02.00.05.00.05.01.04.00.05.02.05.02.05.03.02.00.02.01.05.03.05.00.05.03.09.00.05.01.02.00.05.02.05.02.04.00.05.02.05.03.05.03.02.00.02.01.05.03.05.00.05.03.09.00.05.01.02.00.05.02.05.01.04.02.05.00.05.03.05.03.02.00.02.01.05.03.05.00.05.03.09.00.05.01.02.00.05.01.05.02.04.00.05.01.05.01.05.03.02.00.02.01.05.01.05.00.05.03.09.02.05.01.02.00.05.02.05.00.04.00.05.00.05.01.05.03.02.00.02.01.05.01.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00.05.03.05.01.05.03.02.00.02.01.05.01.05.03.05.03.09.00.05.01.02.00.05.02.05.02.04.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00.05.02.05.01.05.02.02.00.02.01.05.00.05.00.05.03.09.02.05.01.02.00.05.01.05.02.04.00.05.03.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.04.00.05.03.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.01.05.03.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.03.05.01.02.00.05.02.05.00.04.00.05.02.05.01.05.03.02.00.02.01.05.00.05.03.05.03.09.00.05.01.02.00.05.02.05.00.04.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.00.05.01.04.00.05.01.05.01.05.01.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.04.00.05.00.05.01.05.03.02.00.02.01.05.03.05.00.05.03.09.00.05.01.02.00.05.02.05.01.04.02.05.02.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.04.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00.05.02.05.01.05.01.02.00.02.01.05.00.05.03.05.03.09.00.05.01.02.00.05.02.05.02.04.01.05.00.05.01.05.03.02.00.02.01.05.03.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00.05.03.05.01.05.01.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.04.00.05.02.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.04.00.05.03.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.01.05.00.05.01.05.03.02.02.02.01.05.02.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00.05.03.05.01.05.03.02.02.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.02.05.00.05.01.05.03.02.02.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.00.05.01.04.00.05.03.05.01.05.03.02.03.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.04.00.05.00.05.01.05.03.02.03.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.04.02.05.00.05.01.05.03.02.03.02.01.05.01.05.03.05.03.09.00.05.01.02.00.05.01.05.02.04.00.05.00.05.01.05.03.02.03.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00.05.00.05.01.05.03.02.03.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.04.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.04.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.04.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.00.05.01.04.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.04.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.04.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.04.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.04.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.04.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.04.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.00.05.01.04.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.04.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.04.02.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.04.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.04.01.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.04.00.05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.04.00
;array elements		00.01.02.03.04.05.06.07.08.09.0A.0B.0C.0D.0E.0F.10.11.12.13.14.15.16.17.18.19.1A.1B.1C.1D.1E.1F.20.21.22.23.24.25.26.27.28.29.2A.2B.2C.2D.2E.2F.30.31.32.33.34.35.36.37.38.39.3A.3B.3C.3D.3E.3F.40.41.42.43.44.45.46.47.48.49.4A.4B.4C.4D.4E.4F.50.51.52.53.54.55.56.57.58.59.5A.5B.5C.5D.5E.5F.60.61.62.63.64.65.66.67.68.69.6A.6B.6C.6D.6E.6F.70.71.72.73.74.75.76.77.78.79.7A.7B.7C.7D.7E.7F.80.81.82.83.84.85.86.87.88.89.8A.8B.8C.8D.8E.8F.90.91.92.93.94.95.96.97.98.99.9A.9B.9C.9D.9E.9F.A0.A1.A2.A3.A4.A5.A6.A7.A8.A9.AA.AB.AC.AD.AE.AF.B0.B1.B2.B3.B4.B5.B6.B7.B8.B9.BA.BB.BC.BD.BE.BF.C0.C1.C2.C3.C4.C5.C6.C7.C8.C9.CA.CB.CC.CD.CE.CF.D0.D1.D2.D3.D4.D5.D6.D7.D8.D9.DA.DB.DC.DD.DE.DF.E0.E1.E2.E3.E4.E5.E6.E7.E8.E9.EA.EB.EC.ED.EE.EF.F0.F1.F2.F3.F4.F5.F6.F7.F8.F9.FA.FB.FC.FD.FE.FF.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01







;Screen/Tile Draw Variables
SCREEN.DRAW.START_BYTE			.EQ $02				;#CONSTANT		STARTING SCREEN BYTE OF FIRST TILE
SCREEN.DRAW.START_LINE			.EQ	$08				;#CONSTANT		STARTING LINE OF FIRST TILE
SCREEN.DRAW.STOP_BYTE			.EQ $22				;#CONSTANT		STOP SCREEN BYTE ON RIGHT SIDE
SCREEN.DRAW.STOP_LINE			.EQ	$B7				;#CONSTANT		STOP LINE AT SCREEN BOTTOM
SCREEN.DRAW.STOP_LINE2			.EQ	$A7				;#CONSTANT		DRAW.ROW.SINGLE LIKES THIS VALUE FOR SOME REASON, NOT SURE WHY
SCREEN.DRAW.LAST_COLUMN			.EQ	$20				;#CONSTANT		STARTING SCREEN BYTE FOR DRAWN THE COLUMN ON THE RIGHT EDGE OF SCREEN
;SCREEN.DRAW.CURRENT_BYTE		.BS	$1					;1byt			KEEPS TRACK OF THE CURRENT SCREEN BYTE IN DRAW.TILE
SCREEN.DRAW.CURRENT_BYTE		.EQ $9120				;1byt			KEEPS TRACK OF THE CURRENT SCREEN BYTE IN DRAW.TILE

SCREEN.ROW.LAST					.EQ $0A				;#CONSTANT	(!10)
SCREEN.ROW.SIZE					.EQ $11				;#CONSTANT  (!17)
SCREEN.COLUMN.SIZE				.EQ	$0B				;#CONSTANT	(!11)
SCREEN.COLUMN.LAST				.EQ $10				;#CONSTANT	(!16)
;TILE.LINE						.BS	$1				;1byt			KEEPS TRACK OF THE CURRENT LINE IN DRAW.TILE
TILE.LINE						.EQ $9123				;1byt			KEEPS TRACK OF THE CURRENT LINE IN DRAW.TILE

TILE.DEPTH						.EQ $10				;#CONSTANT		# OF LINES IN 1 TILE
;TILE.LINE.START					.BS	$1				;1byt			START LINE OF CURRENT TILE TO BE DRAWN (DRAW.TILE)
TILE.LINE.START					.EQ $9121				;1byt			START LINE OF CURRENT TILE TO BE DRAWN (DRAW.TILE)

;TILE.LINE.STOP					.BS	$1				;1byt			STOP LINE OF CURRENT TILE TO BE DRAWN (DRAW.TILE)
TILE.LINE.STOP					.EQ $9122				;1byt			STOP LINE OF CURRENT TILE TO BE DRAWN (DRAW.TILE)

TILE.LINE.COPY					.BS $1				;1byt			USED FOR COPYING TILES UP/DOWN IN SCROLL.SCREEN AND ITS' SUBROUTINES
SCREEN.ARRAY.LAST_ROW_START		.EQ	$AA				;#CONSTANT		STARTING ARRAY INDEX FOR COPYING TILE DATA INTO SCREEN.TILE.HOPPER
SCREEN.ARRAY.LAST_COLUMN_START	.EQ	$10				;#CONSTANT		STARTING ARRAY INDEX FOR COPYING TILE DATA INTO SCREEN.TILE.HOPPER
SCREEN.ARRAY.LAST_ELEMENT		.EQ	$BA				;#CONSTANT		THE LAST ELEMENT OF SCREEN.TILE.DATA ARRAY
SCREEN.ARRAY.OFFSET				.EQ	$11				;#CONSTANT		OFFSET BETWEEN ROWS WHEN ITERATING THROUGH SCREEN.TILE.ARRAY (SAID ANOTHER WAY, ;NUMBER OF ELEMENTS TO ADVANCE IN SCREEN.TILE.ARRAY TO REFERENCE THE NEXT ROW IN THE SAME COLUMN)	
SCREEN.ARRAY.STOP_VALUE			.BS $01				;1byt			USED TO DETECTED THE END OF DATA WHEN ITERATING THROUGH A COLUMN IN SCREEN.TILE.DATA
SCREEN.ARRAY.PLAYER_LOCATION	.EQ	$5D				;#CONSTANT		CENTER OF THE SCREEN IN THE SCREEN.TILE.DATA ARRAY
SCROLL.STOP_BYTE				.EQ $24				;#CONSTANT		STOP SCREEN BYTE ON RIGHT SIDE WHEN SCREEN SCROLLING
SCROLL.WEST.STOP_BYTE			.EQ $22				;#CONSTANT		STOP SCREEN BYTE ON RIGHT SIDE WHEN SCREEN SCROLLING WEST. NOT SURE WHY THESE NEED TO BE DIFFERENT
SCROLL.STOP.LINE				.EQ $A7				;#CONSTANT		STOP LINE AT BOTTOM WHEN SCREEN SCROLLING
SHP.TBL.CNTR					.BS	$1				;1byt
;GENERIC_COUNTER					.BS $1				;1byt
PAGE.BACKGROUND.SAVE			.BS $1

;MAP POSITION VARIABLES
;
;TILE ID number							not a variable, but is term used to describe the value stored in GMAP, from which other variables such as SMAP, SMAP.CURRENT, and GMAP.LOOKUP are dervied. The tile ID is a unique reference number to a specific tile on the map (from a human perspective). To the computer it is meaningful because the value of Tile ID is also equal to the quantity of tiles on the map in GMAP.TILE.DATA up to and including the tile assocaited with Tile ID. 
;GMAP					.BS $2			;Tracks the position on the map in computer terms. Specifically, it is the tile ID number of the tile at the center of the screen where the player stands. 
GMAP					.EQ $9124
GMAP.X					.BS	$1			;Future use. compass tracking, longitude. 
GMAP.Y					.BS $1			;Future use. compass tracking, latitude. 
SMAP					.EQ $9110		;2byt
SMAP.CURRENT			.EQ $9112		;2byt


;MAP MOVEMENT OFFSETS
OFFSET.UP				.EQ $40		;#CONSTANT (negative offset)
OFFSET.DOWN				.EQ $40		;#CONSTANT
;OFFSET.LEFT			.EQ $01		;NOT USED BECAUSE LEFT IS ALWAYS -1 (DEX/DEY)
;OFFSET.RIGHT			.EQ $01		;NOT USED BECAUSE RIGHT IS ALWAYS +1 (INX/INY) 
OFFSET.SCREEN			.EQ	$149	;#CONSTANT (negative offset)
OFFSET.SCREEN.LZ		.EQ	$148	;#CONSTANT
OFFSET.SCREEN.LL		.EQ $137	;#CONSTANT

				.IN 	C:\MY_CODE\INCLUDES_LIBS\darkness_functions
				
				
				
; RAW DATA FOR 64X64 TILE MAP (1 MAP ROW PER LINE X 64 LINES)


;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.03.05.01.02.00.05.02.05.00.04.00
;05.01.05.01.05.03.02.00.02.01.05.01.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.02
;05.00.05.02.05.03.02.00.02.01.05.02.05.00.05.03.09.00.05.01.02.00.05.00.05.01.04.00
;05.02.05.02.05.03.02.00.02.01.05.03.05.00.05.03.09.00.05.01.02.00.05.02.05.02.04.00
;05.02.05.03.05.03.02.00.02.01.05.03.05.00.05.03.09.00.05.01.02.00.05.02.05.01.04.02
;05.00.05.03.05.03.02.00.02.01.05.03.05.00.05.03.09.00.05.01.02.00.05.01.05.02.04.00
;05.01.05.01.05.03.02.00.02.01.05.01.05.00.05.03.09.02.05.01.02.00.05.02.05.00.04.00
;05.00.05.01.05.03.02.00.02.01.05.01.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00
;05.03.05.01.05.03.02.00.02.01.05.01.05.03.05.03.09.00.05.01.02.00.05.02.05.02.04.01
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00
;05.02.05.01.05.02.02.00.02.01.05.00.05.00.05.03.09.02.05.01.02.00.05.01.05.02.04.00
;05.03.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.04.00
;05.03.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.01
;05.03.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.03.05.01.02.00.05.02.05.00.04.00
;05.02.05.01.05.03.02.00.02.01.05.00.05.03.05.03.09.00.05.01.02.00.05.02.05.00.04.02
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.00.05.01.04.00
;05.01.05.01.05.01.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.04.00
;05.00.05.01.05.03.02.00.02.01.05.03.05.00.05.03.09.00.05.01.02.00.05.02.05.01.04.02
;05.02.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.04.00
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00
;05.02.05.01.05.01.02.00.02.01.05.00.05.03.05.03.09.00.05.01.02.00.05.02.05.02.04.01
;05.00.05.01.05.03.02.00.02.01.05.03.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00
;05.03.05.01.05.01.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.04.00
;05.02.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.04.00
;05.03.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.01
;05.00.05.01.05.03.02.02.02.01.05.02.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00
;05.03.05.01.05.03.02.02.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.02
;05.00.05.01.05.03.02.02.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.00.05.01.04.00
;05.03.05.01.05.03.02.03.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.04.00
;05.00.05.01.05.03.02.03.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.04.02
;05.00.05.01.05.03.02.03.02.01.05.01.05.03.05.03.09.00.05.01.02.00.05.01.05.02.04.00
;05.00.05.01.05.03.02.03.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00
;05.00.05.01.05.03.02.03.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.04.01
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.04.00
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.04.00
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.01
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.02
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.00.05.01.04.00
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.04.00
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.04.02
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.04.00
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.04.01
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.04.00
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.04.00
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.01
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.02
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.00.05.01.04.00
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.04.00
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.04.02
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.04.00
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.02.04.01
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.00.04.00
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.01.05.02.04.00
;05.00.05.01.05.03.02.00.02.01.05.00.05.00.05.03.09.00.05.01.02.00.05.02.05.01.04.00
